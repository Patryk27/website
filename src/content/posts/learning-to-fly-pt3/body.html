<p>
  This is the third part of the <b>Learning to Fly</b> series in which we're
  coding a simulation of evolution using <b>neural network</b> and <b>genetic
  algorithm</b>:
</p>

<figure>
  <a href="https://shorelark.pwy.io">
    <img src="/posts/learning-to-fly-pt1/assets/intro-outcome.png" />
  </a>

  <figcaption>
    <a href="https://shorelark.pwy.io" />
  </figcaption>
</figure>

<p>
  In the previous post we implemented a simple feed-forward neural network that
  could propagate numbers through its randomized layers - it was the first
  milestone in our effors to create a functioning brain.
</p>

<p>
  Randomness can get us only so far, though - for the most part, evolution is
  about making small, incremental changes so that the system gets better over
  time -- so that our brains begin to accumulate knowledge and function as we
  expect them (just catch the food, birdies!).
</p>

<p>
  But how can we <b>train</b> a bunch of floating-point numbers?
</p>

<hdr id="plan">
  Plan
</hdr>

<p>
  <ref id="selection">
    https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)
  </ref>

  <ref id="crossover">
    https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)
  </ref>

  <ref id="mutation">
    https://en.wikipedia.org/wiki/Mutation_(genetic_algorithm)
  </ref>

  Today we'll learn how a genetic algorithm works by implementing one in Rust.
  We'll examine in-depth how <a ref="selection">selection</a>,
  <a ref="crossover">crossover</a> and <a ref="mutation">mutation</a> all come
  together and allow for the computer to find complex solutions seemingly out of
  thin air.
</p>

<p>
  We'll try to remain generic, meaning that instead of hard-coding a particular
  selection or crossover algorithm, we'll use traits to create a library that
  could be even published to <a href="https://crates.io">crates.io</a>!
</p>

<p>
  As in the previous part, so we'll investigate various intricacies of
  Rust's syntax today, focusing a lot on the terminology.
</p>

<p>
  Hopefully, by the end of this post you'll be able to say: I could've
  implemented all this on my own!
</p>

<hdr id="intro">
  Introduction
</hdr>

<p>
  First, let's recap how a genetic algorithm works and what's the point of this
  venture.
</p>

<p>
  Our problem is that we've got an object - a neural network - that's defined by
  a whole lot of <b>parameters</b>. There are so many of them that, even for the
  smallest of networks, we couldn't possibly brute-force all of their
  combinations in our lifetime.
</p>

<note>
  <p>
    All the possible parameters in general are called a <b>search space</b>; an
    erudite would say that our problem's search space is <i>huuuuge</i> and then
    run away.
  </p>
</note>

<p>
  What we <i>can</i> do is to kinda mimic the nature: if we started with a bunch
  of random <b>suboptimal</b> solutions, we could try improving them to get -
  over time - gradually better answers.
</p>

<p>
  One of the methods that allows to simulate all this evolutionary machinery is
  the eponymous <b>genetic algorithm</b> - it starts with a bunch of random
  solution-candidates (a <b>population</b>), which are then improved using
  <b>mutation</b> and <b>crossover</b>, utilizing a <b>fitness function</b> to
  evaluate solutions (<b>individuals</b>) found so far:
</p>

<figure class="sketch w-80">
  <img src="{{ assets }}/intro-1.svg" />

  <figcaption>
    Overview of the genetic algorithm; starting from top and and going
    clockwise: (1) estimating current solutions with a fitness function, (2)
    performing crossover and mutation, (3) starting the entire proces over on
    the new, improved population
  </figcaption>
</figure>

<note>
  <p>
    Because genetic algorithm involves working on random numbers, it's an
    example of a
    <a href="https://en.wikipedia.org/wiki/Randomized_algorithm">
      probabilistic method
    </a>.
  </p>

  <p>
    Probabilistic algorithms trade <b>accuracy</b> for <b>performance</b> - they
    don't always return the best answers, but usually get
    <i>Pretty Close Pretty Cheaply ®</i>.
  </p>
</note>

<p>
  Vegetable manufacturers don't want you to know this, but there exists a
  straightforward procedure to becoming a carrot tycoon that's based on a
  enetic algorithm:
</p>

<code lang="text">
  <!--
    10  go to your garden
    20  sow a few random carrots
    30  wait for those carrots to sprout
    40  choose the best carrot-children and sow them
    50  goto 30
    
    in this world:
    - population = carrots
    - individual = carrot
    - mutation & crossover = happen automatically (free labor!)
    - fitness function = your eyes & brain
  -->
</code>

<p>
  By now, most of those words ought to sound familiar to you - we've already
  gone through the basics of evolutionary computation in the first article; by
  the end of this article, you'll have answered questions such as:
</p>

<ul>
  <li>
    <p>
      but how do you <b>choose</b> the individuals? there must be like a
      thousand ways to do it! <br />
      <i>(psst: oh my yes, there are)</i>
    </p>
  </li>
  <li>
    <p>
      but how do you <b>represent</b> their genomes? there must be like a
      thousand ways to do it! <br />
      <i>(psst: oh my yes, there are)</i>
    </p>
  </li>
  <li>
    <p>
      but how do you <b>implement</b> it in Rust? you promised it'll work inside
      a web browser! <br />
      <i>(psst: oh my yes, it will)</i>
    </p>
  </li>
</ul>

<hdr id="coding-outline">
  Coding: Outline
</hdr>

<p>
  We'll start by creating a second crate inside our workspace:
</p>

<code lang="shell">
  <!--
    $ cd shorelark/libs
    $ cargo new genetic-algorithm --name lib-genetic-algorithm --lib
  -->
</code>

<p>
  That's some nice <code>lib.rs</code> Cargo created for us - let's replace it
  with an entry point:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
  = pub struct GeneticAlgorithm;
  -->
</code>

<p>
  Our genetic algorithm will provide only one functionality - sometimes it's
  called <code>iterate</code>, sometimes it's called <code>step</code> or
  <code>process</code> - I've tossed a coin and decided on:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    impl GeneticAlgorithm {
  =     pub fn evolve(&self) {
  =         todo!()
  =     }
    }
  -->
</code>

<p>
  What are we evolving? A population, of course!
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    impl GeneticAlgorithm {
        pub fn evolve(&self, population: &[???]) -> Vec<???> {
            todo!()
        }
    }
  -->
</code>

<p>
  Our actual problem will depend on neural networks, but since we want for this
  library to be generic, we can't force it to accept a hard-coded
  <code>NeuralNetwork</code> - instead, we can introduce a <b>type
    parameter</b>:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    impl GeneticAlgorithm {
  =     pub fn evolve<I>(&self, population: &[I]) -> Vec<I> {
            todo!()
        }
    }
  -->
</code>

<note>
  <p>
    <code>I</code> stands for <b>individual</b> - as for the Rust's terminology:
  </p>

  <code lang="rust">
    <!--
      // visibility  generics   _ function parameters
      // |          _|     ____|  (or just "parameters")
      // |         |      |
      // v-v       v-----vv----------v
         pub fn foo<'a, T>(bar: &'a T) { /* ... */ }
      //            ^^  ^  ^--------^
      //            |   |  |
      //            |   |  function parameter
      //            |   |  (or just "parameter")
      //            |   type parameter
      //            lifetime parameter
    -->
  </code>

  <p class="text-attached">
    (<a href="https://doc.rust-lang.org/reference/items/functions.html" />)
  </p>

  <p>
    If you wanted to read this signature aloud, you'd say:
  </p>

  <blockquote>
    <p>
      public function <code>foo</code> is <b>generic over</b> lifetime
      <code>a</code> and type <code>T</code>, and it <b>accepts</b> a single
      parameter named <code>bar</code> which is a reference to <code>T</code>.
    </p>
  </blockquote>

  <p>
    That was function's <b>definition</b> - on the other hand, the place where
    you <b>invoke</b> a function is named <b>call site</b> and the values you
    specify there are called <b>arguments</b>:
  </p>

  <code lang="rust">
    <!--
      // v-----------------------v call site
         foo::<'static, f32>(&1.0);
      //       ^-----^  ^-^  ^--^
      //       |        |    |
      //       |        |    function argument
      //       |        |    (or just "argument")
      //       |        type argument
      //       lifetime argument
    -->
  </code>

  <p>
    Most of this vernacular (e.g. the difference between an argument and a
    parameter) is universal across all the programming languages, so it's worth
    remembering.
  </p>
</note>

<p>
  Learning from past mistakes, let's not forget about <b>preconditions</b>:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    impl GeneticAlgorithm {
        pub fn evolve<I>(&self, population: &[I]) -> Vec<I> {
  =         assert!(!population.is_empty());

            /* ... */
        }
    }
  -->
</code>

<p>
  As for the algorithm itself - the outline is:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    impl GeneticAlgorithm {
        pub fn evolve<I>(&self, population: &[I]) -> Vec<I> {
            /* ... */

  =         (0..population.len())
  =             .map(|_| {
  =                 // TODO selection
  =                 // TODO crossover
  =                 // TODO mutation
  =                 todo!()
  =             })
  =             .collect()
        }
    }
  -->
</code>

<hdr id="coding-selection">
  Coding: Selection
</hdr>

<p>
  At this point, inside the loop, we have to pick two individuals - they will
  become parents and "create" a digital offspring for us.
</p>

<p>
  <ref>
    https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)
  </ref>

  Choosing individuals is called the <a>selection stage</a> of a genetic
  algorithm and it should satisfy the following two properties:
</p>

<ul>
  <li>
    <p>
      each individual should have a <b>non-zero</b> chance of being picked,
    </p>
  </li>
  <li>
    <p>
      an individual with a higher fitness score should get picked, on average,
      <b>more often</b> than an individual with a lower fitness score.
    </p>
  </li>
</ul>

<p>
  Because we have to calculate fitness scores, let's start by thinking how we
  want users to provide their <b>fitness function</b> - as trivial as it sounds,
  there are at least two exclusive approaches here:
</p>

<ol>
  <li>
    <p>
      Fitness function as a <i>parameter</i> of an individual:
    </p>

    <code-title>
      libs/genetic-algorithm/src/lib.rs
    </code-title>

    <code lang="rust">
      <!--
        impl GeneticAlgorithm {
            pub fn evolve<I>(
                &self,
                population: &[I],
                evaluate_fitness: &dyn Fn(&I) -> f32,
            ) -> Vec<I> {
                /* ... */
            }
        }
      -->
    </code>
  </li>

  <li>
    <p>
      Fitness score as a <i>property</i> of an individual:
    </p>

    <code-title>
      libs/genetic-algorithm/src/lib.rs
    </code-title>

    <code lang="rust">
      <!--
      = pub trait Individual {
      =     fn fitness(&self) -> f32;
      = }

        impl GeneticAlgorithm {
      =     pub fn evolve<I>(&self, population: &[I]) -> Vec<I>
      =     where
      =         I: Individual,
      =     {
                /* ... */
            }
        }
      -->
    </code>
  </li>
</ol>

<p>
  First approach:
</p>

<ul>
  <li>
    <p>
      ✅ allows to provide many different fitness functions for one kind of an
      individual, which might prove to be useful for somebody (not us, though),
    </p>
  </li>
  <li>
    <p>
      ❌ requires specifying fitness function for each invocation of
      <code>.evolve()</code>, which feels a bit awkward.
    </p>
  </li>
</ul>

<p>
  Second approach:
</p>

<ul>
  <li>
    <p>
      ✅ allows to <b>encapsulate</b> all the individual-oriented attributes
      into a single trait, making it easy for users to discover what they need
      to provide,
    </p>
  </li>
  <li>
    <p>
      ❌ specifying different fitness functions is possible, but a bit more
      tricky.
    </p>
  </li>
</ul>

<p>
  My guts vote 213:7 for introducing a trait (a trait that, as you'll see later,
  we would need anyway), so a trait it is.
</p>

<p>
  <ref>
    https://www.tutorialspoint.com/genetic_algorithms/genetic_algorithms_parent_selection.htm
  </ref>

  As for the selection method, we'll use an algorithm called <a>fitness
  proportionate selection</a> (also known as <b>roulette wheel selection</b>),
  because it's easy to reason about - to understand how it works, let's imagine
  we've got the following three individuals:
</p>

<table>
  <colgroup>
    <col style="width: 20%" />
    <col style="width: 20%" />
    <col style="width: 60%" />
  </colgroup>
  <thead>
    <tr>
      <th>Individual</th>
      <th>Fitness score</th>
      <th>Fitness score %</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <p>
          A
        </p>
      </td>
      <td>
        <p>
          3
        </p>
      </td>
      <td>
        <p>
          <code>3 / (1 + 2 + 3)</code> = <code>3 / 6</code> = <code>50%</code>
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <p>
          B
        </p>
      </td>
      <td>
        <p>
          2
        </p>
      </td>
      <td>
        <p>
          <code>2 / (1 + 2 + 3)</code> = <code>2 / 6</code> = <code>33%</code>
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <p>
          C
        </p>
      </td>
      <td>
        <p>
          1
        </p>
      </td>
      <td>
        <p>
          <code>1 / (1 + 2 + 3)</code> = <code>1 / 6</code> = <code>16%</code>
        </p>
      </td>
    </tr>
  </tbody>
</table>

<p>
  If we placed them all on a roulette wheel - or a pie chart, for all it matters
  - with each individual getting a slice of wheel as large as proportion of
  their fitness score to the entire population:
</p>

<figure class="sketch w-50">
  <img src="{{ assets }}/coding-selection-1.svg" />

  <figcaption>
    A pie chart (roulette wheel, if you squeeze your eyes enough) illustrating
    individuals from the table above
  </figcaption>
</figure>

<p>
  ... then randomizing an individual would boil down to "spinning" the wheel
  with random amount of force and seeing what comes up:
</p>

<figure class="sketch w-50">
  <img src="{{ assets }}/coding-selection-2.svg" />
</figure>

<note>
  <p>
    In practice, fitness proportionate selection is rather frowned upon - it's
    because it allows for the best individuals to <b>dominate</b> the
    simulation.
  </p>

  <p>
    Say, your genetic algorithm finds a solution that's waaaay better than the
    rest:
  </p>

  <figure class="sketch w-50">
    <img src="{{ assets }}/coding-selection-3.svg" />
  </figure>

  <p>
    ... when it happens, the fitness proportionate selection will happily choose
    this green solution 99% of the time, making rest of the individuals an army
    of copy-pasted, green clones.
  </p>

  <p>
    You might think:
  </p>

  <blockquote>
    <p>
      but isn't finding the best solution, like, the whole point?
    </p>
  </blockquote>

  <p>
    ... which it is - but it's important to remember that solutions found by
    genetic algorithm are always best <b>to date</b> - if you discard a
    <i>seemingly</i> unpromising candidate too early, you will never know
    whether tuning some parameter wouldn't make it an even better solution
    <i>in the long run</i>.
  </p>

  <p>
    To put it another way:
  </p>

  <blockquote>
    <p>
      the more <b>diverse</b> humans you have, the greater chance that one of
      them happens to be a trombone prodigy
    </p>
  </blockquote>

  <p>
    For simplicity, we'll continue with the roulette wheel selection - but
    should you feel frisky, I'll just say that <b>rank selection</b> is example
    of an algorithm that doesn't exhibit this dominating behavior and it will
    work with our birdies, too!
  </p>
</note>

<p>
  Living up to the genericness promise, instead of hard-coding our library to
  use roulette wheel selection, let's create a trait - this way users will be
  able to provide any algorithm they fancy:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
  = pub trait SelectionMethod {
  =     fn select(&self);
  = }
  -->
</code>

<p>
  A selection method has to have access to the entire population:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    pub trait SelectionMethod {
  =     fn select<I>(&self, population: &[I]) -> &I
  =     where
  =         I: Individual;
    }
  -->
</code>

<p>
  ... and, for clarity, let's annotate the lifetime:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    pub trait SelectionMethod {
  =     fn select<'a, I>(&self, population: &'a [I]) -> &'a I
  =     where
  =         I: Individual;
    }
  -->
</code>

<p>
  We're going to need random numbers any minute now, so:
</p>

<code-title>
  libs/genetic-algorithm/Cargo.toml
</code-title>

<code lang="toml">
  <!--
    # ...
    
    [dependencies]
  = rand = "0.8"
  =
  = [dev-dependencies]
  = rand_chacha = "0.3"
  -->
</code>

<note>
  <p>
    Each crate in a workspace has <b>its own</b> set of dependencies - the
    <code>rand</code> we've previously added to
    <code>libs/neural-network/Cargo.toml</code> isn't automatically
    shared with other crates within the workspace.
  </p>
</note>

<p>
  Learning from our past troubles with <code>thread_rng()</code>, let's pass the
  PRNG via a parameter:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
  = use rand::RngCore;

    /* ... */

    pub trait SelectionMethod {
  =     fn select<'a, I>(&self, rng: &mut dyn RngCore, population: &'a [I]) -> &'a I
        where
            I: Individual;
    }
  -->
</code>

<p>
  Ain't that a beautiful signature?
</p>

<note>
  <p>
    You might be wondering why we don't take a step further and make
    <code>select()</code> generic over the PRNG, too:
  </p>

  <code lang="rust">
    <!--
      pub trait SelectionMethod {
          fn select<'a, R, I>(
             &self,
             rng: &mut R,
             population: &'a [I],
          ) -> &'a I
          where
              R: RngCore,
              I: Individual;
      }
    -->
  </code>

  <p>
    First, let's catch up on the vernacular:
  </p>

  <ol>
    <li>
      <p>
        <code>dyn Trait</code>, <code>&dyn Trait</code> and
        <code>&mut dyn Trait</code> imply <b>dynamic dispatch</b>,
      </p>
    </li>
    <li>
      <p>
        <code>T</code>, <code>&T</code> and <code>&mut T</code> imply
        <b>static dispatch</b>.
      </p>
    </li>
  </ol>

  <p>
    Dispatching is the way compiler answers the question "where should we jump,
    exactly?" for generic types:
  </p>

  <code lang="rust">
    <!--
      fn foo() {
         bar();
      
         // ^ compiling this call is easy, because it always jumps into `bar`
      }
      
      fn bar() {
         println!("yas queen");
      }
      
      fn method(obj: &dyn SomeTrait) {
          obj.method();
      
          // ^ compiling this call is harder, because there's no single function
          //   this refers to - each implementation of `SomeTrait` provides its
          //   own `fn method(&self) { ... }`
      }
    -->
  </code>

  <p>
    For the sake of an example, let's consider this trait with its two
    implementations:
  </p>

  <code lang="rust">
    <!--
      trait Animal {
          fn kind(&self) -> &'static str;
      }
      
      // --
      
      struct Chinchilla;
      
      impl Animal for Chinchilla {
          fn kind(&self) -> &'static str {
              "chinchilla"
          }
      }
      
      // --
      
      struct Viscacha;
      
      impl Animal for Viscacha {
          fn kind(&self) -> &'static str {
              "viscacha"
          }
      }
    -->
  </code>

  <p>
    If you wanted to create a function that prints the kind of any animal, you
    could do it twofold:
  </p>

  <code-title>
    <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d5d734320717f0fda4d16de1f2600764">
      open in playground
    </a>
  </code-title>

  <code lang="rust">
    <!--
      // Using static dispatch (aka static polymorphism):
      fn print_kind_static<A>(animal: &A)
      where
          A: Animal,
      {
          println!("{}", animal.kind());
      }
      
      // Using dynamic dispatch (aka dynamic polymorphism, aka runtime polymorphism):
      fn print_kind_dynamic(animal: &dyn Animal) {
          println!("{}", animal.kind());
      }
      
      fn main() {
          print_kind_static(&Chinchilla);
          print_kind_static(&Viscacha);
      
          print_kind_dynamic(&Chinchilla);
          print_kind_dynamic(&Viscacha);
      }
    -->
  </code>

  <p>
    From a distance, both function look alike - what's the difference, then?
  </p>

  <p>
    <code>print_kind_static()</code> uses a technique called
    <b>monomorphization</b> - meaning that for each <code>Animal</code> this
    function is called with, the compiler transparently generates a dedicated,
    "copy-pasted" version of that function:
  </p>

  <code lang="rust">
    <!--
      fn print_kind_static__chinchilla(animal: &Chinchilla) {
          println!("{}", Chinchilla::kind(animal));
      }
      
      fn print_kind_static__viscacha(animal: &Viscacha) {
          println!("{}", Viscacha::kind(animal));
      }
      
      fn main() {
          print_kind_static__chinchilla(&Chinchilla);
          print_kind_static__viscacha(&Viscacha);
      }
    -->
  </code>

  <p>
    At this point you can see why it's called <i>static</i> dispatch -
    underneath, the compiler replaces dynamic traits with static types.
  </p>

  <p>
    Monomorphization has a drawback of being a bit slower to compile (instead of
    just one function, the compiler has to process many of them), but usually it
    results in a faster, more optimized code at runtime - it can make a
    noticeable difference for applications that call such generic functions,
    say, million times per second.
  </p>

  <p>
    <code>print_kind_dynamic()</code>, on the other hand, uses a technique
    called <b>vtable</b> ("virtual table"), where each implementation gets
    created a dedicated table mapping to concrete functions:
  </p>

  <code lang="rust">
    <!--
      // (this is pseudo-Rust, just to show the concept)
      
      struct AnimalVtable {
          // Reference to a specific `kind()` function
          kind: fn(*const ()) -> &'static str,
      }
      
      const CHINCHILLA_VTABLE: AnimalVtable = AnimalVtable {
          kind: Chinchilla::kind,
      };
      
      const VISCACHA_VTABLE: AnimalVtable = AnimalVtable {
          kind: Viscacha::kind,
      };
      
      fn print_kind_dynamic(
          animal_obj: *const (),
          animal_vtable: &AnimalVtable,
      ) {
          println!("{}", animal_vtable.kind(animal_obj));
      }
      
      fn main() {
          print_kind_dynamic(&Chinchilla, &CHINCHILLA_VTABLE);
          print_kind_dynamic(&Viscacha, &VISCACHA_VTABLE);
      }
    -->
  </code>

  <p>
    Since all implementations can be described via <code>AnimalVtable</code>,
    <code>print_kind_dynamic()</code> doesn't have to be monomorphized -
    depending on the underlying type, the compiler will simply pass different
    vtable.
  </p>

  <p>
    In this case, the drawback is that each time you call
    <code>print_kind_dynamic()</code>, it has to go through this additional
    "proxy table", which makes it theoretically slower than
    <code>print_kind_static()</code> - more often than not the difference is not
    meaningful, though.
  </p>

  <p>
    Circling back to the original question: so why not
    <code>where R: RngCore</code>?
  </p>

  <p>
    Because we won't be invoking this method million times per second, the extra
    hassle here is not worth it.
  </p>
</note>

<p>
  As for the implementation:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
  = pub struct RouletteWheelSelection;
  =
  = impl SelectionMethod for RouletteWheelSelection {
  =     fn select<'a, I>(&self, rng: &mut dyn RngCore, population: &'a [I]) -> &'a I
  =     where
  =         I: Individual,
  =     {
  =         todo!()
  =     }
  = }
  -->
</code>

<p>
  ... we <i>could</i> do it by hand:
</p>

<code lang="rust">
  <!--
    impl SelectionMethod for RouletteWheelSelection {
        fn select<'a, I>(&self, rng: &mut dyn RngCore, population: &'a [I]) -> &'a I
        where
            I: Individual,
        {
            let total_fitness: f32 = population
                .iter()
                .map(|individual| individual.fitness())
                .sum();
    
            // This is a naïve approach for demonstration purposes - a more
            // efficient implementation would invoke `rng` just once
            loop {
                let indiv = population
                    .choose(rng)
                    .expect("got an empty population");
    
                let indiv_share = indiv.fitness() / total_fitness;
    
                if rng.gen_bool(indiv_share as f64) {
                    return indiv;
                }
            }
        }
    }
  -->
</code>

<p>
  ... but a code <i>par excellence</i> would be <i>&lt;drums /&gt;</i>
  <b>no code at all</b>!
</p>

<p>
  <ref id="doc1">
    https://docs.rs/rand/0.8.3/rand/
  </ref>

  <ref id="doc2">
    https://docs.rs/rand/0.8.3/rand/seq/trait.SliceRandom.html
  </ref>

  <ref id="doc3">
    https://docs.rs/rand/0.8.3/rand/seq/trait.SliceRandom.html#tymethod.choose_weighted
  </ref>

  If you go through the <a ref="doc1"><code>rand</code>'s documentation</a>, you
  might just spot a trait called <a ref="doc2"><code>SliceRandom</code></a> - if
  you take a look inside it, you might just spot a method called
  <a ref="doc3"><code>choose_weighted()</code></a> that happens to be doing
  exactly the exact thing we need:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
  = use rand::seq::SliceRandom;
  = use rand::{Rng, RngCore};

    /* ... */

    impl SelectionMethod for RouletteWheelSelection {
        fn select<'a, I>(&self, rng: &mut dyn RngCore, population: &'a [I]) -> &'a I
        where
            I: Individual,
        {
  =         population
  =             .choose_weighted(rng, |individual| individual.fitness())
  =             .expect("got an empty population")
        }
    }
  -->
</code>

<p class="text-attached">
  (thanks to <a href="https://github.com/javiertury">@javiertury</a> for
  <a href="https://github.com/Patryk27/shorelark/pull/2">pointing out that
  this method exists</a>.)
</p>

<p>
  Apart from trusting <code>rand</code> developers, how can we be sure
  <code>choose_weighted()</code> does the thing we need? By testing it!
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
  = #[cfg(test)]
  = mod tests {
  =     use super::*;
  =
  =     #[test]
  =     fn roulette_wheel_selection() {
  =         todo!();
  =     }
  = }
  -->
</code>

<p>
  Path to the TDD-nirvana is strawn with roses and we're about to get bit by one
  of their thorns:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        use super::*;
  =     use rand::SeedableRng;
  =     use rand_chacha::ChaCha8Rng;

        #[test]
        fn roulette_wheel_selection() {
  =         let mut rng = ChaCha8Rng::from_seed(Default::default());
  =
  =         let population = vec![ /* what here? */ ];
  =         let actual = RouletteWheelSelection::new().select(&mut rng, &population);
  =
  =         assert!(/* what here? */);
        }
    }
  -->
</code>

<p>
  At this point we've got two problems:
</p>

<ol>
  <li>
    <p>
      Since <code>Individual</code> is a trait, how can we fake it for testing
      purposes?
    </p>
  </li>
  <li>
    <p>
      <ref>
        https://xkcd.com/221/
      </ref>

      Since <code>.select()</code> returns just a single individual, how can we
      be sure it's <a>random?</a>
    </p>
  </li>
</ol>

<p>
  Starting from the top: creating fake objects for testing purposes is called
  <b>mocking</b> - and while
  <a href="https://docs.rs/mockall/0.9.1/mockall/">there are</a> mocking
  solutions for Rust, I gotta admit I've never been a fan of the concept of a
  mock, as best presented
  <a href="https://www.youtube.com/watch?v=LI_Oe-jtgdI">in a song</a>:
</p>

<code lang="text">
  <!--
    Friend, either you're closing your eyes
    To a situation you do not wish to acknowledge
    Or you are not aware of the caliber of disaster indicated
    By the presence of mocks in your repository
    
    [...]
    
    Oh yes we got trouble, trouble, trouble!
    With a "T"! Gotta rhyme it with "M"!
    And that stands for Mock
  -->
</code>

<p>
  My suggestion - one that doesn't require any external crates - it to create a
  dedicated testing-struct:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        /* ... */

  =     #[derive(Clone, Debug)]
  =     struct TestIndividual {
  =         fitness: f32,
  =     }
  =
  =     impl TestIndividual {
  =         fn new(fitness: f32) -> Self {
  =             Self { fitness }
  =         }
  =     }
  =
  =     impl Individual for TestIndividual {
  =         fn fitness(&self) -> f32 {
  =             self.fitness
  =         }
  =     }

        /* ... */
    }
  -->
</code>

<p>
  ... which we can then use as:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        /* ... */

        #[test]
        fn roulette_wheel_selection() {
            /* ... */

  =         let population = vec![
  =             TestIndividual::new(2.0),
  =             TestIndividual::new(1.0),
  =             TestIndividual::new(4.0),
  =             TestIndividual::new(3.0),
  =         ];

            /* ... */
        }
    }
  -->
</code>

<p>
  What about the assertion, though? A test such as this one:
</p>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        /* ... */

        #[test]
        fn roulette_wheel_selection() {
            /* ... */

            let actual = RouletteWheelSelection::new()
                .select(&mut rng, &population);

            assert!(actual, &population[2]);
        }
    }
  -->
</code>

<p>
  ... doesn't inspire confidence, because it doesn't <b>prove</b> that the
  fitness scores are actually being considered - a totally invalid
  implementation such as:
</p>

<code lang="rust">
  <!--
    impl SelectionMethod for RouletteWheelSelection {
        fn select<'a, I>(/* ... */) -> &'a I
        where
            I: Individual,
        {
            &population[2]
        }
    }
  -->
</code>

<p>
  ... would pass such test with <span class="text-rainbow">flying colors</span>!
</p>

<p>
  Fortunately, we are not doomed - since we want to assess probability, instead
  of calling <code>.select()</code> just once, we can do it many times and look
  at the histogram:
</p>

<figure class="sketch">
  <img src="{{ assets }}/coding-selection-4.svg" />

  <figcaption>
    <ref>
      https://duckduckgo.com/?q=johnny+bravo&amp;t=h_&amp;iax=images&amp;ia=images
    </ref>

    <code>X</code> axis represents items, <code>Y</code> axis represents
    frequency; I hereby dub it <a>The Johnny Bravo Chart</a>
  </figcaption>
</figure>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        /* ... */
  =     use std::collections::BTreeMap;
  =     use std::iter::FromIterator;
    
        #[test]
        fn roulette_wheel_selection() {
            let mut rng = ChaCha8Rng::from_seed(Default::default());

            let population = vec![
                /* ... */
            ];

  =         let mut actual_histogram = BTreeMap::new();
  =
  =         //          /--| nothing special about this thousand;
  =         //          v  | a number as low as fifty might do the trick, too
  =         for _ in 0..1000 {
  =             let fitness = RouletteWheelSelection
  =                 .select(&mut rng, &population)
  =                 .fitness() as i32;
  =
  =             *actual_histogram
  =                 .entry(fitness)
  =                 .or_insert(0) += 1;
  =         }
  =
  =         let expected_histogram = BTreeMap::from_iter([
  =             // (fitness, how many times this fitness has been chosen)
  =             (1, 0),
  =             (2, 0),
  =             (3, 0),
  =             (4, 0),
  =         ]);
  =
  =         assert_eq!(actual_histogram, expected_histogram);
        }
    }
  -->
</code>

<note>
  <p>
    Notice that while building the histogram, we're <b>casting</b> fitness
    scores from <code>f32</code> to <code>i32</code>:
  </p>

  <code lang="rust">
    <!--
      let fitness = RouletteWheelSelection
          .select(&mut rng, &population)
          .fitness() as i32;
    -->
  </code>

  <p>
    <ref>
      https://doc.rust-lang.org/std/cmp/trait.Ord.html
    </ref>

    We have to do that, because floating-point numbers in Rust don't implement
    the <a><code>Ord</code></a> trait, making it impossible to use them as a
    <code>BTreeMap</code>'s key:
  </p>

  <code-title>
    <a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=535648a70ce2e61f12b8c38021fddbef">
      open in playground
    </a>
  </code-title>

  <code lang="rust">
    <!--
      use std::collections::BTreeMap;
      
      fn main() {
          let mut map = BTreeMap::new();
          map.insert(1.0, "one point zero");
      }
    -->
  </code>

  <code lang="text">
    <!--
      error[E0277]: the trait bound `{float}: Ord` is not satisfied
        |
        |     map.insert(1.0, "one point zero");
        |         ^^^^^^ the trait `Ord` is not implemented for `{float}`
    -->
  </code>

  <p>
    The reason is that floating-point numbers, as defined by the
    <a href="https://floating-point-gui.de/">IEEE 754</a> standard, are not a
    <a href="https://en.wikipedia.org/wiki/Total_order">totally ordered set</a>
    - namely, comparing
    <a href="https://en.wikipedia.org/wiki/NaN#Comparison_with_NaN">NaN</a>s is
    problematic, because:
  </p>

  <code lang="text">
    <!--
      NaN != NaN
    -->
  </code>

  <p>
    What this means in practice is that if you were able to insert a
    <code>NaN</code> into a map, you not only wouldn't be able to retrieve it
    back, but that could also break <code>BTreeMap</code>'s internal data
    structures, making it impossible to retrieve any other item as well.
  </p>

  <p>
    <i>
      <ref id="assym">
        https://en.wikipedia.org/wiki/Asymmetry#In_mathematics
      </ref>

      <ref id="trans">
        https://simple.wikipedia.org/wiki/Transitivity_(mathematics)
      </ref>

      (by the way, that's also true for custom implementations of
      <code>Ord</code> and <code>PartialOrd</code> - if they don't satisfy
      <a ref="assym">asymmetry</a> and <a ref="trans">transitivity</a>, you're
      gonna have a bad time.)
    </i>
  </p>

  <p>
    If you feel like exploring this topic more:
  </p>

  <ul>
    <li>
      <p>
        <a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html" />
      </p>
    </li>
    <li>
      <p>
        <a href="https://www.reddit.com/r/rust/comments/cbrpll/why_doesnt_stdcmpord_is_implemented_for_floats/" />
      </p>
    </li>
    <li>
      <p>
        <a href="https://www.reddit.com/r/rust/comments/29kia3/no_ord_for_f32/" />
      </p>
    </li>
    <li>
      <p>
        <a href="https://stackoverflow.com/questions/26489701/why-does-rust-not-implement-total-ordering-via-the-ord-trait-for-f64-and-f32" />
      </p>
    </li>
  </ul>
</note>

<p>
  <code>cargo test</code> (or <code>cargo test --workspace</code>, if you're in
  the virtual manifest's directory) returns:
</p>

<code lang="text">
  <!--
    thread '...' panicked at 'assertion failed: `(left == right)`
      left: `{1: 98, 2: 202, 3: 278, 4: 422}`,
     right: `{1: 0, 2: 0, 3: 0, 4: 0}`'
  -->
</code>

<p>
  ... proving that <code>choose_weighted()</code> works as advertised (higher
  fitness scores were chosen more frequently), so let's adjust the test:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        /* ... */

        #[test]
        fn roulette_wheel_selection() {
            /* ... */

            let expected_histogram = BTreeMap::from_iter(vec![
                // (fitness, how many times this fitness has been chosen)
  =             (1, 98),
  =             (2, 202),
  =             (3, 278),
  =             (4, 422),
            ]);

            /* ... */
        }
    }
  -->
</code>

<p>
  Voilà - we've tested the untestable! Having the selection ready, let's recap
  where we've stopped:
</p>

<code lang="rust">
  <!--
    impl GeneticAlgorithm {
        pub fn evolve<I>(&self, population: &[I]) -> Vec<I>
        where
            I: Individual,
        {
            /* ... */

            (0..population.len())
                .map(|_| {
                    // TODO selection
                    // TODO crossover
                    // TODO mutation
                    todo!()
                })
                .collect()
        }
    }
  -->
</code>

<p>
  What we have to figure out now is how to pass
  <code>SelectionMethod</code> in there - I see two approaches:
</p>

<ol>
  <li>
    <p>
      Using a parameter:
    </p>

    <code lang="rust">
      <!--
        impl GeneticAlgorithm {
            pub fn evolve<I, S>(
                &self,
                population: &[I],
                selection_method: &S,
            ) -> Vec<I>
            where
                I: Individual,
                S: SelectionMethod,
            {
                /* ... */
            }
        }
      -->
    </code>
  </li>

  <li>
    <p>
      Using a constructor:
    </p>

    <code-title>
      libs/genetic-algorithm/src/lib.rs
    </code-title>

    <code lang="rust">
      <!--
      = pub struct GeneticAlgorithm<S> {
      =     selection_method: S,
      = }
      =
      = impl<S> GeneticAlgorithm<S>
      = where
      =     S: SelectionMethod,
        {
      =     pub fn new(selection_method: S) -> Self {
      =         Self { selection_method }
      =     }
      =
            pub fn evolve<I, S>(&self, population: &[I]) -> Vec<I>
            where
                I: Individual,
            {
                /* ... */
            }
        }
      -->
    </code>
  </li>
</ol>

<p>
  Facing this kind of decision, I think how often users will need to change that
  object:
</p>

<p>
  A population is usually different each time one calls <code>.evolve()</code>,
  so it's convenient to accept it via parameter - on the other hand, the
  selection algorithm usually remains the same for the entire simulation, so
  it'll be more convenient for the users to provide it through the constructor.
</p>

<p>
  Now we're almost ready to invoke the selection method:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    impl<S> GeneticAlgorithm<S>
    where
        S: SelectionMethod,
    {
        /* ... */

        pub fn evolve<I>(&self, population: &[I]) -> Vec<I>
        where
            I: Individual,
        {
            /* ... */

            (0..population.len())
                .map(|_| {
  =                 let parent_a = self.selection_method.select(rng, population);
  =                 let parent_b = self.selection_method.select(rng, population);

                    // TODO crossover
                    // TODO mutation
                    todo!()
                })
                .collect()
        }
    }
  -->
</code>

<p>
  ... the only thing we're missing is the PRNG:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    impl<S> GeneticAlgorithm<S>
    where
        S: SelectionMethod,
    {
        /* ... */

  =     pub fn evolve<I>(&self, rng: &mut dyn RngCore, population: &[I]) -> Vec<I>
        where
            I: Individual,
        {
            /* ... */
        }
    }
  -->
</code>

<note>
  <p>
    You might be wondering why we pass <code>rng</code> through the argument
    instead of through the constructor - surely the random number generator is
    not going to be changed for each evolution!
  </p>

  <p>
    This decision was more subtle - let's explore the other ways we could've
    written this code:
  </p>

  <ol>
    <li>
      <p>
        By accepting an <b>owned</b> PRNG via the constructor:
      </p>

      <code lang="rust">
        <!--
          pub struct GeneticAlgorithm<R> {
              rng: R,
          }
          
          impl<R> GeneticAlgorithm<R>
          where
              R: RngCore,
          {
              pub fn new(rng: R) -> Self {
                  Self { rng }
              }
          }
        -->
      </code>
    </li>
    <li>
      <p>
        By accepting a <b>borrowed</b> PRNG via the constructor:
      </p>

      <code lang="rust">
        <!--
          pub struct GeneticAlgorithm<'r> {
              rng: &'r mut dyn RngCore,
          }
          
          impl<'r> GeneticAlgorithm<'r> {
              pub fn new(rng: &'r mut dyn RngCore) -> Self {
                  Self { rng }
              }
          }
        -->
      </code>
    </li>
  </ol>

  <p>
    The first approach is something I'd suggest in C# or Java - it's a different
    story in Rust, because if we <i>move</i> <code>rng</code> into the
    constructor, we won't be able to use it in other places of the application:
  </p>

  <code lang="rust">
    <!--
      fn main() {
          let rng = /* ... */;
          let ga = GeneticAlgorithm::new(rng);
      
          // oh no, we can't use this `rng` anymore!
          if rng.gen_bool() {
              /* ... */
          } else {
              /* ... */
          }
      }
    -->
  </code>

  <p>
    You could argue the same already happens for <code>SelectionMethod</code>:
  </p>

  <code lang="rust">
    <!--
      fn main() {
          let sp = RouletteWheelSelection::new();
          let ga = GeneticAlgorithm::new(sp);
      
          // oh no, we can't use this `sp` anymore!
          if sp.something() {
              /* ... */
          }
      }
    -->
  </code>

  <p>
    ... but in my opinion there's a difference in that <code>Rng</code> is a
    more versatile trait - it makes sense to use it outside the
    <code>GeneticAlgorithm</code>, which cannot be said about
    <code>SelectionMethod</code>.
  </p>

  <p>
    All said, you'd be right to call this a far-fetched explanation - picking a
    "more versatile" trait is nothing but a gut feeling; if you ask me, the
    owned-value approach is correct, just slightly inferior in this particular
    case.
  </p>

  <p>
    As for the <code>&mut dyn RngCore</code> variant, I consider it the worst -
    it requires a unique borrow (<code>&mut</code>) on <code>rng</code>, so not
    only it "locks" PRNG for the lifetime of the genetic algorithm:
  </p>

  <code lang="rust">
    <!--
      fn main() {
          let rng = /* ... */;
          let ga = GeneticAlgorithm::new(&mut rng);
      
          // oh no, we still can't use this `rng`!
          let population = if rng.gen_bool() {
              /* ... */
          } else {
              /* ... */
          };
      
          ga.evolve(population);
      }
    -->
  </code>

  <p>
    ... but it also prevents otherwise valid use cases such as this one:
  </p>

  <code lang="rust">
    <!--
      struct Simulation {
          rng: ChaCha8Rng,
          ga: GeneticAlgoritm<'whats_this_lifetime??>,
      }

      impl Simulation {
          pub fn new_chacha() -> Self {
              let rng = ChaCha8Rng::from_seed(Default::default());
              let ga = GeneticAlgorithm::new(&mut rng);

              Self { rng, ga } // whoopsie
          }
      }
    -->
  </code>

  <p>
    By the way, that's called a <b>self-referential struct</b> - they can be
    summoned via eldritch magicks:
  </p>

  <ul>
    <li>
      <p>
        <a href="https://stackoverflow.com/questions/32300132/why-cant-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct" />
      </p>
    </li>
    <li>
      <p>
        <a href="https://boats.gitlab.io/blog/post/2018-01-25-async-i-self-referential-structs/" />
      </p>
    </li>
  </ul>
</note>

<hdr id="coding-crossover">
  Coding: Crossover
</hdr>

<p>
  Now that we have chosen two parent-individuals, it's time for the
  <b>crossover</b> phase.
</p>

<p>
  Crossover (also known as <b>recombination</b>) takes two individuals and mixes
  them, creating a new~ish solution in result:
</p>

<figure class="sketch w-80">
  <img src="{{ assets }}/coding-crossover-1.svg" />
</figure>

<p>
  As compared to simply creating brand-new random individuals, crossover is neat
  in the sense that it tries to <b>preserve knowledge</b> - the idea is that
  mixing two good solutions will usually yield a solution that's both new
  <i>and</i> at least as good as the two solutions we already have - this allows
  to explore the search space without the risk of losing the best solutions
  discovered so far.
</p>

<p>
  As in real world, crossover doesn't actually happen on individuals, but rather
  on their <b>chromosomes</b> - which is a fancy word for "the encoding of a
  solution":
</p>

<figure class="sketch w-80">
  <img src="{{ assets }}/coding-crossover-2.svg" />
</figure>

<p>
  A chromosome (also called <b>genotype</b>, though I'm convinced a biologist
  dies each time someone mixes both terms) is usually built from <b>genes</b>,
  and its structure depends on the underlying problem - sometimes it's
  convenient to model a chromosome as a bitset:
</p>

<figure class="sketch w-50">
  <img src="{{ assets }}/coding-crossover-3.svg" />
</figure>

<p>
  ... sometimes it's more convenient to have a string:
</p>

<figure class="sketch w-50">
  <img src="{{ assets }}/coding-crossover-4.svg" />
</figure>

<p>
  ... and we'll use what we already have - bunch of f32s representing weights of
  the neural network:
</p>

<figure class="sketch w-50">
  <img src="{{ assets }}/coding-crossover-5.svg" />
</figure>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
  = #[derive(Clone, Debug)]
  = pub struct Chromosome {
  =     genes: Vec<f32>,
  = }
  -->
</code>

<p>
  Instead of exposing genes directly (via <code>pub genes: ...​</code>), we'll
  provide a handful of functions allowing to peek inside the chromosome - that's
  called <b>encapsulation</b>:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
  = impl Chromosome {
  =     pub fn len(&self) -> usize {
  =         self.genes.len()
  =     }
  =
  =     pub fn iter(&self) -> impl Iterator<Item = &f32> {
  =         self.genes.iter()
  =     }
  =
  =     pub fn iter_mut(&mut self) -> impl Iterator<Item = &mut f32> {
  =         self.genes.iter_mut()
  =     }
  = }
  -->
</code>

<p>
  Seizing the day, let's catch up on some cool traits from the standard library:
</p>

<ol>
  <li>
    <p>
      <ref>
        https://doc.rust-lang.org/stable/std/ops/trait.Index.html
      </ref>

      There's <a><code>Index</code></a>, which allows you to use the <b>indexing
      operator</b> - <code>[]</code> - on your type:
    </p>

    <code lang="rust">
      <!--
      = use std::ops::Index;

        /* ... */

      = // ---
      = // | this is the type of expression you expect inside the square brackets
      = // |
      = // | e.g. if you implemented `Index<&str>`, you could write:
      = // |   chromosome["yass"]
      = // ------- v---v
      = impl Index<usize> for Chromosome {
      =     type Output = f32;
      =
      =     fn index(&self, index: usize) -> &Self::Output {
      =         &self.genes[index]
      =     }
      = }
      -->
    </code>
  </li>

  <li>
    <p>
      <ref>
        https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html
      </ref>

      There's <a><code>FromIterator</code></a>, which allows you to
      <code>.collect()</code> into your type:
    </p>

    <code lang="rust">
      <!--
      = // ---
      = // | this is the type of the item an iterator should provide in order to be compatible
      = // | with our chromosome
      = // |
      = // | (sometimes it's called the type an iterator *yields*)
      = // |
      = // | intuitively, since our chromosome is built of of floating-point numbers, we
      = // | expect floating-point numbers in here as well
      = // -------------- v-v
      = impl FromIterator<f32> for Chromosome {
      =     fn from_iter<T: IntoIterator<Item = f32>>(iter: T) -> Self {
      =         Self {
      =             genes: iter.into_iter().collect(),
      =         }
      =     }
      = }
      -->
    </code>
  </li>

  <li>
    <p>
      <ref>
        https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html
      </ref>

      Finally, there's <a><code>IntoIterator</code></a>, which works in the
      opposite way - it converts a type into an iterator:
    </p>

    <code lang="rust">
      <!--
      = impl IntoIterator for Chromosome {
      =     type Item = f32;
      =     type IntoIter = std::vec::IntoIter<f32>;
      =
      =     fn into_iter(self) -> Self::IntoIter {
      =         self.genes.into_iter()
      =     }
      = }
      -->
    </code>
  </li>
</ol>

<note>
  <p>
    What's up with this <code>std::vec::IntoIter&lt;f32&gt;</code>?
  </p>

  <p>
    An iterator is just another type, one that implements the
    <code>Iterator</code> trait:
  </p>

  <code-title>
    <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=e0d46e15578e4acc5a2dd9d948e8cbc6">
      open in playground
    </a>
  </code-title>

  <code lang="rust">
    <!--
      struct Fibonacci {
          prev: u32,
          curr: u32,
      }

      impl Default for Fibonacci {
          fn default() -> Self {
              Self { prev: 0, curr: 1 }
          }
      }

      impl Iterator for Fibonacci {
          type Item = u32;

          fn next(&mut self) -> Option<u32> {
              let next = self.prev + self.curr;

              self.prev = self.curr;
              self.curr = next;

              Some(self.prev)
          }
      }

      fn main() {
          for number in Fibonacci::default().take(10) {
              println!("{}", number);
          }
      }
    -->
  </code>

  <p>
    So if you want to convert a type into an iterator, you need to know what
    this target iterable-type is - in our case, since <code>Chromosome</code> is
    just a wrapper for <code>Vec</code>, the target type is
    <code>std::vec::IntoIter</code>, which the compiler can even spell for us:
  </p>

  <code-title>
    <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3f802badda113751add0ac5f92bca8b4">
      open in playground
    </a>
  </code-title>

  <code lang="rust">
    <!--
      struct Chromosome {
          genes: Vec<f32>,
      }

      impl IntoIterator for Chromosome {
          type Item = f32;
          type IntoIter = (); // note that we're deliberately using the wrong type here

          fn into_iter(self) -> Self::IntoIter {
              self.genes.into_iter()
          }
      }
    -->
  </code>

  <code lang="text">
    <!--
      error[E0308]: mismatched types
         |
         | /* ... */
         |
         = note: expected unit type `()`
                       found struct `std::vec::IntoIter<f32>`
    -->
  </code>

  <p>
    Naming this type is not always this easy, though, because combinators such
    as <code>.filter()</code> or <code>.map()</code> all account into it:
  </p>

  <code-title>
    <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=1e2f3dd9f63d54022a657113e5e1754e">
      open in playground
    </a>
  </code-title>

  <code lang="rust">
    <!--
      struct Somethinger {
          values: Vec<f32>,
      }

      impl IntoIterator for Somethinger {
          type Item = f32;
          type IntoIter = ();

          fn into_iter(self) -> Self::IntoIter {
              self.values
                  .into_iter()
                  .filter(|value| *value > 0.0)
                  .map(|value| value * 10.0)
          }
      }
    -->
  </code>

  <code lang="text">
    <!--
      error[E0308]: mismatched types
         |
         | /* ... */
         |
         = note: expected unit type `()`
                       found struct `Map<Filter<std::vec::IntoIter<f32>, {closure}>, {closure}>`
    -->
  </code>

  <p>
    Nightly Rust offers a cosy solution to this problem -
    <code>impl_trait_in_assoc_type</code>:
  </p>

  <code lang="rust">
    <!--
      #![feature(impl_trait_in_assoc_type)]

      struct Somethinger {
          values: Vec<f32>,
      }

      impl IntoIterator for Somethinger {
          type Item = f32;
          type IntoIter = impl Iterator<Item = f32>;

          fn into_iter(self) -> Self::IntoIter {
              self.values
                  .into_iter()
                  .filter(|value| *value > 0.0)
                  .map(|value| value * 10.0)
          }
      }
    -->
  </code>

  <p>
    ... which essentially says "please, compiler, find out the type on your
    own".
  </p>

  <p>
    Since we're on the stable toolchain, we can't use this feature, but
    fortunately we don't have to.
  </p>
</note>

<p>
  As I said a few minutes ago:
</p>

<blockquote>
  <p>
    [...] crossover doesn't actually happen on individuals, but rather on their
    <b>chromosomes</b> [...]
  </p>
</blockquote>

<p>
  ... which brings us to:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    impl<S> GeneticAlgorithm<S>
    where
        S: SelectionMethod,
    {
        /* ... */

        pub fn evolve<I>(/* ... */) -> Vec<I>
        where
            I: Individual,
        {
            (0..population.len())
                .map(|_| {
  =                 let parent_a = self.selection_method.select(rng, population).chromosome();
  =                 let parent_b = self.selection_method.select(rng, population).chromosome();

                    /* ... */
                })
                .collect()
        }
    }

    /* ... */

    pub trait Individual {
        fn fitness(&self) -> f32;
  =     fn chromosome(&self) -> &Chromosome;
    }

    /* ... */

    #[cfg(test)]
    mod tests {
        /* ... */

        impl Individual for TestIndividual {
            fn fitness(&self) -> f32 {
                self.fitness
            }
  =
  =         fn chromosome(&self) -> &Chromosome {
  =             panic!("not supported for TestIndividual")
  =         }
        }

        /* ... */
    }
  -->
</code>

<p>
  <ref>
    https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)#Examples
  </ref>

  As for the crossover itself, there are <a>many</a> algorithms we could
  implement - usually it's best to try a few of them and see whichever plays
  best with given problem, but for simplicity, we'll go with <b>uniform
  crossover</b>, which can be described with a single drawing:
</p>

<figure class="sketch">
  <img src="{{ assets }}/coding-crossover-6.svg" />
</figure>

<p>
  Same as before, let's start with a trait:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
  = pub trait CrossoverMethod {
  =     fn crossover(
  =         &self,
  =         rng: &mut dyn RngCore,
  =         parent_a: &Chromosome,
  =         parent_b: &Chromosome,
  =     ) -> Chromosome;
  = }
  -->
</code>

<p>
  ... and a rudimentary implementation:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
  = #[derive(Clone, Debug)]
  = pub struct UniformCrossover;
  =
  = impl CrossoverMethod for UniformCrossover {
  =     fn crossover(
  =         &self,
  =         rng: &mut dyn RngCore,
  =         parent_a: &Chromosome,
  =         parent_b: &Chromosome,
  =     ) -> Chromosome {
  =         let mut child = Vec::new();
  =         let gene_count = parent_a.len();
  =
  =         for gene_idx in 0..gene_count {
  =             let gene = if rng.gen_bool(0.5) {
  =                 parent_a[gene_idx]
  =             } else {
  =                 parent_b[gene_idx]
  =             };
  =
  =             child.push(gene);
  =         }
  =
  =         child.into_iter().collect()
  =     }
  = }
  -->
</code>

<p>
  Your internal critic might've noticed a few things off about this code -
  rightfully so!
</p>

<p>
  First, let's add an assertion:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    impl CrossoverMethod for UniformCrossover {
        fn crossover(/* ... */) -> Chromosome {
  =         assert_eq!(parent_a.len(), parent_b.len());

            /* ... */
        }
    }
  -->
</code>

<p>
  <ref>
    https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.zip
  </ref>

  Second, let's use a <span class="text-rainbow">combinator</span> - we already
  know this one from the previous post, it's <a><code>.zip()</code></a>:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    impl CrossoverMethod for UniformCrossover {
        fn crossover(/* ... */) -> Chromosome {
            assert_eq!(parent_a.len(), parent_b.len());

  =         parent_a
  =             .iter()
  =             .zip(parent_b.iter())
  =             .map(|(&a, &b)| if rng.gen_bool(0.5) { a } else { b })
  =             .collect()
        }
    }
  -->
</code>

<p>
  How neat!
</p>

<p>
  Notice how by implementing <code>.iter()</code> and <code>FromIterator</code>
  a moment ago, we were able to reduce code in here to a bare minimum that
  conveys the essence of the uniform crossover.
</p>

<p>
  Your internal critic might still be alerted that something's missing...​ hmm...​
  ah, tests!
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        /* ... */
    
  =     #[test]
  =     fn uniform_crossover() {
  =         let mut rng = ChaCha8Rng::from_seed(Default::default());
  =         let parent_a = todo!();
  =         let parent_b = todo!();
  =         let child = UniformCrossover.crossover(&mut rng, &parent_a, &parent_b);
  =
  =         assert!(/* ... */);
  =     }
    }
  -->
</code>

<p>
  What we want to verify, in plain words, is that <code>child</code> is 50%
  <code>parent_a</code> + 50% <code>parent_b</code>.
</p>

<p>
  My suggestion is to generate two distinct chromosomes (they don't have to be
  random, just build out of different genes):
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        /* ... */

        #[test]
        fn uniform_crossover() {
            /* ... */

  =         let parent_a: Chromosome = (1..=100).map(|n| n as f32).collect();
  =         let parent_b: Chromosome = (1..=100).map(|n| -n as f32).collect();
  =
  =         // First parent will be:
  =         //   [1, 2, /* ... */, 100]
  =         //
  =         // Second parent will look similar, but with reversed signs:
  =         //   [-1, -2, /* ... */, -100]
  =         //
  =         // Just like in the histogram, the concrete number of genes doesn't
  =         // matter - 100 will nicely round up to 100%, that's all

            /* ... */
        }
    }
  -->
</code>

<p>
  ... and then compare how much <code>child</code> differs from each of them:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        /* ... */

        #[test]
        fn uniform_crossover() {
            /* ... */

            let child = UniformCrossover.crossover(&mut rng, &parent_a, &parent_b);

  =         // Number of genes different between `child` and `parent_a`
  =         let diff_a = child.iter().zip(parent_a).filter(|(c, p)| *c != p).count();
  =
  =         // Number of genes different between `child` and `parent_b`
  =         let diff_b = child.iter().zip(parent_b).filter(|(c, p)| *c != p).count();
  =
  =         assert_eq!(diff_a, 0);
  =         assert_eq!(diff_b, 0);
        }
    }
  -->
</code>

<p>
  <code>cargo test</code> says:
</p>

<code lang="text">
  <!--
    thread '...' panicked at 'assertion failed: `(left == right)`
      left: `49`,
     right: `0`'
  -->
</code>

<p>
  ... so let's adjust the test:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    assert_eq!(diff_a, 49);
  -->
</code>

<p>
  Another <code>cargo test</code> will fail on the second assertion:
</p>

<code lang="text">
  <!--
    thread '...' panicked at 'assertion failed: `(left == right)`
      left: `51`,
     right: `0`'
  -->
</code>

<p>
  ... so:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    assert_eq!(diff_b, 51);
  -->
</code>

<p>
  To recall, what we've got is:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        /* ... */

        #[test]
        fn uniform_crossover() {
            /* ... */

            assert_eq!(diff_a, 49);
            assert_eq!(diff_b, 51);
        }
    }
  -->
</code>

<p>
  ... meaning that our <code>child</code> got 49% of its genome from
  <code>parent_a</code> and 51% from <code>parent_b</code> - this ultimately
  proves our uniform crossover picks genes from both parents at equal
  probability.
</p>

<p class="text-dim">
  (we didn't get an exact 50% - 50% match, but that's just probability being
  probability.)
</p>

<p>
  Now we can pass <code>CrossoverMethod</code> next to
  <code>SelectionMethod</code>:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    pub struct GeneticAlgorithm<S> {
        selection_method: S,
  =     crossover_method: Box<dyn CrossoverMethod>,
    }
    
    impl<S> GeneticAlgorithm<S>
    where
        S: SelectionMethod,
    {
  =     pub fn new(
  =         selection_method: S,
  =         crossover_method: impl CrossoverMethod + 'static,
  =     ) -> Self {
            Self {
                selection_method,
  =             crossover_method: Box::new(crossover_method),
            }
        }
    
        /* ... */
    }
  -->
</code>

<note>
  <p>
    <ref>
      https://doc.rust-lang.org/book/ch17-02-trait-objects.html#object-safety-is-required-for-trait-objects
    </ref>

    Contrary to <code>SelectionMethod::select()</code>,
    <code>CrossoverMethod::crossover()</code> doesn't contain any generic
    parameters and <a>that’s why</a> we can <code>Box</code> it - another
    approach could be:
  </p>

  <code lang="rust">
    <!--
      pub struct GeneticAlgorithm<S, C> {
          selection_method: S,
          crossover_method: C,
      }
      
      impl<S, C> GeneticAlgorithm<S, C>
      where
          S: SelectionMethod,
          C: CrossoverMethod,
      {
          pub fn new(
              selection_method: S,
              crossover_method: C,
          ) -> Self {
              Self {
                  selection_method,
                  crossover_method,
              }
          }
      
          /* ... */
      }
    -->
  </code>

  <p>
    ... with the trade-off here being the same as when we were talking about
    <code>T: Trait</code> vs <code>dyn Trait</code> (where
    <code>Box&lt;dyn Trait&gt;</code> corresponds to dynamic dispatch).
  </p>

  <p>
    Because Rust makes it so easy to add genetic parameter upon generic
    parameter, some argue that using <code>Box</code> - which has a slight
    performance penalty - makes for a less idiomatic Rust code.
  </p>

  <p>
    My stance is that <code>Box</code> is a convenient mechanism whose potential
    runtime trade off is paid by having a code that's easier to maintain - I'd
    say to use <code>Box</code> unless benchmarks prove it's an issue or unless
    it makes the code awkward to read.
  </p>
</note>

<p>
  ... and then we can call it:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    impl<S> GeneticAlgorithm<S>
    where
        S: SelectionMethod,
    {
        /* ... */

        pub fn evolve<I>(&self, rng: &mut dyn RngCore, population: &[I]) -> Vec<I>
        where
            I: Individual,
        {
            /* ... */

            (0..population.len())
                .map(|_| {
                    /* ... */

  =                 let mut child = self.crossover_method.crossover(rng, parent_a, parent_b);

                    /* ... */
                })
                .collect()
        }
    }
  -->
</code>

<hdr id="coding-mutation">
  Coding: Mutation
</hdr>

<p>
  Now that we have a semi-new chromosome at hand, it's time to introduce some
  diversity!
</p>

<p>
  Mutation, next to crossover and selection, is the third
  <a href="https://en.wikipedia.org/wiki/Genetic_operator">genetic operator</a>
  - it takes a chromosome and introduces one or many random changes to it:
</p>

<figure class="sketch w-50">
  <img src="{{ assets }}/coding-mutation-1.svg" />
</figure>

<p>
  As in The Actual Evolution®, the role of mutation is to explore solutions
  that were not present in the initial population; it also prevents the algoritm
  from getting stuck in a local optimum, as it keeps the population changed from
  one generation to another.
</p>

<p>
  Since we already have <code>Chromosome</code> implemented, mutation's going to
  be smooth as butter:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
  = pub trait MutationMethod {
  =     fn mutate(&self, rng: &mut dyn RngCore, child: &mut Chromosome);
  = }
  -->
</code>

<p>
  We'll use Gaussian mutation, which is a fancy way of saying "we'll add or
  subtract random numbers from the genome". Contrary to our parameter-less
  selection method, Gaussian mutation requires specifying two arguments:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
  = #[derive(Clone, Debug)]
  = pub struct GaussianMutation {
  =     /// Probability of changing a gene:
  =     /// - 0.0 = no genes will be touched
  =     /// - 1.0 = all genes will be touched
  =     chance: f32,
  =
  =     /// Magnitude of that change:
  =     /// - 0.0 = touched genes will not be modified
  =     /// - 3.0 = touched genes will be += or -= by at most 3.0
  =     coeff: f32,
  = }
  =
  = impl GaussianMutation {
  =     pub fn new(chance: f32, coeff: f32) -> Self {
  =         assert!(chance >= 0.0 && chance <= 1.0);
  =
  =         Self { chance, coeff }
  =     }
  = }
  =
  = impl MutationMethod for GaussianMutation {
  =     fn mutate(&self, rng: &mut dyn RngCore, child: &mut Chromosome) {
  =         for gene in child.iter_mut() {
  =             let sign = if rng.gen_bool(0.5) { -1.0 } else { 1.0 };
  =
  =             if rng.gen_bool(self.chance as f64) {
  =                 *gene += sign * self.coeff * rng.gen::<f32>();
  =             }
  =         }
  =     }
  = }
  -->
</code>

<p>
  As for the tests, instead of doing <code>fn test()</code> like before, this
  time I'd like to show you a bit different approach - let's talk
  <b>edge cases</b>:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        /* ... */

  =     mod gaussian_mutation {
  =         mod given_zero_chance {
  =             mod and_zero_coefficient {
  =                 #[test]
  =                 fn does_not_change_the_original_chromosome() {
  =                     todo!();
  =                 }
  =             }
  =
  =             mod and_nonzero_coefficient {
  =                 #[test]
  =                 fn does_not_change_the_original_chromosome() {
  =                     todo!();
  =                 }
  =             }
  =         }
  =
  =         mod given_fifty_fifty_chance {
  =             mod and_zero_coefficient {
  =                 #[test]
  =                 fn does_not_change_the_original_chromosome() {
  =                     todo!();
  =                 }
  =             }
  =
  =             mod and_nonzero_coefficient {
  =                 #[test]
  =                 fn slightly_changes_the_original_chromosome() {
  =                     todo!();
  =                 }
  =             }
  =         }
  =
  =         mod given_max_chance {
  =             mod and_zero_coefficient {
  =                 #[test]
  =                 fn does_not_change_the_original_chromosome() {
  =                     todo!();
  =                 }
  =             }
  =
  =             mod and_nonzero_coefficient {
  =                 #[test]
  =                 fn entirely_changes_the_original_chromosome() {
  =                     todo!();
  =                 }
  =             }
  =         }
  =     }
    }
  -->
</code>

<p>
  Naming tests this way took me a while to get used to, but eventually I've
  found this convention so helpful that I cannot <i>not</i> mention it; tests
  structured like that are worth more than a million comments, because tests -
  contrary to comments - don't become obsolete over time.
</p>

<p>
  When implementing, to avoid copy-pasting, let's create a helper function:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        /* ... */

        mod gaussian_mutation {
  =         use super::*;
  =
  =         fn actual(chance: f32, coeff: f32) -> Vec<f32> {
  =             let mut rng = ChaCha8Rng::from_seed(Default::default());
  =             let mut child = vec![1.0, 2.0, 3.0, 4.0, 5.0].into_iter().collect();
  =
  =             GaussianMutation::new(chance, coeff).mutate(&mut rng, &mut child);
  =
  =             child.into_iter().collect()
  =         }
    
            /* ... */
        }
    }
  -->
</code>

<p>
  ... and with it, the rest is as easy as:
</p>

<code-title>
  libs/genetic-algorithm/Cargo.toml
</code-title>

<code lang="toml">
  <!--
    # ...
    
    [dev-dependencies]
  = approx = "0.4"
    rand_chacha = "0.3"
  -->
</code>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        /* ... */

        mod gaussian_mutation {
            /* ... */

            mod given_zero_chance {
  =             use approx::assert_relative_eq;
  =
  =             fn actual(coeff: f32) -> Vec<f32> {
  =                 super::actual(0.0, coeff)
  =             }
  =
                mod and_zero_coefficient {
  =                 use super::*;
  =
                    #[test]
                    fn does_not_change_the_original_chromosome() {
  =                     let actual = actual(0.0);
  =                     let expected = vec![1.0, 2.0, 3.0, 4.0, 5.0];
  =
  =                     assert_relative_eq!(actual.as_slice(), expected.as_slice());
                    }
                }

                mod and_nonzero_coefficient {
  =                 use super::*;

                    #[test]
                    fn does_not_change_the_original_chromosome() {
  =                     let actual = actual(0.5);
  =                     let expected = vec![1.0, 2.0, 3.0, 4.0, 5.0];
  =
  =                     assert_relative_eq!(actual.as_slice(), expected.as_slice());
                    }
                }
            }

            /* ... */
        }
    }
  -->
</code>

<p>
  Implementing rest of the tests follows what we've learned so far, so it's been
  - brace for it - left as an exercise for the reader :-)
</p>

<p>
  Now we can pass <code>MutationMethod</code> next to
  <code>SelectionMethod</code> - there are no generics inside
  <code>MutationMethod::mutate()</code>, so let's not hesitate on a
  <code>Box</code>:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    pub struct GeneticAlgorithm<S> {
        selection_method: S,
        crossover_method: Box<dyn CrossoverMethod>,
  =     mutation_method: Box<dyn MutationMethod>,
    }
    
    impl<S> GeneticAlgorithm<S>
    where
        S: SelectionMethod,
    {
        pub fn new(
            selection_method: S,
            crossover_method: impl CrossoverMethod + 'static,
  =         mutation_method: impl MutationMethod + 'static,
        ) -> Self {
            Self {
                selection_method,
                crossover_method: Box::new(crossover_method),
  =             mutation_method: Box::new(mutation_method),
            }
        }
    
        /* ... */
    }
  -->
</code>

<p>
  ... and then:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    impl<S> GeneticAlgorithm<S>
    where
        S: SelectionMethod,
    {
        /* ... */

        pub fn evolve<I>(/* ... */) -> Vec<I>
        where
            I: Individual,
        {
            /* ... */

            (0..population.len())
                .map(|_| {
                    /* ... */

  =                 self.mutation_method.mutate(rng, &mut child);

                    /* ... */
                })
                .collect()
        }
    }
  -->
</code>

<hdr id="coding-creating-individuals">
  Coding: Creating individuals
</hdr>

<p>
  Our <code>child</code> is of type <code>Chromosome</code>, while the vector we
  return is <code>Vec&lt;I&gt;</code> - so the last thing we're missing is the
  ability of converting a genotype back into an individual:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    pub trait Individual {
  =     fn create(chromosome: Chromosome) -> Self;

        /* ... */
    }
    
    /* ... */
    
    #[cfg(test)]
    mod tests {
        /* ... */

        impl Individual for TestIndividual {
  =         fn create(chromosome: Chromosome) -> Self {
  =            todo!()
  =         }
  =
            /* ... */
        }
    }
  -->
</code>

<p>
  ... and then voilà!
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    impl<S> GeneticAlgorithm<S>
    where
        S: SelectionMethod,
    {
        /* ... */

        pub fn evolve<I>(&self, rng: &mut dyn RngCore, population: &[I]) -> Vec<I>
        where
            I: Individual,
        {
            assert!(!population.is_empty());

            (0..population.len())
                .map(|_| {
                    let parent_a = self.selection_method.select(rng, population).chromosome();
                    let parent_b = self.selection_method.select(rng, population).chromosome();
                    let mut child = self.crossover_method.crossover(rng, parent_a, parent_b);

                    self.mutation_method.mutate(rng, &mut child);

  =                 I::create(child)
                })
                .collect()
        }
    }
  -->
</code>

<hdr id="the-test">
  The Test
</hdr>

<p>
  Having <code>.evolve()</code> ready, the time has come for perhaps the most
  exciting slice of this post: the <b><span class="text-rainbow">test</span></b>
  that'll prove to everyone that our <code>.evolve()</code> works and that we
  know what we're doing.
</p>

<p>
  We'll start by adjusting our <code>TestIndividual</code> so that instead of
  <code>panic!()</code>-ing, it actually implements <code>::create()</code> and
  <code>.chromosome()</code>.
</p>

<p>
  Some tests - e.g. the ones for <code>RouletteWheelSelection</code> - don't
  care about genes at all, so we'll get bonus points for inventing a solution
  that doesn't require modifying those already-working tests.
</p>

<p>
  My proposition is to change <code>TestIndividual</code> from
  <code>struct</code> to an <code>enum</code> with two different variants:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        /* ... */

  =     #[derive(Clone, Debug)]
  =     enum TestIndividual {
  =         /// For tests that require access to the chromosome
  =         WithChromosome { chromosome: Chromosome },
  =
  =         /// For tests that don't require access to the chromosome
  =         WithFitness { fitness: f32 },
  =     }
  =
  =     impl TestIndividual {
  =         fn new(fitness: f32) -> Self {
  =             Self::WithFitness { fitness }
  =         }
  =     }
  =
  =     impl Individual for TestIndividual {
  =         fn create(chromosome: Chromosome) -> Self {
  =             Self::WithChromosome { chromosome }
  =         }
  =
  =         fn chromosome(&self) -> &Chromosome {
  =             match self {
  =                 Self::WithChromosome { chromosome } => chromosome,
  =
  =                 Self::WithFitness { .. } => {
  =                     panic!("not supported for TestIndividual::WithFitness")
  =                 }
  =             }
  =         }
  =
  =         fn fitness(&self) -> f32 {
  =             match self {
  =                 Self::WithChromosome { chromosome } => {
  =                     chromosome.iter().sum()
  =
  =                     // ^ the simplest fitness function ever - we're just
  =                     // summing all the genes together
  =                 }
  =
  =                 Self::WithFitness { fitness } => *fitness,
  =             }
  =         }
  =     }

        /* ... */
    }
  -->
</code>

<p class="text-attached">
  <ref>
    https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition
  </ref>

  (instead of <code>enum</code>, you could also create two separate types
  like <code>TestIndividualWithChromosome</code> and
  <code>TestIndividualWithFitness</code>, but that feels <a>too enterprisey</a>
  for me)
</p>

<p>
  Since we're already here, let's derive <code>PartialEq</code> - it'll come
  handy in a moment:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        /* ... */

  =     #[derive(Clone, Debug, PartialEq)]
        pub enum TestIndividual {
            /* ... */
        }

        /* ... */

  =     impl PartialEq for Chromosome {
  =         fn eq(&self, other: &Self) -> bool {
  =             approx::relative_eq!(self.genes.as_slice(), other.genes.as_slice())
  =         }
  =     }

        /* ... */
    }
  -->
</code>

<p>
  As for the test, nothing scary - we'll start with a few individuals, evolve
  them over a couple of generations and see how they end up looking like:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        /* ... */

  =     #[test]
  =     fn genetic_algorithm() {
  =         let mut rng = ChaCha8Rng::from_seed(Default::default());
  =
  =         let ga = GeneticAlgorithm::new(
  =             RouletteWheelSelection,
  =             UniformCrossover,
  =             GaussianMutation::new(0.5, 0.5),
  =         );
  =
  =         let mut population = vec![
  =             /* TODO */
  =         ];
  =
  =         // We're running `.evolve()` a few times, so that the differences between the
  =         // input and output population are easier to spot.
  =         //
  =         // No particular reason for a number of 10 - this test would be fine for 5, 20 or
  =         // even 1000 generations - the only thing that'd change is the magnitude of the
  =         // difference between the populations.
  =         for _ in 0..10 {
  =             population = ga.evolve(&mut rng, &population);
  =         }
  =
  =         let expected_population = vec![
  =             /* TODO */
  =         ];
  =
  =         assert_eq!(population, expected_population);
  =     }

        /* ... */
    }
  -->
</code>

<p>
  We're going to create a few individuals at once, so a helper function is a
  must:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        /* ... */

        #[test]
        fn genetic_algorithm() {
  =         fn individual(genes: &[f32]) -> TestIndividual {
  =             TestIndividual::create(genes.iter().cloned().collect())
  =         }

            /* ... */
        }

        /* ... */
    }
  -->
</code>

<p>
  ... and now:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        /* ... */

        #[test]
        fn genetic_algorithm() {
            /* ... */

  =         let mut population = vec![
  =             individual(&[0.0, 0.0, 0.0]),
  =             individual(&[1.0, 1.0, 1.0]),
  =             individual(&[1.0, 2.0, 1.0]),
  =             individual(&[1.0, 2.0, 4.0]),
  =         ];

            /* ... */

  =         let expected_population = vec![
  =             individual(&[0.0, 0.0, 0.0, 0.0]),
  =             individual(&[0.0, 0.0, 0.0, 0.0]),
  =             individual(&[0.0, 0.0, 0.0, 0.0]),
  =             individual(&[0.0, 0.0, 0.0, 0.0]),
  =         ];

            /* ... */
        }
    }
  -->
</code>

<p class="text-attached">
  (as before, there's no reason for having exactly 4 individuals with exactly 3
  genes - it just feels reasonable to maintain; two individuals would be too
  few, a hundredth - probably too many.)
</p>

<p>
  Do you hear the people sing, singings the songs of angry men? It's
  <code>cargo test</code>, failing due to the zeroed-out
  <code>expected_population</code>:
</p>

<code lang="text">
  <!--
    thread '...' panicked at 'assertion failed: `(left == right)`
      left: `[WithChromosome { ... }, WithChromosome { ... }, ... ]`,
     right: `[WithChromosome { ... }, WithChromosome { ... }, ... ]`,
  -->
</code>

<p>
  Using this output, we can copy-paste actual genes from <code>left</code> into
  <code>expected_population</code>:
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    #[cfg(test)]
    mod tests {
        /* ... */

        #[test]
        fn genetic_algorithm() {
            /* ... */

  =         let expected_population = vec![
  =             individual(&[0.44769490, 2.0648358, 4.3058133]),
  =             individual(&[1.21268670, 1.5538777, 2.8869110]),
  =             individual(&[1.06176780, 2.2657390, 4.4287640]),
  =             individual(&[0.95909685, 2.4618788, 4.0247330]),
  =         ];

            /* ... */
        }
    }
  -->
</code>

<p>
  Yes...​ ha ha ha...​ <b><u>yes</u></b>... we've got...​ numbers?
</p>

<p>
  What's certain is that we've got <i>some</i> output - but how do we know those
  four individuals are actually <b>better</b> than the four individuals we'v
  started with?
</p>

<p>
  Well, we can compare their fitness scores!
</p>

<code-title>
  libs/genetic-algorithm/src/lib.rs
</code-title>

<code lang="rust">
  <!--
    // In this case, `fitness score` means `average of the genes`, as per our implemetation
    // inside `TestIndividual::fitness()`

    let population = vec![
        individual(&[/* ... */]), // fitness = 0.0
        individual(&[/* ... */]), // fitness = 1.0
        individual(&[/* ... */]), // fitness ~= 1.33
        individual(&[/* ... */]), // fitness ~= 2.33
    ];
    
    let expected_population = vec![
        individual(&[/* ... */]), // fitness ~= 6.8
        individual(&[/* ... */]), // fitness ~= 5.7
        individual(&[/* ... */]), // fitness ~= 7.8
        individual(&[/* ... */]), // fitness ~= 7.4
    ];
  -->
</code>

<p class="text-rainbow" style="margin-top: 3em; margin-bottom: 4em">
  it works! it works! our genetic algorithm is the apex predator of computer
  science!
</p>

<figure class="sketch">
  <img src="{{ assets }}/the-test-1.svg" />

  <figcaption>
    <a href="https://knowyourmeme.com/memes/stonks">stonks</a>
  </figcaption>
</figure>

<p>
  We've got higher fitness scores, which means that our individuals got better
  and everything worked as intended:
</p>

<ol>
  <li>
    <p>
      Thanks to the roulette wheel selection, the worst solution -
      <code>[0.0, 0.0, 0.0]</code> - was discarded.
    </p>
  </li>
  <li>
    <p>
      Thanks to the uniform crossover, the average fitness score grew from 3.5
      to 7.0 (!)
    </p>
  </li>
  <li>
    <p>
      Thanks to the Gaussian mutation, we see genes - numbers - that were not
      present in the initial population.
    </p>
  </li>
</ol>

<p>
  You don't have to believe me, though - try commenting out various parts of the
  algorithm:
</p>

<code lang="rust">
  <!--
    // self.mutation_method.mutate(rng, &mut child);
  -->
</code>

<p>
  ... and see how they affect the output population.
</p>

<hdr id="closing-thoughts">
  Closing thoughts
</hdr>

<p>
  So far, learning <i>whoa so much</i> on the way, we've implemented two
  separate components: a neural network and a genetic algorithm.
</p>

<p>
  In the upcoming, last post of this series we'll integrate both algorithms and
  implement a snazzy user interface that'll allow us to see beyond lists of
  floating-point numbers - as promised, that's where the JavaScript and
  WebAssembly will come to play.
</p>
