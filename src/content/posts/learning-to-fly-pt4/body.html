<p>
  This is the last part of the <b>Learning to Fly</b> series in which we're
  coding a simulation of evolution using <b>neural network</b> and <b>genetic
  algorithm</b>:
</p>

<figure>
  <a href="https://shorelark.pwy.io">
    <img src="/posts/learning-to-fly-pt1/assets/intro-outcome.png" />
  </a>

  <figcaption>
    <a href="https://shorelark.pwy.io" />
  </figcaption>
</figure>

<p>
  In today's, final episode:
</p>

<style>
  ._intro-card {
    text-align: center;
    margin-bottom: 1.5em;
  }

  ._intro-card-title {
    padding-bottom: 8px;
    font-weight: bold;
  }

  ._intro-card-body img {
    width: 200px;
  }

  ._intro-card-body pre {
    margin: -5px 0 0 0;
    padding: 0;
  }

  @media only screen and (min-width: 992px) {
    #_intro {
      display: flex;
    }

    ._intro-card {
      flex: 1;
      margin-bottom: 0;
      padding: 5px;
    }

    ._intro-card-body img {
      width: 100%;
    }
  }
</style>

<div id="_intro">
  <div class="_intro-card">
    <div class="_intro-card-title">
      Sexy Polygons
    </div>

    <div class="_intro-card-body">
      <img src="{{ assets }}/37718e09-3278-44ef-a104-28cb5486e4ff.png" />
    </div>
  </div>

  <div class="_intro-card">
    <div class="_intro-card-title">
      ISO-Certified ASCII Diagrams
    </div>

    <div class="_intro-card-body">
      <pre>
------------
| \...%....|
|   \......|
|    @&gt;....|
|      \...|
|        \.|
------------</pre>
    </div>
  </div>

  <div class="_intro-card">
    <div class="_intro-card-title">
      Cool Numbers
    </div>

    <div class="_intro-card-body">
      <img src="{{ assets }}/2c33e3da-bfad-4f75-8a0c-c175c4fb1694.png" />
    </div>
  </div>
</div>

<hr />

<p>
  Now that we have implemented neural network and genetic algorithm, what awaits
  is the most delightful part: modelling the ecosystem and displaying
  <span class="text-rainbow">them dancing triangles</span> on our screens!
</p>

<p>
  I'm obliged say that at this point we're basically on a runner's high, so if
  you considered the previous three parts even remotely interesting, then going
  through this one will feel like eating Nutella for the first time in your
  life.
</p>

<p class="text-center text-dim">
  <b>content warning</b>: this article contains traces of javascript
</p>

<note>
  <p>
    No worries if JavaScript or HTML are unfamiliar to you - I'll try to explain
    concepts as we go.
  </p>
</note>

<h2 id="plan">
  Plan
</h2>

<p>
  We've got <code>struct NeuralNetwork</code> and
  <code>struct GeneticAlgorithm</code> - but what about
  <code>struct Eye</code> or <code>struct World</code>? After all, our birds
  have to have eyes and a place to live!
</p>

<figure class="sketch">
  <img src="/posts/learning-to-fly-pt1/assets/design-4.svg" />
</figure>

<p>
  So that's what we'll be doing today; we'll implement all those functions
  that'll determine <code>what a bird sees</code> or
  <code>how a bird moves</code>. We'll also - at last! - create a user interface
  that'll allow us to see beyond dry numbers; it's about time we engage that
  visual cortex of ours better!
</p>

<p>
  I'm not a great salesman, but lemme give it a shot - in a marketing gabble:
</p>

<p class="text-center">
  <i>
    we'll see our code in action (<span class="text-rainbow">!</span>), in
    real-time (<span class="text-rainbow">!!</span>), in a web browser
    (<span class="text-rainbow">!!!</span>)
  </i>
</p>

<p>
  If you're into diagrams, what we're aiming for is:
</p>

<figure class="sketch w-90">
  <img src="{{ assets }}/9af5a3d9-83f9-47eb-b191-7ee523846ecf.svg" />

  <figcaption>
    green tick = already implemented, blue dot = will be done today
  </figcaption>
</figure>

<p>
  As always, next to coding, we'll also investigate what's <i>exactly</i>
  happening underneath all the layers of abstractions we're given - if you're
  not into that, feel free to skip those yellow boxes.
</p>

<p>
  Ready? Off we go!
</p>

<h2 id="prerequisites">
  Prerequisites
</h2>

<p>
  For a <span class="text-spaced">fearless</span> WebAssembly experience, we'll
  need two extra tools:
</p>

<ul>
  <li>
    <p>
      <a href="https://www.npmjs.com/get-npm"><code>npm</code></a> (like Cargo,
      but for JavaScript),
    </p>
  </li>
  <li>
    <p>
      <a href="https://rustwasm.github.io/wasm-pack/installer/">
        <code>wasm-pack</code>
      </a> (set of tools that make compiling Rust into WebAssembly easier).
    </p>
  </li>
</ul>

<p>
  Before continuing, please install those tools according to the system you're
  using.
</p>

<note>
  <p>
    If you're into <a href="https://nixos.org/">Nix</a>, installing both
    applications is as easy as creating a file called <code>shell.nix</code>:
  </p>

  <listing-title>
    shell.nix
  </listing-title>

  <listing lang="nix">
    <!--
      let
        pkgs = import <nixpkgs> { };
      
      in
        pkgs.mkShell {
          buildInputs = with pkgs; [
            libiconv
            nodejs
            wasm-pack
          ];
        }
    -->
  </listing>

  <p>
    ... and executing <code>nix-shell</code>.
  </p>
</note>

<h2 id="hello-wasm-rust">
  Hello, WebAssembly World! (the Rust part)
</h2>

<p>
  Let's begin by creating a new crate - as in the diagram, it will be
  responsible for interacting with our frontend application:
</p>

<note>
  <p>
    <ref>
      https://en.wikipedia.org/wiki/Interoperation
    </ref>

    Formally, this kind of "talking to another system" module is known as a
    <b>bridge</b> or an <a><b>interop</b></a>.
  </p>
</note>

<listing lang="shell">
  <!--
    $ cd shorelark/libs
    $ cargo new simulation-wasm --lib --name lib-simulation-wasm
    
    # (this crate's name doesn't have to contain `wasm` - it's just a
    # convention of mine, so that the crate's purpose is explicit)
  -->
</listing>

<p>
  To make our crate WebAssembly-aware, there are two things we have to add to
  its manifest:
</p>

<ol>
  <li>
    <p>
      <ref>
        https://doc.rust-lang.org/reference/linkage.html
      </ref>

      We have to set <a><code>crate-type</code></a> to <code>cdylib</code>:
    </p>

    <listing-title>
      libs/simulation-wasm/Cargo.toml
    </listing-title>

    <listing lang="toml">
      <!--
        [package]
        # ...
        
      = [lib]
      = crate-type = ["cdylib"]
      -->
    </listing>

    <note>
      <p>
        Compiler transforms code into <i>something</i>, and
        <code>crate-type</code> determines what that <i>something</i> - also
        called an <b>artifact</b> - gets to be:
      </p>

      <ul>
        <li>
          <p>
            <code>crate-type = ["bin"]</code> means: compiler, pretty please
            produce a <b>program</b> <br />
            (e.g. an <code>.exe</code> file for Windows),
          </p>
        </li>
        <li>
          <p>
            <code>crate-type = ["lib"]</code> means: compiler, pretty please
            produce a <b>library</b> <br />
            (e.g. a <code>.dll</code> file for Windows, <code>.so</code> for
            Linux).
          </p>
        </li>
      </ul>

      <p>
        Where:
      </p>

      <ul>
        <li>
          <p>
            a <b>program</b> is something that you can execute directly (e.g.
            from your terminal),
          </p>
        </li>
        <li>
          <p>
            a <b>library</b> is a piece of code that provides functions
            <i>for others</i> to use.
          </p>
        </li>
      </ul>

      <p>
        <ref>
          https://github.com/rust-lang/rfcs/blob/master/text/1510-cdylib.md
        </ref>

        The type we have to use, <a><code>cdylib</code></a>, stands for <b>C
        dynamic library</b> and it tells the compiler:
      </p>

      <ul>
        <li>
          <p>
            that it should export only those functions which are intended to be
            called from outside, ignoring Rust-specific internal stuff.
          </p>

          <p>
            This prevents bloating the library with "useless" metadata and so
            it's important for WebAssembly (we don't want our users to go
            bankrupt over internet bills, do we?).
          </p>
        </li>
        <li>
          <p>
            that it should generate a <b>dynamic library</b> - that is: a piece
            of code that will get invoked <i>by somebody else</i>.
          </p>

          <p>
            This is required for WebAssembly, because - as you'll see in a
            moment - our Rust code won't run standalone: it'll be at
            JavaScript's beck and call.
          </p>

          <p>
            In practice, what this means is that we won't have any
            <code>fn main() { ...â€‹ }</code>, but rather
            <code>pub fn do_something() { ...â€‹ }</code>.
          </p>
        </li>
      </ul>
    </note>
  </li>
  <li>
    <p>
      <ref>
        https://github.com/rustwasm/wasm-bindgen
      </ref>

      We have to include <a><code>wasm-bindgen</code></a> in our dependencies:
    </p>

    <listing-title>
      libs/simulation-wasm/Cargo.toml
    </listing-title>

    <listing lang="toml">
      <!--
        # ...
        
        [dependencies]
      = wasm-bindgen = "0.2"
      -->
    </listing>

    <note>
      <p>
        <code>wasm-bindgen</code> provides types and macros that facilitate
        writing WebAssembly-aware code.
      </p>

      <p>
        It is possible to write Rust + WebAssembly without it - just less
        convenient.
      </p>
    </note>
  </li>
</ol>

<p>
  When it comes to adjustments, that's all - now it's Rust-time!
</p>

<p>
  Since creating the simulation will take some time, and it'd be nice to see
  something working as soon as possible, I say we begin by creating a function
  that we'll be able to invoke from JavaScript right away - you know, just to
  ensure that this <i>"WebAssembly"</i> thing isn't just a hoax:
</p>

<listing-title>
  libs/simulation-wasm/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
  = pub fn whos_that_dog() -> String {
  =     "Mister Peanutbutter".into()
  = }
  -->
</listing>

<p>
  If we were building a regular crate to publish on crates.io, that'd be all -
  but for WebAssembly, there's one more thing we have to add,
  <code>#[wasm_bindgen]</code>:
</p>

<listing-title>
  libs/simulation-wasm/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
  = use wasm_bindgen::prelude::*;
    
  = #[wasm_bindgen]
    pub fn whos_that_dog() -> String {
        "Mister Peanutbutter".into()
    }
  -->
</listing>

<note>
  <p>
    Simplifying a bit, the <code>#[wasm_bindgen]</code>
    <a href="https://doc.rust-lang.org/book/ch19-06-macros.html#procedural-macros-for-generating-code-from-attributes">
      procedural macro
    </a>
    informs the compiler that you want to <b>export</b> given function or
    type - that is: make it visible on the JavaScript's side.
  </p>

  <p>
    All Rust symbols eventually are compiled into WebAssembly, but only those
    prepended with <code>#[wasm_bindgen]</code> can be invoked from the
    JavaScript code directly.
  </p>

  <p>
    If you're curious, you can further use
    <a href="https://github.com/dtolnay/cargo-expand">
      <code>cargo-expand</code>
    </a>
    to inspect what this macro does:
  </p>

  <listing-title>
    $ cargo expand
  </listing-title>

  <listing lang="rust">
    <!--
      use wasm_bindgen::prelude::*;
      
      pub fn whos_that_dog() -> String {
          "Mister Peanutbutter".into()
      }
      
      //  v--------v
      pub extern "C" fn __wasm_bindgen_generated_whos_that_dog() ->
          <String as wasm_bindgen::convert::ReturnWasmAbi>::Abi
      {
          let _ret = { whos_that_dog() };
          <String as wasm_bindgen::convert::ReturnWasmAbi>::return_abi(_ret)
      }
      //  ^ `extern` informs compiler (and linker) that this function must
      //  | be exported (it must be visible from outside the Rust code).
      //  |
      //  | While `pub` determines how given symbol is visible _inside_ Rust
      //  | code, `extern` says "other languages should be able to invoke
      //  | this function, too".
      //  |
      //  | `"C"` determines a so-called application binary interface (ABI),
      //  | which describes _how exactly_ the function gets to be exported
      //  | (there are many different conventions that define how parameters
      //  | and return values must be passed in order to be understood "on
      //  | the other side").
      //  |
      //  | If you want to know more - which it's not required to follow
      //  | the article - there's:
      //  |
      //  | https://doc.rust-lang.org/reference/items/external-blocks.html#abi
      //  ---
    -->
  </listing>
</note>

<p>
  To build a WebAssembly crate, we'll use that <b>wasm-pack</b> tool we've just
  installed:
</p>

<listing lang="shell">
  <!--
    $ cd simulation-wasm
    $ wasm-pack build
  -->
</listing>

<p>
  The difference between plain <code>cargo</code> and <code>wasm-pack</code> is
  that the latter not only compiles the code, but also generates a lot of handy
  JavaScript files that otherwise we'd have to write by hand - we can find them
  all inside a newly-created directory called <code>pkg</code>:
</p>

<listing lang="text">
  <!--
    $ ls -l pkg
    total 36
    -rw-r--r-- 1 pwy   110 Apr  2 17:20 lib_simulation_wasm.d.ts
    -rw-r--r-- 1 pwy   184 Apr  2 17:20 lib_simulation_wasm.js
    -rw-r--r-- 1 pwy  1477 Apr  2 17:20 lib_simulation_wasm_bg.js
    -rw-r--r-- 1 pwy 13155 Apr  2 17:20 lib_simulation_wasm_bg.wasm
    -rw-r--r-- 1 pwy   271 Apr  2 17:20 lib_simulation_wasm_bg.wasm.d.ts
    -rw-r--r-- 1 pwy   356 Apr  2 17:20 package.json
  -->
</listing>

<p>
  To ground ourselves, let's take a brief look at what we've got:
</p>

<ul>
  <li>
    <p>
      <code>package.json</code> is like
      <a href="https://www.npmjs.com/">npm</a>'s <code>Cargo.toml</code> - it
      contains metadata about the module itself:
    </p>

    <listing-title>
      libs/simulation-wasm/pkg/package.json
    </listing-title>

    <listing lang="javascript">
      <!--
        {
          "name": "lib-simulation-wasm",
          "version": "0.1.0",
          /* ... */
        }
      -->
    </listing>
  </li>
  <li>
    <p>
      <ref>
        https://en.wikipedia.org/wiki/Forward_declaration
      </ref>

      <code>lib_simulation_wasm.d.ts</code> contains <a>forward declarations</a>
      for IDEs to provide type hints:
    </p>

    <listing-title>
      libs/simulation-wasm/pkg/lib_simulation_wasm.d.ts
    </listing-title>

    <listing lang="javascript">
      <!--
        /**
         * @returns {string}
         */
        export function whos_that_dog(): string;
      -->
    </listing>
  </li>
  <li>
    <p>
      <ref id="bc">
        https://en.wikipedia.org/wiki/Bytecode
      </ref>

      <ref id="wabt">
        https://github.com/WebAssembly/wabt
      </ref>

      <code>lib_simulation_wasm_bg.wasm</code> is the essence, as it contains
      the WebAssembly <a ref="bc"><b>bytecode</b></a> of our crate; it's like
      <code>.dll</code> or <code>.so</code>, and you can use
      <a ref="wabt">wabt</a> to inspect it (mainly for fun, I guess):
    </p>

    <listing-title>
      $ wasm2wat pkg/lib_simulation_wasm_bg.wasm
    </listing-title>

    <listing lang="lisp">
      <!--
        (module
          (func (type 1) (param i32) (result i32)
            (local i32 i32 i32 i32)
            global.get 0
            i32.const 16
            i32.sub
            local.tee 11
            ;; ...
      -->
    </listing>
  </li>
  <li>
    <p>
      <code>lib_simulation_wasm_bg.js</code> contains a rather spine-chilling
      code that actually invokes our WebAssembly library:
    </p>

    <listing-title>
      libs/simulation-wasm/pkg/lib_simulation_wasm_bg.js
    </listing-title>

    <listing lang="javascript">
      <!--
        /**
         * @returns {string}
         */
        export function whos_that_dog() {
            try {
                const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
                wasm.whos_that_dog(retptr);
                var r0 = getInt32Memory0()[retptr / 4 + 0];
                var r1 = getInt32Memory0()[retptr / 4 + 1];
                return getStringFromWasm0(r0, r1);
            } finally {
                wasm.__wbindgen_add_to_stack_pointer(16);
                wasm.__wbindgen_free(r0, r1);
            }
        }
      -->
    </listing>

    <note>
      <p>
        Wait - if our Rust code does next to nothing:
      </p>

      <listing-title>
        libs/simulation-wasm/src/lib.rs
      </listing-title>

      <listing lang="rust">
        <!--
          pub fn whos_that_dog() -> String {
              "Mister Peanutbutter".into()
          }
        -->
      </listing>

      <p>
        ... then why does that piece look so complex?
      </p>

      <p>
        Well, in short, it's because WebAssembly
        <b>doesn't support strings</b> - and wasm-pack, being neat,
        transparently hacks its way around it.
      </p>

      <p>
        But first, the terminology:
      </p>

      <ul>
        <li>
          <p>
            <ref>
              https://doc.rust-lang.org/nomicon/ffi.html
            </ref>

            When you move a value from one function into another, when both
            functions work in different environments and/or when they are
            written in different languages, you make it <b>cross the foreign
            function interface (<a>FFI</a>) boundary</b>:
          </p>

          <figure class="sketch w-80">
            <img src="{{ assets }}/962da22e-fe0c-49b1-afb6-c333e5a18447.svg" />
          </figure>

          <p>
            In this case we'd say that our <code>fn whos_that_dog()</code>
            returns a <code>String</code> that crosses the FFI boundary from
            Rust (where it's created) into JavaScript (where it's used).
          </p>

          <p>
            Crossing the FFI boundary is a big deal, because different languages
            tend to have different <b>memory representations</b> of objects - so
            even if Rust's <code>struct Foo</code> and JavaScript's
            <code>class Foo</code> look alike on the surface, their <b>memory
            layout</b> is different.
          </p>

          <p>
            This means that when you want to send a value from one language into
            another, you cannot just say "hey, there's a few bytes at 0x0000CAFE
            - that's Foo" - instead, you have to <b>convert</b> that value into
            something the other party can understand:
          </p>

          <figure class="sketch w-80">
            <img src="{{ assets }}/d152e743-8a56-4f39-8376-ce72bca8c88c.svg" />
          </figure>
        </li>
        <li>
          <p>
            When you convert a value into another representation, you
            <b>serialize</b> it.
          </p>

          <p>
            For instance, a type such as this one:
          </p>

          <listing lang="rust">
            <!--
              struct Foo {
                  value: String,
              }
            -->
          </listing>

          <p>
            ... can be serialized into, say, JSON that looks like this:
          </p>

          <listing lang="json">
            <!--
              {
                "value": "Hi!"
              }
            -->
          </listing>

          <p>
            ... which can be then easily <b>deserialized</b> on the JavaScript's
            side:
          </p>

          <listing lang="javascript">
            <!--
              const foo = JSON.parse('{ "value": "Hi!" }');
              console.log(foo);
            -->
          </listing>

          <p>
            <ref>
              https://hacks.mozilla.org/2019/04/crossing-the-rust-ffi-frontier-with-protocol-buffers/
            </ref>

            (serialization isn't limited to human-readable formats such as JSON,
            YAML or XML - there's also e.g. <a>Protocol Buffers</a>.)
          </p>
        </li>
      </ul>

      <p>
        Now, while both Rust and JavaScript support strings, WebAssembly
        understands mostly numbers - this means that all the functions that we
        export via <code>#[wasm_bindgen]</code> might accept and return <i>at
        most</i> a handful of numbers (from WebAssembly's point of view).
      </p>

      <p>
        This means that in order to return a string, wasm-pack had to get
        creative - it generated this boi we've already seen a moment ago:
      </p>

      <listing-title>
        (generated automatically during compilation)
      </listing-title>

      <listing lang="rust">
        <!--
          pub extern "C" fn __wasm_bindgen_generated_whos_that_dog()
              -> <String as ReturnWasmAbi>::Abi
          {
              let _ret = { whos_that_dog() };
              <String as ReturnWasmAbi>::return_abi(_ret)
          }
        -->
      </listing>

      <p>
        In general, this is known as <b>shim</b> (or <b>glue-function</b>, or
        <b>glue-code</b>).
      </p>

      <p>
        This one converts Rust's <code>String</code> into a pair of
        numbers - following the JavaScript code:
      </p>

      <ul>
        <li>
          <p>
            <ref>
              https://en.wikipedia.org/wiki/Pointer_(computer_programming)
            </ref>

            <code>r0</code> which determines location of returned string in
            memory (it's good-old <a>pointer</a>),
          </p>
        </li>
        <li>
          <p>
            <code>r1</code> which determines length of returned string.
          </p>
        </li>
      </ul>

      <p>
        Those two numbers are then used by <code>getStringFromWasm0()</code> to
        <b>recreate</b> ("deserialize") the string on JavaScript's side - all
        without us having to lift a single finger.
      </p>

      <p>
        Pretty neat!
      </p>

      <p>
        <ref>
          https://radu-matei.com/blog/practical-guide-to-wasm-memory/
        </ref>

        (if you're further interested in the WebAssembly memory model,
        <a>hereâ€™s</a> a nice introduction.)
      </p>
    </note>
  </li>
</ul>

<p>
  Phew, that's a lot of information for one <code>fn() -&gt; String</code> that
  we <i>still</i> haven't seen working - but that's only because I wanted to
  give you an introduction as to <i>"why wasm-pack generates so many files"</i>
  and <i>"why no just cargo build"</i> - later we won't be inspecting those
  artifacts again.
</p>

<p>
  So, now that our crate is compiled, &lt;deep-breath /&gt;,
</p>

<p class="text-center">
  <b>how do we run it?</b>
</p>

<h2 id="hello-wasm-js">
  Hello, WebAssembly World! (the JavaScript part)
</h2>

<p>
  Frontend time!
</p>

<p>
  To start our frontend application, let's go back to the project's root
  directory (next to our top-level <code>Cargo.toml</code>):
</p>

<listing lang="shell">
  <!--
    $ cd ../..
  -->
</listing>

<p>
  <ref>
    https://github.com/rustwasm/create-wasm-app
  </ref>

  Setting up a frontend requires a bit of boilerplate too - luckily, this time
  we can use <code>npm init</code> to copy-paste the <a>WebAssembly frontend
  template project</a> for us:
</p>

<listing lang="shell">
  <!--
    $ npm init wasm-app www
  -->
</listing>

<p>
  You should now see a directory called <code>www</code> with a handful of
  files:
</p>

<listing lang="text">
  <!--
    $ ls -l www
    total 248
    -rw-r--r-- 1 pwy  10850 Apr  2 17:24 LICENSE-APACHE
    -rw-r--r-- 1 pwy   1052 Apr  2 17:24 LICENSE-MIT
    -rw-r--r-- 1 pwy   2595 Apr  2 17:24 README.md
    -rw-r--r-- 1 pwy    279 Apr  2 17:24 bootstrap.js
    -rw-r--r-- 1 pwy    297 Apr  2 17:24 index.html
    -rw-r--r-- 1 pwy     56 Apr  2 17:24 index.js
    -rw-r--r-- 1 pwy 209434 Apr  2 17:24 package-lock.json
    -rw-r--r-- 1 pwy    937 Apr  2 17:24 package.json
    -rw-r--r-- 1 pwy    311 Apr  2 17:24 webpack.config.js
  -->
</listing>

<p>
  ... let's briefly go through them.
</p>

<h3>
  Knowing your enemy
</h3>

<p>
  <i>Le point d'entrÃ©e</i>, similar to Rust's <code>main.rs</code>, here is
  <code>index.html</code>:
</p>

<listing-title>
  www/index.html
</listing-title>

<listing lang="html">
  <!--
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="utf-8">
        <title>Hello wasm-pack!</title>
      </head>
    
      <body>
        <script src="./bootstrap.js"></script>
      </body>
    </html>
  -->
</listing>

<p>
  A quick primer on HTML:
</p>

<ul>
  <li>
    <p>
      <code>&lt;something&gt;</code> is called a <b>tag</b>,
    </p>
  </li>
  <li>
    <p>
      a tag has an <b>opening</b>: <code>&lt;something&gt;</code>; and an
      <b>ending</b>: <code>&lt;/something&gt;</code>,
    </p>
  </li>
  <li>
    <p>
      a tag might contain <b>attributes</b>: <code>key="value"</code>,
    </p>
  </li>
  <li>
    <p>
      a tag might contain <b>children</b> (i.e. more tags inside of it).
    </p>
  </li>
</ul>

<p>
  <ref>
    https://en.wikipedia.org/wiki/Document_Object_Model
  </ref>

  Overall, an HTML document describes a <a>tree representation</a> of the web
  page:
</p>

<listing lang="text">
  <!--
    html
    â”œâ”€â”€ head
    â”‚   â”œâ”€â”€ meta
    â”‚   â””â”€â”€ title
    â””â”€â”€ body
        â””â”€â”€ script
  -->
</listing>

<p>
  ... which browser analyzes, trying to make something nice out of it.
</p>

<p>
  Each tag has a certain meaning:
</p>

<ul>
  <li>
    <p>
      <code>html</code> wraps the entire document,
    </p>
  </li>
  <li>
    <p>
      <code>head</code> contains document's metadata (such as its language or
      title),
    </p>
  </li>
  <li>
    <p>
      <code>body</code> contains document's contents,
    </p>
  </li>
  <li>
    <p>
      <code>script</code> loads and executes a JavaScript file,
    </p>
  </li>
  <li>
    <p>
      <code>p</code> (not used here, just provided as an example) prints text,
    </p>
  </li>
  <li>
    <p>
      <code>b</code> (ditto) prints text in bold:
    </p>

    <listing lang="html">
      <!--
        <body>
          <p>yes... ha ha ha... <b>yes!</b></p>
        </body>
      -->
    </listing>

    <figure class="sketch w-30">
      <img src="{{ assets }}/ab2b7ba1-2fbb-44a7-8126-592e2c8f4a1f.png" />
    </figure>
  </li>
</ul>

<p>
  Armed with all this knowledge, we can see that our page doesn't actually do
  that much - the most important thing is that it loads
  <code>bootstrap.js</code>:
</p>

<listing-title>
  www/bootstrap.js
</listing-title>

<listing lang="javascript">
  <!--
    import("./index.js")
      .catch(e => console.error("Error importing `index.js`:", e));
  -->
</listing>

<p>
  <code>import</code> is like Rust's <code>use</code> or
  <code>extern crate</code>. Contrary to Rust, in JavaScript
  <code>import</code> can be used as a <b>statement</b>, meaning that it
  <b>returns a value</b>; in pseudo-Rust, what happens above is:
</p>

<listing lang="rust">
  <!--
    (mod "./index.js")
        .await
        .map_err(|err| {
            eprintln!("Error importing ...", err);
        });
  -->
</listing>

<p>
  We can see that this code loads <code>index.js</code>, so let's take a look
  there:
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    import * as wasm from "hello-wasm-pack";
    //                     ^-------------^
    //                      defined in package.json
    
    wasm.greet();
  -->
</listing>

<p>
  This <code>import</code> is a bit different in that it resembles
  <code>extern crate</code> more:
</p>

<listing lang="rust">
  <!--
    extern crate hello_wasm_pack as wasm;

    wasm::greet();
  -->
</listing>

<p>
  When it comes to the application's code itself, that's all.
</p>

<p>
  We can also spot one more file, called <code>webpack.config.js</code> - while
  we won't have to touch it, it won't hurt to take a look either:
</p>

<listing-title>
  www/webpack.config.js
</listing-title>

<listing lang="javascript">
  <!--
    const CopyWebpackPlugin = require("copy-webpack-plugin");
    const path = require('path');
    
    module.exports = {
      entry: "./bootstrap.js",
      output: {
        path: path.resolve(__dirname, "dist"),
        filename: "bootstrap.js",
      },
      mode: "development",
      plugins: [
        new CopyWebpackPlugin(['index.html'])
      ],
    };
  -->
</listing>

<p>
  <ref>
    https://webpack.js.org/
  </ref>

  This file contains configuration for <a>webpack</a>, which isâ€‹ kinda like
  Cargo, but for JavaScript.
</p>

<note>
  <p>
    Since this is the second time I say "like Cargo", it's time to get more
    specific:
  </p>

  <ul>
    <li>
      <p>
        <ref>
          https://www.npmjs.com/
        </ref>

        <a>npm</a> manages dependencies,
      </p>
    </li>
    <li>
      <p>
        <ref id="webpack">
          https://webpack.js.org/
        </ref>

        <ref id="build">
          https://doc.rust-lang.org/cargo/reference/build-scripts.html
        </ref>

        <a ref="webpack">webpack</a> builds application (in a way, it's like
        <a ref="build">build.rs</a>).
      </p>
    </li>
  </ul>

  <p>
    Cargo does all of those things on its own (how comfy!), but for JavaScript
    we need those two, separate applications.
  </p>
</note>

<h3>
  What To Do After You Know Your Enemy
</h3>

<p>
  Having exchanged pleasantries with the filesystem, let's get back to the
  business:
</p>

<ol>
  <li>
    <p>
      Currently <code>npm</code> doesn't know about
      <code>lib-simulation-wasm</code> - let's fix it:
    </p>

    <listing-title>
      www/package.json
    </listing-title>

    <listing lang="javascript">
      <!--
        {
          /* ... */
          "devDependencies": {
      =     "lib-simulation-wasm": "file:../libs/simulation-wasm/pkg",
            /* ... */
          }
        }
      -->
    </listing>
  </li>
  <li>
    <p>
      After that, we have to let <code>npm</code> know about that change:
    </p>

    <listing lang="shell">
      <!--
        $ cd www
        $ npm install
      -->
    </listing>

    <note>
      <p>
        This command might print a few scary-looking messages:
      </p>

      <listing lang="text">
        <!--
          npm WARN optional SKIPPING OPTIONAL DEPENDENCY: ...
        -->
      </listing>

      <listing lang="text">
        <!--
          found 362 vulnerabilities (348 low, 4 moderate, 10 high)
            run `npm audit fix` to fix them, or `npm audit` for details
        -->
      </listing>

      <p>
        ... but worry not - that's just <code>npm</code> being <code>npm</code>;
        if it succeeds, then everything's alright.
      </p>
    </note>
  </li>
  <li>
    <p>
      Now it's time for <code>index.js</code>:
    </p>

    <listing-title>
      www/index.js
    </listing-title>

    <listing lang="javascript">
      <!--
      = import * as sim from "lib-simulation-wasm";
      = 
      = alert("Who's that dog? " + sim.whos_that_dog() + "!");
      -->
    </listing>

    <note>
      <p>
        <ref>
          https://developer.mozilla.org/en-US/docs/Glossary/Hoisting
        </ref>

        There's no <code>function main() { }</code>, that's because JavaScript
        doesn't need one - all the code gets to be executed top-down (<a>more or
        less</a>).
      </p>
    </note>
  </li>
  <li>
    <p>
      With everything ready, we can now launch our application - this is
      basically <code>cargo run</code>:
    </p>

    <listing lang="shell">
      <!--
        $ npm run start
      -->
    </listing>

    <listing lang="text">
      <!--
        ...
        â„¹ ï½¢wdsï½£: Project is running at http://localhost:8080/
        ...
      -->
    </listing>
  </li>
</ol>

<note>
  <p>
    <ref>
      https://stackoverflow.com/questions/69692842/error-message-error0308010cdigital-envelope-routinesunsupported
    </ref>

    If the command above fails with <code>error:0308010C</code>, you might be
    using <a>too new Node version</a> - in that case you should run it this way:
  </p>

  <listing lang="shell">
    <!--
    $ NODE_OPTIONS=--openssl-legacy-provider npm run start
    -->
  </listing>
</note>

<p>
  When you now open this link in your browser, you'll be greeted with a peppy,
  springy & spry:
</p>

<figure class="sketch">
  <img src="{{ assets }}/42ca83b3-8949-4b70-aa72-3b1b1a8bed17.png" />
</figure>

<p class="text-center">
  yay ðŸŽ‰ yay
</p>

<note>
  <p>
    By the way: when <code>npm run start</code> is working, it automatically
    listens for changes.
  </p>

  <p>
    If you'd like to modify this alert's message, simply go back to
    <code>lib.rs</code>, do whatever you want, run <code>wasm-pack build</code>,
    and - in a few seconds - the site should automatically reload.
  </p>

  <p>
    The same applies for HTML and JS, though you don't have to re-run
    <code>wasm-pack</code> then.
  </p>
</note>

<h2 id="hello-wasm-summary">
  Hello, WebAssembly World! (the summary part)
</h2>

<p>
  So...â€‹ what is all this?
</p>

<p>
  Granted, displaying an alert message doesn't exactly qualify us for Da Nobel
  Prize (unless i'm mistaken in which case please let me know
  <b><i>urgently</i></b> thanks) - but our point was to get something running
  quickly and we <i>did</i> get something running pretty quickly.
</p>

<p>
  In the next section, we'll lay the foundations for our simulation - just
  enough to have something to send to JavaScript.
</p>

<h2 id="hello-simulation">
  Hello, Simulation!
</h2>

<p>
  As before, to keep the boundaries clean & tidy, let's start by creating a new
  crate:
</p>

<listing lang="shell">
  <!--
    $ cd ../libs
    $ cargo new simulation --lib --name lib-simulation
  -->
</listing>

<p>
  This crate will contain our <span class="text-rainbow">simulation
  engine</span>:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
  = pub struct Simulation;
  -->
</listing>

<p>
  Now, to avoid conjuring a design out of <span class="text-spaced">thin
  air</span>, let's recall our drawing from before:
</p>

<figure class="sketch">
  <img src="/posts/learning-to-fly-pt1/assets/design-4.svg" />
</figure>

<p>
  What do we see there? Hmm, well - certainly a <b>world</b>:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
  = pub struct Simulation {
  =     world: World,
  = }
    
  = #[derive(Debug)]
  = pub struct World;
  -->
</listing>

<p>
  ... which contains some <b>animals</b> (<i>birds!</i>) and <b>foods</b>
  (<i>rich in protein & fiber!</i>):
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
  = pub struct World {
  =     animals: Vec<Animal>,
  =     foods: Vec<Food>,
  = }
    
  = #[derive(Debug)]
  = pub struct Animal;
    
  = #[derive(Debug)]
  = pub struct Food;
  -->
</listing>

<p>
  ... which are located at some <b>coordinates</b>:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
  = pub struct Animal {
  =     position: ?,
  = }
    
    #[derive(Debug)]
  = pub struct Food {
  =     position: ?,
  = }
  -->
</listing>

<note>
  <p>
    <i>Fun Related Note</i>
  </p>

  <p>
    Here, we're designing our models using object-oriented programming -
    although that's a correct approach, it's not the only one!
  </p>

  <p>
    <ref>
      https://ianjk.com/ecs-in-rust/
    </ref>

    There exists a cool pattern called <a><b>Entity Component System</b></a>
    which allows to express certain model &lt;-&gt; property relationships (such
    as <code>animal &lt;-&gt; position</code>) in a bit different,
    cleaner-when-there-are-lots-of-properties way.
  </p>

  <p>
    Using ECS goes beyond the scope of this article, so I'm merely sowing a seed
    if you happen to be looking for a cool design pattern to learn in the
    future.
  </p>
</note>

<p>
  Our world is two-dimensional, which sets us at:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct Animal {
  =     position: Point2,
    }
    
    #[derive(Debug)]
    pub struct Food {
  =     position: Point2,
    }
    
  = #[derive(Debug)]
  = pub struct Point2 {
  =     x: f32,
  =     y: f32,
  = }
  -->
</listing>

<p>
  Moreover, animals are of certain <b>rotati</b>...â€‹
</p>

<p class="text-center">
  wait - did you hear that?
</p>

<p class="text-center">
  oh no
</p>

<p class="text-center">
  who's that?
</p>

<p class="text-center">
  oh no
</p>

<p class="text-center">
  <ref>
    https://en.wikipedia.org/wiki/Not_invented_here
  </ref>

  ðŸš¨ it's the <a>not-invented-here</a> police ðŸš¨
</p>

<p>
  So far we've been writing a lot of code by hand - you know, that genetic
  algorithm and neural network, to name a few.
</p>

<p>
  At least now, when it comes to a few mathematical data structures, I'd like to
  avoid reinventing the wheel - in part because there's barely anything
  educational in writing:
</p>

<listing lang="rust" class="listing-invalid">
  <!--
    #[derive(Copy, Clone, Debug)]
    pub struct Point2 {
        x: f32,
        y: f32,
    }
    
    impl Point2 {
        pub fn new(...) -> Self {
            /* ... */
        }
    
        /* ... */
    }
    
    impl Add<Point2> for Point2 {
        /* ... */
    }
    
    impl Sub<Point2> for Point2 {
        /* ... */
    }
    
    impl Mul<Point2> for f32 {
        /* ... */
    }
    
    impl Mul<f32> for Point2 {
        /* ... */
    }
    
    #[cfg(test)]
    mod tests {
        /* ... */
    }
  -->
</listing>

<p>
  ... and in part because I'd like to introduce you to a crate that I love:
  <a href="https://nalgebra.org">nalgebra</a>!
</p>

<p>
  Quoting
  <a href="https://docs.rs/nalgebra/0.26.2/nalgebra/">their documentation</a>:
</p>

<blockquote>
  <p>
    nalgebra is a linear algebra library written for Rust targeting:
  </p>

  <ul>
    <li>
      <p>
        General-purpose linear algebra (still lacks a lot of features...)
      </p>
    </li>
    <li>
      <p>
        Real-time computer graphics.
      </p>
    </li>
    <li>
      <p>
        Real-time computer physics.
      </p>
    </li>
  </ul>
</blockquote>

<p>
  In other words: <i>math for the people, done right</i> - and it plays nice
  with WebAssembly as well.
</p>

<p>
  <ref id="clamp">
    https://docs.rs/nalgebra/0.26.2/nalgebra/fn.clamp.html
  </ref>

  <ref id="udq">
    https://docs.rs/nalgebra/0.26.2/nalgebra/geometry/type.UnitDualQuaternion.html
  </ref>

  <ref id="p2">
    https://docs.rs/nalgebra/0.26.2/nalgebra/geometry/type.Point2.html
  </ref>

  nalgebra provides a variety of tools: from simple functions such as
  <a ref="clamp">clamp</a>, through somewhat complicated structures such as
  <a ref="udq">quaternions</a>, to our beloved <a ref="p2">point</a>.
</p>

<p>
  Since it's just a crate, installing it boils down to editing the manifest:
</p>

<listing-title>
  libs/simulation/Cargo.toml
</listing-title>

<listing lang="toml">
  <!--
    # ...
    
    [dependencies]
  = nalgebra = "0.26"
  -->
</listing>

<p>
  ... and then our code from a moment ago becomes:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
  = use nalgebra as na;
    // --------- ^^
    // | This kind of import - one that uses `as` - is called an alias.
    // | You'd say that we're aliasing `nalgebra` as `na`.
    // ---
    
    /* ... */
    
    #[derive(Debug)]
    pub struct Animal {
  =     position: na::Point2<f32>,
    }
    
    #[derive(Debug)]
    pub struct Food {
  =     position: na::Point2<f32>,
    }
  -->
</listing>

<p>
  Where were we? Ah, right - animals are of certain <b>rotation</b> and
  <b>speed</b>:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct Animal {
        position: na::Point2<f32>,
  =     rotation: na::Rotation2<f32>,
  =     speed: f32,
    }
    
    /* ... */
  -->
</listing>

<note>
  <p>
    Overall, rotation and speed can be also represented together as a
    <b>vector</b>:
  </p>

  <listing lang="rust">
    <!--
      #[derive(Debug)]
      pub struct Animal {
          position: na::Point2<f32>,
          velocity: na::Vector2<f32>,
      }
    -->
  </listing>

  <p>
    We'll continue with two separate fields, because it makes certain
    computations easier later, but should you feel adventurous...â€‹
  </p>
</note>

<p>
  Now that we have a few models, it'd be nice if we could somehow construct
  them, so:
</p>

<listing-title>
  libs/simulation/Cargo.toml
</listing-title>

<listing lang="toml">
  <!--
    # ...
    
    [dependencies]
    nalgebra = "0.26"
  = rand = "0.8"
  -->
</listing>

<p>
  ... and while we're here, let's enable nalgebra's support for rand - it'll
  come handy in a moment:
</p>

<listing-title>
  libs/simulation/Cargo.toml
</listing-title>

<listing lang="toml">
  <!--
    # ...
    
    [dependencies]
  = nalgebra = { version = "0.26", features = ["rand-no-std"] }
    rand = "0.8"
  -->
</listing>

<p>
  We'll start with a few rudimentary constructors that just randomize
  everything:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    use nalgebra as na;
  = use rand::{Rng, RngCore};
    
    /* ... */
    
  = impl Simulation {
  =     pub fn random(rng: &mut dyn RngCore) -> Self {
  =         Self {
  =             world: World::random(rng),
  =         }
  =     }
  = }
  = 
  = impl World {
  =     pub fn random(rng: &mut dyn RngCore) -> Self {
  =         let animals = (0..40)
  =             .map(|_| Animal::random(rng))
  =             .collect();
  = 
  =         let foods = (0..60)
  =             .map(|_| Food::random(rng))
  =             .collect();
  = 
  =         // ^ Our algorithm allows for animals and foods to overlap, so
  =         // | it's hardly ideal - but good enough for our purposes.
  =         // |
  =         // | A more complex solution could be based off of e.g.
  =         // | Poisson disk sampling:
  =         // |
  =         // | https://en.wikipedia.org/wiki/Supersampling
  =         // ---
  = 
  =         Self { animals, foods }
  =     }
  = }
  = 
  = impl Animal {
  =     pub fn random(rng: &mut dyn RngCore) -> Self {
  =         Self {
  =             position: rng.gen(),
  =             // ------ ^-------^
  =             // | If not for `rand-no-std`, we'd have to do awkward
  =             // | `na::Point2::new(rng.gen(), rng.gen())` instead
  =             // ---
  = 
  =             rotation: rng.gen(),
  =             speed: 0.002,
  =         }
  =     }
  = }
  = 
  = impl Food {
  =     pub fn random(rng: &mut dyn RngCore) -> Self {
  =         Self {
  =             position: rng.gen(),
  =         }
  =     }
  = }
  -->
</listing>

<p>
  A <b>getter</b> is a function that allows to access object's state - a few of
  them will come useful:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
  =     pub fn world(&self) -> &World {
  =         &self.world
  =     }
    }
    
    impl World {
        /* ... */
    
  =     pub fn animals(&self) -> &[Animal] {
  =         &self.animals
  =     }
  = 
  =     pub fn foods(&self) -> &[Food] {
  =         &self.foods
  =     }
    }
    
    impl Animal {
        /* ... */
    
  =     pub fn position(&self) -> na::Point2<f32> {
  =         // ------------------ ^
  =         // | No need to return a reference, because na::Point2 is Copy.
  =         // |
  =         // | (meaning: it's so small that cloning it is cheaper than
  =         // | messing with references.)
  =         // |
  =         // | Of course you don't have to memorize which types are Copy
  =         // | and which aren't - if you accidentally return a reference
  =         // | to a type that's Copy, rust-clippy will point it out and
  =         // | suggest a change.
  =         // ---
  = 
  =         self.position
  =     }
  = 
  =     pub fn rotation(&self) -> na::Rotation2<f32> {
  =         self.rotation
  =     }
    }
    
    impl Food {
        /* ... */
    
  =     pub fn position(&self) -> na::Point2<f32> {
  =         self.position
  =     }
    }
  -->
</listing>

<p>
  Nice?
</p>

<ul>
  <li>
    <p>
      world? âœ… exists
    </p>
  </li>
  <li>
    <p>
      animals? âœ… exist
    </p>
  </li>
  <li>
    <p>
      foods? âœ… exist
    </p>
  </li>
</ul>

<p>
  Nice.
</p>

<p>
  There's a lot of code still missing, but at this point we've got enough to get
  âœ¨ something âœ¨ displayed on the screen via JavaScript.
</p>

<h3>
  All About That JS
</h3>

<p>
  Now, you might be wondering:
</p>

<blockquote>
  <p>
    If we want to invoke this from JavaScript, shouldn't we have
    <code>#[wasm_bindgen]</code> all over the place?
  </p>
</blockquote>

<p>
  ... to which I'll reply:
</p>

<p>
  Excellent question! &lt;high-fives himself /&gt;
</p>

<p>
  <ref>
    https://en.wikipedia.org/wiki/Separation_of_concerns
  </ref>

  I think that it's important to remember about <a>separation of concerns</a> -
  <code>lib-simulation</code> should be all about <i>"how to simulate
  evolution"</i>, not <i>"how to simulate evolution <b>and</b> integrate with
  WebAssembly"</i>.
</p>

<p>
  In a second we'll be implementing <code>lib-simulation-wasm</code> and if we
  keep <code>lib-simulation</code> frontend-agnostic, it'll be easy to create,
  say, <code>lib-simulation-bevy</code> or <code>lib-simulation-cli</code> next
  - all sharing the same simulation code underneath.
</p>

<p>
  Ok, let's go back to <code>lib-simulation-wasm</code> - we have to make it
  aware of <code>rand</code> and <code>lib-simulation</code>:
</p>

<listing-title>
  libs/simulation-wasm/Cargo.toml
</listing-title>

<listing lang="toml">
  <!--
    # ...
    
    [dependencies]
  = rand = "0.8"
    wasm-bindgen = "0.2"
    
  = lib-simulation = { path = "../simulation" }
                            # ^ path relative to *this* Cargo.toml
  -->
</listing>

<p>
  Now inside <code>lib-simulation-wasm</code> we can refer to
  <code>lib_simulation</code>:
</p>

<listing-title>
  libs/simulation-wasm/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
  = use lib_simulation as sim;
  -->
</listing>

<p>
  ... and implement a WebAssembly-aware <b>wrapper</b> (also known as
  <a href="https://en.wikipedia.org/wiki/Proxy_pattern">proxy</a>):
</p>

<listing-title>
  libs/simulation-wasm/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    use lib_simulation as sim;
  = use rand::prelude::*;
  = use wasm_bindgen::prelude::*;
  = 
  = #[wasm_bindgen]
  = pub struct Simulation {
  =     rng: ThreadRng,
  =     sim: sim::Simulation,
  = }
  = 
  = #[wasm_bindgen]
  = impl Simulation {
  =     #[wasm_bindgen(constructor)]
  =     pub fn new() -> Self {
  =         let mut rng = thread_rng();
  =         let sim = sim::Simulation::random(&mut rng);
  = 
  =         Self { rng, sim }
  =     }
  = }
  -->
</listing>

<p>
  As for baby steps, this looks good - let's try compiling it; surely nothing
  can fail <i>just yet</i>!
</p>

<listing-title>
  $ wasm-pack build
</listing-title>

<listing lang="text">
  <!--
    [INFO]: Checking for the Wasm target...
    [INFO]: Compiling to Wasm...
    
       Compiling getrandom v0.2.2
    
       error: target is not supported, for more information see:
              https://docs.rs/getrandom/#unsupported-targets
    -\-> /home/pwy/.cargo/registry/src/...
    3:9
        |
    213 | /         compile_error!("target is not supported, for more information see: \\
    214 | |                         https://docs.rs/getrandom/#unsupported-targets");
        | |_________________________________________________________________________^
    
    error[E0433]: failed to resolve: use of undeclared crate or module `imp`
       -\-> /home/pwy/.cargo/registry/src/...
    5:5
        |
    235 |     imp::getrandom_inner(dest)
        |     ^^^ use of undeclared crate or module `imp`
  -->
</listing>

<p class="text-center">
  <i>ayy, ayy</i>
</p>

<p>
  <ref>
    https://docs.rs/getrandom/0.2.2/getrandom/#unsupported-targets
  </ref>

  Being honest, this error took me by surprise - fortunately, the <a>linked
  page</a> describes what's going on quite well: <code>rand</code> internally
  depends on <code>getrandom</code>, which <i>does</i> support WebAssembly
  inside a web browser environment, but only when asked explicitly to:
</p>

<listing-title>
  libs/simulation-wasm/Cargo.toml
</listing-title>

<listing lang="toml">
  <!--
    # ...
    
    [dependencies]
    # ...
  = getrandom = { version = "0.2", features = ["js"] }
  -->
</listing>

<p>
  Let's try rebuilding now:
</p>

<listing-title>
  $ wasm-pack build
</listing-title>

<listing lang="text">
  <!--
    [INFO]: Checking for the Wasm target...
    [INFO]: Compiling to Wasm...
    
    warning: field is never read: `rng`
        ...
    
    warning: field is never read: `sim`
        ...
    
    warning: 2 warnings emitted
    
        Finished release [optimized] target(s) in 0.01s
    
    [WARN]: origin crate has no README
    [INFO]: Installing wasm-bindgen...
    [INFO]: Optimizing wasm binaries with `wasm-opt`...
    [INFO]: Optional fields missing from Cargo.toml: 'description',
            'repository', and 'license'. These are not necessary, but
             recommended
    [INFO]: :-) Done in 0.63s
    [INFO]: :-) Your wasm pkg is ready to publish at /home/pwy/Projects/...
  -->
</listing>

<p>
  On the JavaScript's side, we can now do:
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    import * as sim from "lib-simulation-wasm";
    
  = const simulation = new sim.Simulation();
    // --------------- ^-^
    // | For all practical purposes, this is a fancy syntax for Rust's:
    // | `Simulation::new()`
    // ---
  -->
</listing>

<p>
  Great, we've got the simulation engine up and running!
</p>

<p>
  However it's a pretty quiet engine, that one, because currently it just
  randomizes some animals and foods, and goes quiet. To make it fun, let's
  propagate more data into JavaScript.
</p>

<p>
  To do that, we'll need a few more models - they'll be kinda copy-pasted from
  <code>lib-simulation</code>, but with WebAssembly in mind:
</p>

<listing-title>
  libs/simulation-wasm/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[wasm_bindgen]
    pub struct Simulation {
        /* ... */
    }
    
  = #[wasm_bindgen]
  = #[derive(Clone, Debug)]
  = pub struct World {
  =     pub animals: Vec<Animal>,
  = }
  = 
  = #[wasm_bindgen]
  = #[derive(Clone, Debug)]
  = pub struct Animal {
  =     pub x: f32,
  =     pub y: f32,
  = }
    
    // ^ This model is smaller than `lib_simulation::Animal` - that's
    // | because a bird's position is all we need on the JavaScript's
    // | side at the moment; there's no need to map rest of the fields.
    
    /* ... */
  -->
</listing>

<p>
  ... and two conversion methods:
</p>

<listing-title>
  libs/simulation-wasm/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[wasm_bindgen]
    impl Simulation {
        /* ... */
    }

    /* ... */
    
  = impl From<&sim::World> for World {
  =     fn from(world: &sim::World) -> Self {
  =         let animals = world.animals().iter().map(Animal::from).collect();
  = 
  =         Self { animals }
  =     }
  = }
  = 
  = impl From<&sim::Animal> for Animal {
  =     fn from(animal: &sim::Animal) -> Self {
  =         Self {
  =             x: animal.position().x,
  =             y: animal.position().y,
  =         }
  =     }
  = }
  -->
</listing>

<p>
  With all that in our editor, we can now add:
</p>

<listing-title>
  libs/simulation-wasm/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[wasm_bindgen]
    impl Simulation {
        /* ... */
    
  =     pub fn world(&self) -> World {
  =         World::from(self.sim.world())
  =     }
    }
    
    /* ... */
  -->
</listing>

<p>
  ... aaaand
</p>

<p class="text-center">
  oh my
</p>

<p class="text-center">
  heart starts to
</p>

<p class="text-center">
  beat faster
</p>

<p class="text-center">
  as i execute
</p>

<p class="text-center">
  <code>$ wasm-pack build</code>
</p>

<p class="text-center">
  aaaaand
</p>

<p class="text-center">
  <i>oh no</i> ðŸ˜¢
</p>

<listing lang="text">
  <!--
    error[E0277]: the trait bound `Vec<Animal>: std::marker::Copy` is not satisfied
      -\-> libs/simulation-wasm/src/lib.rs
       |
       |     pub animals: Vec<Animal>,
       |                            ^ the trait `std::marker::Copy` is not ...
       |
  -->
</listing>

<p>
  This happens because <code>#[wasm_bindgen]</code> automatically creates
  getters and setters for JavaScript, but it requires for those fields to be
  <code>Copy</code> - intuitively, the macro does something similar to:
</p>

<listing lang="rust">
  <!--
    impl World {
        pub fn animals(&self) -> Vec<Animal> {
            self.animals
        }
    }
  -->
</listing>

<p>
  ... which also wouldn't work, not without an explicit <code>.clone()</code> -
  and that's exactly what we need to tell <code>#[wasm_bindgen]</code>:
</p>

<listing-title>
  libs/simulation-wasm/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */

    #[wasm_bindgen]
    #[derive(Clone, Debug)]
    pub struct World {
  =     #[wasm_bindgen(getter_with_clone)]
        pub animals: Vec<Animal>,
    }

    /* ... */
  -->
</listing>

<p>
  Call time!
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    import * as sim from "lib-simulation-wasm";
    
    const simulation = new sim.Simulation();
  = const world = simulation.world();
  -->
</listing>

<p>
  All this should work...â€‹ in theory - but how can we be sure our world contains
  any meaningful data? By using our own eyes!
</p>

<p>
  Most browsers expose a thing called <code>developer console</code> (also known
  as <code>developer tools</code>), which you should be able to access by
  pressing <code>F12</code>:
</p>

<p class="text-dim">
  (<a href="https://support.apple.com/guide/safari/use-the-developer-tools-in-the-develop-menu-sfri20948/mac">
    Safari users might require an extra hoop.</a>)
</p>

<figure class="sketch w-90">
  <img src="{{ assets }}/e24b0b5a-9e3b-4e14-a13e-f0529b35a05c.png" />
</figure>

<p>
  What can we do with this console? We can print stuff to it:
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
  = for (const animal of world.animals) {
  =   console.log(animal.x, animal.y);
  = }
  -->
</listing>

<p>
  <i>
    (I assume <code>npm run start</code> is still working in the
    background - if it's not, remember to re-launch it.)
  </i>
</p>

<note>
  <listing lang="javascript">
    <!--
      // Nobody can stop us now:
      console.log(Array(16).join('wat' - 1) + ' Batman!');
      
      // Haha, ha:
      console.log(console.log);
    -->
  </listing>
</note>

<p>
  Nice - now that we know the positions of animals, it means we can draw them!
</p>

<h2 id="hello-graphics">
  Hello, Graphics!
</h2>

<p>
  <ref>
    https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial
  </ref>

  Drawing stuff in HTML + JavaScript is relatively painless - we'll use a thing
  called <a><code>&lt;canvas&gt;</code></a>:
</p>

<listing-title>
  www/index.html
</listing-title>

<listing lang="html">
  <!--
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="utf-8">
        <title>Hello wasm-pack!</title>
      </head>
    
      <body>
  =     <canvas id="viewport"></canvas>
        <script src="./bootstrap.js"></script>
      </body>
    </html>
  -->
</listing>

<p>
  Our canvas has an attribute called <code>id</code> - this attribute is used to
  identify tags, so that they can be easily found from inside JavaScript:
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
  = const viewport = document.getElementById('viewport');
    // ------------- ^------^
    // | `document` is a global object that allows to access and modify
    // | current page (e.g. create or remove stuff from it).
    // ---
  -->
</listing>

<p>
  If you want to take a moment to digest what's happening, feel free to
  <code>console.log(viewport);</code> and click through its properties - there's
  a lot of them!
</p>

<p>
  To display stuff on <code>&lt;canvas&gt;</code>, we have to request for a
  specific drawing mode (think: 2D vs 3D):
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
  = const ctxt = viewport.getContext('2d');
  -->
</listing>

<p>
  So far, so good!
</p>

<note>
  <p>
    <ref>
      https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D
    </ref>

    For reference, our <code>ctxt</code> here is of type
    <a><code>CanvasRenderingContext2D</code></a>.
  </p>
</note>

<p>
  There are many methods and properties we can invoke on
  <code>ctxt</code> - let's start by investigating <code>fillStyle</code> and
  <code>fillRect()</code>:
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
    // ---
    // | Determines color of the upcoming shape.
    // - v-------v
  = ctxt.fillStyle = 'rgb(255, 0, 0)';
    // ------------------ ^-^ -^ -^
    // | Each of those three parameters is a number from range 0 up to 255:
    // |
    // | rgb(0, 0, 0) = black
    // |
    // | rgb(255, 0, 0) = red
    // | rgb(0, 255, 0) = green
    // | rgb(0, 0, 255) = blue
    // |
    // | rgb(255, 255, 0) = yellow
    // | rgb(0, 255, 255) = cyan
    // | rgb(255, 0, 255) = magenta
    // |
    // | rgb(128, 128, 128) = gray
    // | rgb(255, 255, 255) = white
    // ---
    
  = ctxt.fillRect(10, 10, 100, 50);
    // ---------- X   Y   W    H
    // | Draws rectangle filled with color determined by `fillStyle`.
    // |
    // | X = position on the X axis (left-to-right)
    // | Y = position on the Y axis (top-to-bottom)
    // | W = width
    // | X = height
    // |
    // | (unit: pixels)
    // ---
  -->
</listing>

<p>
  Launching this code should make our <code>&lt;canvas&gt;</code> print a red
  rectangle:
</p>

<figure class="sketch w-20">
  <img src="{{ assets }}/25e0b526-015d-4db5-8c1e-5516ef684b84.png" />
</figure>

<p>
  Ah, Mondrian would be so proud - I tell you: we're going places!
</p>

<note>
  <p>
    To be on the same page, <code>&lt;canvas&gt;</code>'s coordinate system is:
  </p>

  <figure class="sketch w-60">
    <img src="{{ assets }}/3b2960ca-6511-4686-9acd-a384969e257a.svg" />
  </figure>
</note>

<h3>
  Itâ€™s My Data
</h3>

<p>
  Now that we know how to draw rectangles, let's bring our data back into the
  picture:
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    import * as sim from "lib-simulation-wasm";
    
    const simulation = new sim.Simulation();
  = const viewport = document.getElementById('viewport');
  = const ctxt = viewport.getContext('2d');
  = 
  = ctxt.fillStyle = 'rgb(0, 0, 0)';
  = 
  = for (const animal of simulation.world().animals) {
  =     ctxt.fillRect(animal.x, animal.y, 15, 15);
  = }
  -->
</listing>

<p>
  ... and:
</p>

<figure class="sketch w-10">
  <img src="{{ assets }}/eb853ead-5d7e-4c0d-9e6a-ca26bb515a10.png" />
</figure>

<p>
  Well, ain't that a bummer - what happened? Let's investigate our data once
  again:
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
  = for (const animal of simulation.world().animals) {
  =   console.log(animal.x, animal.y);
  = }
  -->
</listing>

<listing lang="text">
  <!--
    0.6751065850257874 0.9448947906494141
    0.2537931203842163 0.4474523663520813
    0.7111597061157227 0.731094241142273
    0.20178401470184326 0.5820554494857788
    0.7062546610832214 0.3024316430091858
    0.030273854732513428 0.4638679623603821
    0.48392945528030396 0.9207395315170288
    0.49439138174057007 0.24340438842773438
    0.5087683200836182 0.10066533088684082
    /* ... */
  -->
</listing>

<p>
  Ah, positions of our animals belong to range <code>&lt;0.0, 1.0&gt;</code>,
  while <code>&lt;canvas&gt;</code> expects coordinates in the unit of a
  <b>pixel</b> - we can fix this by scaling the numbers while rendering:
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
    const viewport = document.getElementById('viewport');
  = const viewportWidth = viewport.width;
  = const viewportHeight = viewport.height;
    
    /* ... */
    
    for (const animal of simulation.world().animals) {
  =     ctxt.fillRect(
  =         animal.x * viewportWidth,
  =         animal.y * viewportHeight,
  =         15,
  =         15,
  =     );
    }
  -->
</listing>

<p>
  ... which gets us:
</p>

<figure class="sketch w-40">
  <img src="{{ assets }}/2e91178c-5441-4f66-9fbf-001d76ad752d.png" />
</figure>

<note>
  <p>
    If you've got an HiDPI display, you might notice that the canvas looks
    blurry - please do not adjust your television set, all's "correct".
  </p>

  <p>
    It's because most, if not all, browsers render canvases without adjusting
    for screen's pixel density and then artificially <b>upscale</b> the image
    to match the actual resolution of the screen.
  </p>

  <p>
    Overcoming this inconvenience requires a bit of a trickery that boils down
    to enlarging the canvas manually before any drawing happens, as to "correct"
    the browser's default behavior:
  </p>

  <listing lang="javascript">
    <!--
      /* ... */
      
      const viewportWidth = viewport.width;
      const viewportHeight = viewport.height;
      
      const viewportScale = window.devicePixelRatio || 1;
      // ------------------------------------------ ^^^^
      // | Syntax-wise, it's like: .unwrap_or(1)
      // |
      // | This value determines how much physical pixels there are per
      // | each single pixel on a canvas.
      // |
      // | Non-HiDPI displays usually have a pixel ratio of 1.0, which
      // | means that drawing a single pixel on a canvas will lighten-up
      // | exactly one physical pixel on the screen.
      // |
      // | My display has a pixel ratio of 2.0, which means that for each
      // | single pixel drawn on a canvas, there will be two physical
      // | pixels modified by the browser.
      // ---
      
      // The Trick, part 1: we're scaling-up canvas' *buffer*, so that it
      // matches the screen's pixel ratio
      viewport.width = viewportWidth * viewportScale;
      viewport.height = viewportHeight * viewportScale;
      
      // The Trick, part 2: we're scaling-down canvas' *element*, because
      // the browser will automatically multiply it by the pixel ratio in
      // a moment.
      //
      // This might seem like a no-op, but the maneuver lies in the fact
      // that modifying a canvas' element size doesn't affect the canvas'
      // buffer size, which internally *remains* scaled-up:
      //
      // ----------- < our entire page
      // |         |
      // |   ---   |
      // |   | | < | < our canvas
      // |   ---   |   (size: viewport.style.width & viewport.style.height)
      // |         |
      // -----------
      //
      // Outside the page, in the web browser's memory:
      //
      // ----- < our canvas' buffer
      // |   | (size: viewport.width & viewport.height)
      // |   |
      // -----
      viewport.style.width = viewportWidth + 'px';
      viewport.style.height = viewportHeight + 'px';
      
      const ctxt = viewport.getContext('2d');
      
      // Automatically scales all operations by `viewportScale` - otherwise
      // we'd have to `* viewportScale` everything by hand
      ctxt.scale(viewportScale, viewportScale);
      
      // Rest of the code follows without any changes
      ctxt.fillStyle = 'rgb(0, 0, 0)';
      
      for (const animal of simulation.world().animals) {
          ctxt.fillRect(
              animal.x * viewportWidth,
              animal.y * viewportHeight,
              15,
              15,
          );
      }
    -->
  </listing>

  <p>
    As promised, this gets us a sharp image:
  </p>

  <figure class="sketch w-40">
    <img src="{{ assets }}/4248d354-2b4c-420b-87c1-c1d249cdff84.png" />
  </figure>
</note>

<p>
  So...â€‹ would you believe it, someone told me that squares are <b>not
  fashionable</b> anymore!
</p>

<p>
  Apparently â–¼ triangles â–² are all the rage, so let's try drawing one.
</p>

<p>
  Somewhat unluckily, JavaScript doesn't provide any method for printing
  triangles, requiring us to draw them manually vertex-by-vertex instead.
</p>

<p>
  To get a grip of how it works, let's start with a hard-coded example:
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
    // Starts drawing a polygon
  = ctxt.beginPath();
    
    // Moves cursor at x=50, y=0
  = ctxt.moveTo(50, 0);
    
    // Draws a line from (50,0) to (100,50) and moves cursor there
    // (this gets us the right side of our triangle)
  = ctxt.lineTo(100, 50);
    
    // Draws a line from (100,50) to (0,50) and moves cursor there
    // (this gets us the bottom side of our triangle)
  = ctxt.lineTo(0, 50);
    
    // Draws a line from (0,50) to (50,0) and moves cursor there
    // (this gets us the left side of our triangle)
  = ctxt.lineTo(50, 0);
    
    // Fills our triangle with a black color
    //
    // (there's also `ctxt.stroke();`, which would render only our triangle's
    // outline instead.)
  = ctxt.fillStyle = 'rgb(0, 0, 0)';
  = ctxt.fill();
  -->
</listing>

<p>
  ... aaaand, what a beauty!
</p>

<figure class="sketch w-30">
  <img src="{{ assets }}/bc321864-81b2-4f69-90c0-57edda4ae04f.png" />
</figure>

<p>
  Since drawing a triangle requires a few steps, to make it easier to use, let's
  make it a function:
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
  = function drawTriangle(ctxt, x, y, size) {
  =     ctxt.beginPath();
  =     ctxt.moveTo(x, y);
  =     ctxt.lineTo(x + size, y + size);
  =     ctxt.lineTo(x - size, y + size);
  =     ctxt.lineTo(x, y);
  = 
  =     ctxt.fillStyle = 'rgb(0, 0, 0)';
  =     ctxt.fill();
  = }
  = 
  = drawTriangle(ctxt, 50, 0, 50);
  -->
</listing>

<p>
  ... or, a bit more idiomatic:
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
    // ---
    // | The type of our `ctxt`.
    // v------------------ v
  = CanvasRenderingContext2D.prototype.drawTriangle =
  =     function (x, y, size) {
  =         this.beginPath();
  =         this.moveTo(x, y);
  =         this.lineTo(x + size, y + size);
  =         this.lineTo(x - size, y + size);
  =         this.lineTo(x, y);
  =
  =         this.fillStyle = 'rgb(0, 0, 0)';
  =         this.fill();
  =     };
  = 
  = ctxt.drawTriangle(50, 0, 50);
  -->
</listing>

<note>
  <p>
    JavaScripts allows for methods to be created willy-nilly at runtime - a
    similar code in Rust would require creating a trait:
  </p>

  <listing lang="rust">
    <!--
      trait DrawTriangle {
          fn draw_triangle(&mut self, x: f32, y: f32, size: f32);
      }
      
      impl DrawTriangle for CanvasRenderingContext2D {
          fn draw_triangle(&mut self, x: f32, y: f32, size: f32) {
              self.begin_path();
              /* ... */
          }
      }
    -->
  </listing>
</note>

<p>
  Equipped with <code>.drawTriangle()</code>, we can now do:
</p>

<listing-title>
  www/index.html
</listing-title>

<listing lang="html">
  <!--
    <!-- ... -\->
  = <canvas id="viewport" width="800" height="800"></canvas>
    <!-- ... -\->
  -->
</listing>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
  = for (const animal of simulation.world().animals) {
  =     ctxt.drawTriangle(
  =         animal.x * viewportWidth,
  =         animal.y * viewportHeight,
  =         0.01 * viewportWidth,
  =     );
  = }
  -->
</listing>

<figure class="sketch w-30">
  <img src="{{ assets }}/37718e09-3278-44ef-a104-28cb5486e4ff.png" />
</figure>

<note>
  <p>
    If those triangles look too small for you, feel free to adjust the canvas'
    size and the <code>0.01</code> parameter.
  </p>
</note>

<p>
  Nice ðŸ˜Ž
</p>

<p style="display: block">
  <span style="display: inline-block">
    ... and you know what would be even nicer? If they were
  </span>

  <span style="display: inline-block; font-weight: bold; transform: rotate(-35deg)">
    rotated!
  </span>
</p>

<h3>
  Vertices Go Brr
</h3>

<p>
  We already have a field called <code>rotation</code> inside
  <code>lib-simulation</code>:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct Animal {
        /* ... */
        rotation: na::Rotation2<f32>,
        /* ... */
    }
  -->
</listing>

<p>
  ... so all we've gotta do is to pass it into JavaScript:
</p>

<listing-title>
  libs/simulation-wasm/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */

    #[wasm_bindgen]
    #[derive(Clone, Debug)]
    pub struct Animal {
        pub x: f32,
        pub y: f32,
  =     pub rotation: f32,
    }

    impl From<&sim::Animal> for Animal {
        fn from(animal: &sim::Animal) -> Self {
            Self {
                x: animal.position().x,
                y: animal.position().y,
  =             rotation: animal.rotation().angle(),
            }
        }
    }

    /* ... */
  -->
</listing>

<p>
  ... now <code>wasm-pack build</code>:
</p>

<listing-title>
  $ wasm-pack build
</listing-title>

<listing lang="text">
  <!--
    ...
    [INFO]: :-) Done in 2.42s
    [INFO]: :-) Your wasm pkg is ready to publish at /home/pwy/Projects/...
  -->
</listing>

<p>
  ... and we're back to JavaScript.
</p>

<p>
  Since the rotation will be different for each triangle, we'll need to have
  another parameter:
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
    CanvasRenderingContext2D.prototype.drawTriangle =
  =     function (x, y, size, rotation) {
            /* ... */
        };
    
    /* ... */
  -->
</listing>

<p>
  Intuitively, what we're looking for is:
</p>

<figure class="sketch w-80">
  <img src="{{ assets }}/d50a7a76-abc0-415c-b43c-dff76f18b242.svg" />
</figure>

<p>
  ... but generalized for any angle.
</p>

<h3>
  Vertices Go Brrr (using math)
</h3>

<p>
  Let's bring back our triangle - this time, together with its
  <b>circumscribed circle</b>:
</p>

<figure class="sketch w-40">
  <img src="{{ assets }}/0b4f3862-3b22-4499-a4b1-3d29099c5e76.svg" />
</figure>

<p>
  Under this circumstances, I'd casually describe rotating as moving each vertex
  alongside the circle "with" certain angle:
</p>

<figure class="sketch w-50">
  <img src="{{ assets }}/52ce2085-216f-4ff9-85b7-7dd0c5f44d26.svg" />
</figure>

<p>
  How do we know where to move those points? Well, whenever there's a circle
  involved, there's probably a fair share of trigonometry happening underneath
  - it's certainly true this time!
</p>

<p>
  You might've heard of <code>cos()</code> and <code>sin()</code> - while they
  aren't that impressive plotted separately:
</p>

<figure class="sketch w-90">
  <img src="{{ assets }}/0ee9c7b5-80a5-4c5e-92e0-f72104f4aeca.svg" />
</figure>

<p>
  ... when we juxtapose both of them on a circle, we might just spot that what
  <code>cos(angle)</code> returns in practice is the <code>y</code> coordinate
  of a point "rotated" with given angle - and, similarly,
  <code>sin(angle)</code> gives the <code>x</code> coordinate:
</p>

<figure class="sketch w-50">
  <img src="{{ assets }}/dd44883a-ab9b-4ed7-be1e-b97d4b50e128.svg" />
</figure>

<note>
  <p>
    I'm using quotes around <i>rotated</i>, because technically it makes little
    to no sense to talk about rotation of a point - but hopefully the
    mathematicians among you will forgive me for I have semantically-sinned in a
    good faith.
  </p>

  <p>
    Also, foreshadowing a bit: we're actually going to use
    <code>x = -sin(angle)</code>, because Nalgebra understands rotations
    counterclockwise.
  </p>
</note>

<p>
  Speaking in code-terms - if what we have currently is:
</p>

<listing lang="javascript">
  <!--
    this.moveTo(x, y);
  -->
</listing>

<p>
  ... then rotating the <code>x</code> coordinate requires applying
  <code>- sin()</code>:
</p>

<listing lang="javascript">
  <!--
    this.moveTo(
  =     x - Math.sin(rotation) * size,
        y,
    );
  -->
</listing>

<p>
  ... and rotating the <code>y</code> coordinate requires applying
  <code>+ cos()</code>:
</p>

<listing lang="javascript">
  <!--
    this.moveTo(
        x - Math.sin(rotation) * size,
  =     y + Math.cos(rotation) * size,
    );
  -->
</listing>

<p>
  ... where <code>rotation</code> is measured in <b>radians</b> - that is,
  <code>&lt;0Â°, 360Â°&gt;</code> shrank to <code>&lt;0, 2 * PI&gt;</code>:
</p>

<ul>
  <li>
    <p>
      0Â° â‡’ <code>rotation = 0</code>
    </p>
  </li>
  <li>
    <p>
      180Â° â‡’ <code>rotation = PI</code>
    </p>
  </li>
  <li>
    <p>
      360Â° â‡’ <code>rotation = 2 * PI</code>
    </p>
  </li>
  <li>
    <p>
      90Â° â‡’ 180Â° / 2 â‡’ <code>rotation = PI / 2</code>
    </p>
  </li>
  <li>
    <p>
      45Â° â‡’ 180Â° / 4 â‡’ <code>rotation = PI / 4</code>
    </p>
  </li>
  <li>
    <p>
      and so on.
    </p>
  </li>
</ul>

<p>
  Okie - one vertex done:
</p>

<figure class="sketch w-40">
  <img src="{{ assets }}/e0fa1f63-964b-49ba-9e32-4eab5d249a13.svg" />
</figure>

<p>
  ... two more to go!
</p>

<p>
  Since the entire circle takes 360Â° and we've got three vertices to draw, then
  each vertex is going to occupy 360Â° / 3 = 120Â°; considering that first vertex
  lays on 0Â°, the second vertex is going to be located at 120Â°.
</p>

<p>
  A quick conversion to radians, using proportions:
</p>

<listing lang="text">
  <!--
    { 2 * PI = 360Â°
    {      x = 120Â°

             ^
             |
             v

    360Â° * x = 2 * PI * 120Â°    | divide by 2
    180Â° * x = PI * 120Â°        | divide by 180Â°
           x = PI * 120Â° / 180Â° | simplify
           x = PI * 2 / 3       | shuffle constant to left
           x = 2 / 3 * PI       | enjoy
  -->
</listing>

<p>
  ... gives us:
</p>

<listing lang="javascript">
  <!--
    this.moveTo(
        x - Math.sin(rotation) * size,
        y + Math.cos(rotation) * size,
    );
    
  = this.lineTo(
  =     x - Math.sin(rotation + 2.0 / 3.0 * Math.PI) * size,
  =     y + Math.cos(rotation + 2.0 / 3.0 * Math.PI) * size,
  = );
  -->
</listing>

<figure class="sketch w-40">
  <img src="{{ assets }}/bce2d60a-cd7e-4666-84f3-76ef6dbb043a.svg" />
</figure>

<p>
  Similarly, for the third vertex:
</p>

<listing lang="text">
  <!--
    2 * PI = 360Â°
         x = 120Â° + 120Â°
    
    /* ... */
    
    x = 4 / 3 * PI
  -->
</listing>

<p>
  ... giving us:
</p>

<listing lang="javascript">
  <!--
    this.moveTo(
        x - Math.sin(rotation) * size,
        y + Math.cos(rotation) * size,
    );
    
    this.lineTo(
        x - Math.sin(rotation + 2.0 / 3.0 * Math.PI) * size,
        y + Math.cos(rotation + 2.0 / 3.0 * Math.PI) * size,
    );
    
  = this.lineTo(
  =     x - Math.sin(rotation + 4.0 / 3.0 * Math.PI) * size,
  =     y + Math.cos(rotation + 4.0 / 3.0 * Math.PI) * size,
  = );
  -->
</listing>

<figure class="sketch w-40">
  <img src="{{ assets }}/66781628-c317-4a0c-98ce-b5317abf4c4c.svg" />
</figure>

<note>
  <p>
    For what it's worth, instead of <code>+ 4.0 / 3.0</code>, we could've also
    used <code>- 2.0 / 3.0</code> (meaning "60Â° counterclockwise from the top
    vertex"):
  </p>

  <listing lang="javascript">
    <!--
      this.lineTo(
          x - Math.sin(rotation - 2.0 / 3.0 * Math.PI) * size,
          y + Math.cos(rotation - 2.0 / 3.0 * Math.PI) * size,
      );
    -->
  </listing>

  <p>
    ... as both
    <a href="https://www.wolframalpha.com/input/?i=sin%28x+-+2%2F3+*+pi%29+%3D+sin%28x+%2B+4%2F3+*+pi%29">
      are identical
    </a>.
  </p>
</note>

<p>
  As you might see in the drawing, now we're missing only the very last edge
  going from the third vertex back into the first:
</p>

<figure class="sketch w-40">
  <img src="{{ assets }}/13650115-7ac4-47d2-a1d5-bcf1c3c7b370.svg" />
</figure>

<p>
  ... so:
</p>

<listing lang="javascript">
  <!--
    /* ... */
    
    this.lineTo(
        x - Math.sin(rotation + 4.0 / 3.0 * Math.PI) * size,
        y + Math.cos(rotation + 4.0 / 3.0 * Math.PI) * size,
    );
    
  = this.lineTo(
  =     x - Math.sin(rotation) * size,
  =     y + Math.cos(rotation) * size,
  = );
  -->
</listing>

<p>
  In all its glory, our code is:
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
  = CanvasRenderingContext2D.prototype.drawTriangle =
  =     function (x, y, size, rotation) {
  =         this.beginPath();
  = 
  =         this.moveTo(
  =             x - Math.sin(rotation) * size,
  =             y + Math.cos(rotation) * size,
  =         );
  = 
  =         this.lineTo(
  =             x - Math.sin(rotation + 2.0 / 3.0 * Math.PI) * size,
  =             y + Math.cos(rotation + 2.0 / 3.0 * Math.PI) * size,
  =         );
  = 
  =         this.lineTo(
  =             x - Math.sin(rotation + 4.0 / 3.0 * Math.PI) * size,
  =             y + Math.cos(rotation + 4.0 / 3.0 * Math.PI) * size,
  =         );
  = 
  =         this.lineTo(
  =             x - Math.sin(rotation) * size,
  =             y + Math.cos(rotation) * size,
  =         );
  = 
  =         this.stroke();
  =     };
  = 
  = ctxt.drawTriangle(50, 50, 25, Math.PI / 4);
  -->
</listing>

<p>
  Does it work? Apparently:
</p>

<figure class="sketch w-20">
  <img src="{{ assets }}/7c0a009c-202c-4666-ac69-e6c03cf75bae.png" />
</figure>

<p>
  ... but it's kinda hard to spot that it's rotated - what if we extruded one of
  the vertices?
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
    CanvasRenderingContext2D.prototype.drawTriangle =
        function (x, y, size, rotation) {
            this.beginPath();
    
            this.moveTo(
  =             x - Math.sin(rotation) * size * 1.5,
  =             y + Math.cos(rotation) * size * 1.5,
            );
    
            /* ... */
    
            this.lineTo(
  =             x - Math.sin(rotation) * size * 1.5,
  =             y + Math.cos(rotation) * size * 1.5,
            );
    
            this.stroke();
        };
    
    /* ... */
  -->
</listing>

<p>
  There, better:
</p>

<figure class="sketch w-30">
  <img src="{{ assets }}/e53c3146-b334-4b4d-8492-09b6c37b4293.png" />
</figure>

<h3>
  Animals Go Brrr
</h3>

<p>
  Now that we are able to render rotated triangles, we can adjust our code from
  before:
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
    for (const animal of simulation.world().animals) {
        ctxt.drawTriangle(
            animal.x * viewportWidth,
            animal.y * viewportHeight,
            0.01 * viewportWidth,
  =         animal.rotation,
        );
    }
  -->
</listing>

<p>
  ... which gives us:
</p>

<figure class="sketch w-60">
  <img src="{{ assets }}/e5597f34-11e5-48cc-b76c-329f0ee543d6.png" />
</figure>

<p>
  Neat; high five, <span class="text-rainbow">pal</span> - we've earned it!
</p>

<h2 id="stepping-stones">
  step()-ping stones
</h2>

<p>
  Stationary triangles are cool - obviously! -- but <b>moving</b> triangles are
  cooler.
</p>

<p>
  Our birds don't have brains, but they do have rotation & speed - this means we
  can simulate physics on them, even if they won't be able to interact with
  their environment yet:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
        /// Performs a single step - a single second, so to say - of our
        /// simulation.
  =     pub fn step(&mut self) {
  =         for animal in &mut self.world.animals {
  =             animal.position += animal.rotation * animal.speed;
  =         }
  =     }
    }
    
    /* ... */
  -->
</listing>

<p>
  One <code>cargo check</code> after:
</p>

<listing-title>
  $ cargo check
</listing-title>

<listing lang="text">
  <!--
    error[E0277]: cannot multiply `Rotation<f32, 2_usize>` by `f32`
       |
       |             animal.position += animal.rotation * animal.speed;
       |                                                ^
       |             -----------------------------------|
       |             no implementation for `Rotation<f32, 2_usize> * f32`
       |
       = help: the trait `Mul<f32>` is not implemented for
         `Rotation<f32, 2_usize>`
  -->
</listing>

<p>
  Hmm, nalgebra doesn't provide <code>Rotation2 * f32</code> - maybe we can use
  a vector instead?
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
  = animal.position += animal.rotation * na::Vector2::new(0.0, animal.speed);
  -->
</listing>

<listing-title>
  $ cargo check
</listing-title>

<listing lang="text">
  <!--
    Finished dev [unoptimized + debuginfo] target(s) in 18.04s
  -->
</listing>

<p>
  Bingo!
</p>

<note>
  <blockquote>
    <p>
      Wait, wait - why <code>::new(0.0, animal.speed)</code>?
    </p>
  </blockquote>

  <p>
    nalgebra assumes no specific point of reference - instruction
    <code>please move at 45Â°</code> doesn't contain enough information to
    actually compute where the birdie should get moved: it's 45Â° according to
    which axis?
  </p>

  <figure class="sketch w-80">
    <img src="{{ assets }}/2b162f23-e9ab-4c46-8f61-0ce617366de0.svg" />
  </figure>

  <p>
    So that's the issue our <code>::new(0.0, animal.speed)</code> solves - it
    says that we're interested in rotating relative to the <code>Y</code> axis,
    that is: a bird with rotation of 0Â° will fly <b>upwards</b>.
  </p>

  <p>
    All said, this is a rather arbitrary decision that just neatly aligns with
    how we render triangles on <code>&lt;canvas&gt;</code>; we might've as well
    done e.g. <code>::new(-animal.speed, 0.0)</code> and adjust our
    <code>drawTriangle()</code> to account for that.
  </p>
</note>

<p>
  With <code>step()</code> inside <code>lib-simulation</code>, we can now expose
  it via <code>lib-simulation-wasm</code>:
</p>

<listing-title>
  libs/simulation-wasm/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[wasm_bindgen]
    impl Simulation {
        /* ... */
    
  =     pub fn step(&mut self) {
  =         self.sim.step();
  =     }
    }
    
    /* ... */
  -->
</listing>

<p>
  ... and compile:
</p>

<listing-title>
  $ wasm-pack build
</listing-title>

<listing lang="text">
  <!--
    ....
    [INFO]: :-) Done in 3.58s
    [INFO]: :-) Your wasm pkg is ready to publish at /home/pwy/Projects/...
  -->
</listing>

<p>
  As for invoking <code>.step()</code> from JavaScript - while in some languages
  we might've used a loop:
</p>

<listing lang="javascript" class="listing-invalid">
  <!--
    /* ... */
    
    while (true) {
         ctxt.clearRect(0, 0, viewportWidth, viewportHeight);
    
         simulation.step();
    
         for (const animal of simulation.world().animals) {
             ctxt.drawTriangle(
                 animal.x * viewportWidth,
                 animal.y * viewportHeight,
                 0.01 * viewportWidth,
                 animal.rotation,
             );
         }
    }
  -->
</listing>

<p>
  ... the web browser environment makes it a bit harder, because our code
  <b>mustn't block</b>. That's because when JavaScript is working, browser waits
  for it to finish, hanging the tab and preventing user from interacting with
  the page.
</p>

<p>
  The more time it takes for the code to complete, the longer the tab is
  blocked - it's essentially single-threaded. So if we wrote
  <code>while (true) { ...â€‹ }</code>, the browser would just hang the tab forever,
  patiently waiting for the code to finish working.
</p>

<p>
  <ref>
    https://developer.mozilla.org/pl/docs/Web/API/Window/requestAnimationFrame
  </ref>

  Instead of blocking, we can use a function called
  <a><code>requestAnimationFrame()</code></a> - it <b>schedules</b> a function
  to be executed just before the next frame is drawn and it itself finishes
  immediately:
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
  = function redraw() {
  =     ctxt.clearRect(0, 0, viewportWidth, viewportHeight);
  = 
  =     simulation.step();
  = 
  =     for (const animal of simulation.world().animals) {
  =         ctxt.drawTriangle(
  =             animal.x * viewportWidth,
  =             animal.y * viewportHeight,
  =             0.01 * viewportWidth,
  =             animal.rotation,
  =         );
  =     }
  = 
  =     // requestAnimationFrame() schedules code only for the next frame.
  =     //
  =     // Because we want for our simulation to continue forever, we've
  =     // gotta keep re-scheduling our function:
  =     requestAnimationFrame(redraw);
  = }
  = 
  = redraw();
  -->
</listing>

<p>
  And voilÃ :
</p>

<figure>
  <video src="{{ assets }}/4828f46c-2f2a-44a9-9d64-56ef61aa692e.mp4" />
</figure>

<p>
  ... or rather voil-<i>whaaat</i> - why do they disappear after a while?
</p>

<p>
  Let's go back to <code>lib-simulation</code> and investigate:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
        pub fn step(&mut self) {
            for animal in &mut self.world.animals {
                animal.position += animal.rotation * na::Vector2::new(animal.speed, 0.0);
            }
        }
    }
    
    /* ... */
  -->
</listing>

<p>
  So we add rotation to position and...â€‹ ah, right! Our map is bounded by
  <code>&lt;0.0, 1.0&gt;</code> - anything beyond those coordinates can exist,
  but it'd be rendered outside the canvas; as we've just seen.
</p>

<p>
  Let's fix it:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
        pub fn step(&mut self) {
            for animal in &mut self.world.animals {
                animal.position += animal.rotation * na::Vector2::new(0.0, animal.speed);
    
  =             animal.position.x = na::wrap(animal.position.x, 0.0, 1.0);
  =             animal.position.y = na::wrap(animal.position.y, 0.0, 1.0);
            }
        }
    }
    
    /* ... */
  -->
</listing>

<p>
  <a href="https://docs.rs/nalgebra/0.26.2/nalgebra/fn.wrap.html"><code>wrap()</code></a>
  does pretty much what it says - the first argument is the number being
  checked, while the second and third arguments determine minimum and maximum
  allowed values:
</p>

<ul>
  <li>
    <p>
      <code>na::wrap(0.5, 0.0, 1.0) == 0.5</code>
      (numbers between <code>[min,max]</code> are left untouched),
    </p>
  </li>
  <li>
    <p>
      <code>na::wrap(-0.5, 0.0, 1.0) == 1.0</code>
      (<code>if number &lt; min { return max; }</code>),
    </p>
  </li>
  <li>
    <p>
      <code>na::wrap(1.5, 0.0, 1.0) == 0.0</code>
      (<code>if number &gt; max { return min; }</code>).
    </p>
  </li>
</ul>

<p>
  With this fix, let's <code>$ wasm-pack build</code> - and:
</p>

<figure>
  <video src="{{ assets }}/0653f996-eb04-4c17-a1ff-06733b46f30c.mp4" />
</figure>

<p>
  Woohoo!
</p>

<h2 id="ur-somebody-else">
  Youâ€™re Somebody Else (when youâ€™re hungry)
</h2>

<p>
  All said, birds constitute for only half of our ecosystem - we've also got
  food.
</p>

<h3>
  Rendering food
</h3>

<p>
  Fortunately, because we've already written lots of the code, rendering food
  distills to just a few changes:
</p>

<listing-title>
  libs/simulation-wasm/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */

    #[wasm_bindgen]
    #[derive(Clone, Debug)]
    pub struct World {
        #[wasm_bindgen(getter_with_clone)]
        pub animals: Vec<Animal>,

  =     #[wasm_bindgen(getter_with_clone)]
  =     pub foods: Vec<Food>,
    }

    impl From<&sim::World> for World {
        fn from(world: &sim::World) -> Self {
            let animals = world.animals().iter().map(Animal::from).collect();
  =         let foods = world.foods().iter().map(Food::from).collect();
  =
  =         Self { animals, foods }
        }
    }
    
    /* ... */

  = #[wasm_bindgen]
  = #[derive(Clone, Debug)]
  = pub struct Food {
  =     pub x: f32,
  =     pub y: f32,
  = }
  =
  = impl From<&sim::Food> for Food {
  =     fn from(food: &sim::Food) -> Self {
  =         Self {
  =             x: food.position().x,
  =             y: food.position().y,
  =         }
  =     }
  = }
  -->
</listing>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */

    CanvasRenderingContext2D.prototype.drawTriangle =
        function (x, y, size, rotation) {
            /* ... */
        };
    
  = CanvasRenderingContext2D.prototype.drawCircle =
  =     function(x, y, radius) {
  =         this.beginPath();
  = 
  =         // ---
  =         // | Circle's center.
  =         // ----- v -v
  =         this.arc(x, y, radius, 0, 2.0 * Math.PI);
  =         // ------------------- ^ -^-----------^
  =         // | Range at which the circle starts and ends, in radians.
  =         // |
  =         // | By manipulating these two parameters you can e.g. draw
  =         // | only half of a circle, Pac-Man style.
  =         // ---
  = 
  =         this.fillStyle = 'rgb(0, 0, 0)';
  =         this.fill();
  =     };
    
    function redraw() {
        ctxt.clearRect(0, 0, viewportWidth, viewportHeight);
    
        simulation.step();
    
  =     const world = simulation.world();
    
  =     for (const food of world.foods) {
  =         ctxt.drawCircle(
  =             food.x * viewportWidth,
  =             food.y * viewportHeight,
  =             (0.01 / 2.0) * viewportWidth,
  =         );
  =     }
    
  =     for (const animal of world.animals) {
            /* ... */
        }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>
  Believe me or not, it's enough!
</p>

<listing-title>
  $ wasm-pack build
</listing-title>

<listing lang="text">
  <!--
    ....
    [INFO]: :-) Done in 1.25s
    [INFO]: :-) Your wasm pkg is ready to publish at /home/pwy/Projects/...
  -->
</listing>

<figure>
  <video src="{{ assets }}/87172540-2d9b-4f8d-a4ff-1e0a456bfffe.mp4" />
</figure>

<h3>
  Pimpin'-up
</h3>

<p>
  Our math checks out, but our simulation's appearance is...â€‹ daunting - let's try
  pimpin' it up:
</p>

<listing-title>
  www/index.html
</listing-title>

<listing lang="html">
  <!--
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="utf-8">
  =     <title>Shorelark</title>
      </head>
  =   <style>
  =     body {
  =       background: #1f2639; /* A nice navy blue color that I found by
  =                               a nice trial and error */
  =     }
  =   </style>
      <body>
        <canvas id="viewport" width="800" height="800"></canvas>
        <script src="./bootstrap.js"></script>
      </body>
    </html>
  -->
</listing>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
    CanvasRenderingContext2D.prototype.drawTriangle =
        function (x, y, size, rotation) {
            /* ... */
    
  =         this.fillStyle = 'rgb(255, 255, 255)'; // A nice white color
  =         this.fill();
        };
    
    CanvasRenderingContext2D.prototype.drawCircle =
        function(x, y, radius) {
            /* ... */
    
  =         this.fillStyle = 'rgb(0, 255, 128)'; // A nice green color
            this.fill();
        };
    
    /* ... */
  -->
</listing>

<p>
  There, better:
</p>

<figure>
  <video src="{{ assets }}/cac427f6-316d-4d90-80bd-609d1511e885.mp4" />
</figure>

<h3>
  Simulating food
</h3>

<p>
  At the moment, when our birdies collide with food, nothing happens - time to
  improve it!
</p>

<p>
  First, let's refactor <code>step()</code> a bit:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
        pub fn step(&mut self) {
  =         self.process_movements();
        }
    
  =     fn process_movements(&mut self) {
  =         for animal in &mut self.world.animals {
  =             animal.position += animal.rotation * na::Vector2::new(0.0, animal.speed);
  = 
  =             animal.position.x = na::wrap(animal.position.x, 0.0, 1.0);
  =             animal.position.y = na::wrap(animal.position.y, 0.0, 1.0);
  =         }
  =     }
    }
    
    /* ... */
  -->
</listing>

<p>
  Now:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
        pub fn step(&mut self) {
  =         self.process_collisions();
            self.process_movements();
        }
    
  =     fn process_collisions(&mut self) {
  =         todo!();
  =     }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>
  In plain English, what we want to achieve is:
</p>

<listing lang="rust">
  <!--
    /* ... */
    
    fn process_collisions(&mut self) {
        for each animal {
            for each food {
                if animal collides with food {
                    handle collision
                }
            }
        }
    }
    
    /* ... */
  -->
</listing>

<p>
  The process of checking whether two polygons collide is called
  <a href="https://en.wikipedia.org/wiki/Hit-testing">hit-testing</a> - so since
  our birds are triangles and our foods are circles, the thing we <i>should</i>
  be duckduckgoing for is "triangle circle hit test algorithm" (or "triangle
  circle collision" etc.).
</p>

<p>
  But - funny thing - this kind of hit-testing is
  <a href="http://www.phatcode.net/articles.php?id=459">unbearably complex</a>,
  so whaddya say we try something simpler, hang tight:
</p>

<p class="text-center">
  What if we assumed our birds are <b>circles</b>?
</p>

<p>
  You know, we can keep drawing them as triangles - it's only about the physics.
</p>

<p>
  Agreed? <i>(just kidding, I know you can't reply here.)</i>
</p>

<p>
  Ok, so circle-circle hit testing relies on checking whether the distance
  between two cirles is shorter or equal than the sum of their radii:
</p>

<figure class="sketch w-80">
  <img src="{{ assets }}/eaeec88c-f532-4976-8e1d-0b3b7660c136.svg" />

  <figcaption>
    distance(A, B) &gt; radius(A) + radius(B) â‡’ no collision
  </figcaption>
</figure>

<br />

<figure class="sketch w-80">
  <img src="{{ assets }}/b5eac4ea-8667-4590-91bb-0c77412d8cb1.svg" />

  <figcaption>
    distance(A, B) &lt;= radius(A) + radius(B) â‡’ collision
  </figcaption>
</figure>

<p>
  In practice, this reduces to a single <code>if</code>:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
  = pub fn step(&mut self, rng: &mut dyn RngCore) {
  =     self.process_collisions(rng);
        self.process_movements();
    }
    
  = fn process_collisions(&mut self, rng: &mut dyn RngCore) {
  =     for animal in &mut self.world.animals {
  =         for food in &mut self.world.foods {
  =             let distance = na::distance(&animal.position, &food.position);
  = 
  =             if distance <= 0.01 {
  =                 food.position = rng.gen();
  =             }
  =         }
  =     }
  = }
    
    /* ... */
  -->
</listing>

<listing-title>
  libs/simulation-wasm/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[wasm_bindgen]
    impl Simulation {
        /* ... */
    
        pub fn step(&mut self) {
  =         self.sim.step(&mut self.rng);
        }
    }
    
    /* ... */
  -->
</listing>

<p>
  The distance returned by nalgebra is in the same units as our positions - so a
  distance of, say, 0.5 means that our animal and food are half a map apart from
  each other, while 0.0 means that both are at the exact same coordinates.
</p>

<p>
  <code>0.01</code> determines the radius of our food - I've chosen
  <code>0.01</code> because it seems to play nice with the sizes we're using for
  drawing.
</p>

<p>
  Overall, does it work? Oh my!
</p>

<figure>
  <video src="{{ assets }}/64cb25d6-7c9f-43a8-b7ea-e022410a962a.mp4" />
</figure>

<h2 id="birdie-and-the-brain">
  Birdie and the Brain
</h2>

<p>
  Our birds can fly, but they can't interact with their environment yet - in
  this chapter we'll implement <b>eyes</b>, allowing for our birds to see the
  food, and <b>brains</b>, allowing for our birds to decide where they want to
  fly.
</p>

<h3>
  Refactoring
</h3>

<p>
  There's a lot of code inside <code>libs/simulation/src/lib.rs</code> - before
  we go further, let's take a moment to refactor it.
</p>

<p>
  A good rule of thumb is to keep a struct per file, so:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
  = mod animal;
  = mod food;
  = mod world;
  =
  = pub use self::{animal::*, food::*, world::*};
    use nalgebra as na;
    use rand::{Rng, RngCore};
    
    pub struct Simulation {
        /* ... */
    }
    
    impl Simulation {
        /* ... */
    }
  -->
</listing>

<listing-title>
  libs/simulation/src/animal.rs
</listing-title>

<listing lang="rust">
  <!--
  = use crate::*;
  = 
  = #[derive(Debug)]
  = pub struct Animal {
  =     /* ... */
  = }
  = 
  = impl Animal {
  =     /* ... */
  = }
  -->
</listing>

<listing-title>
  libs/simulation/src/food.rs
</listing-title>

<listing lang="rust">
  <!--
  = use crate::*;
  = 
  = #[derive(Debug)]
  = pub struct Food {
  =     /* ... */
  = }
  = 
  = impl Food {
  =     /* ... */
  = }
  -->
</listing>

<listing-title>
  libs/simulation/src/world.rs
</listing-title>

<listing lang="rust">
  <!--
  = use crate::*;
  = 
  = #[derive(Debug)]
  = pub struct World {
  =     /* ... */
  = }
  = 
  = impl World {
  =     /* ... */
  = }
  -->
</listing>

<p>
  ... and now:
</p>

<listing-title>
  $ cargo check
</listing-title>

<listing lang="text">
  <!--
    error[E0616]: field `animals` of struct `world::World` is private
      -\-> libs/simulation/src/lib.rs
       |
       |         for animal in &mut self.world.animals {
       |                                       ^^^^^^^ private field
    
    error[E0616]: field `foods` of struct `world::World` is private
      -\-> libs/simulation/src/lib.rs
       |
       |             for food in &mut self.world.foods {
       |                                         ^^^^^ private field
    
    /* ... */
  -->
</listing>

<p>
  Oh no, we've only shuffled some code around - what happened? Let's see the
  offending place:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
        fn process_collisions(&mut self, rng: &mut dyn RngCore) {
            for animal in &mut self.world.animals {
                //                       ^------^
    
                for food in &mut self.world.foods {
                    //                     ^----^
    
                    /* ... */
                }
            }
        }
    }
  -->
</listing>

<p>
  <ref>
    https://doc.rust-lang.org/reference/visibility-and-privacy.html
  </ref>

  Previously, when all four structs were in the same file, Rust's <a>visibility
  rules</a> allowed for all of them to access each other's private fields. Now
  that our structs are in separate files, they can't access non-pub fields
  anymore.
</p>

<p>
  There are two ways we could solve this issue:
</p>

<ol>
  <li>
    <p>
      We could provide <b>mutable getters</b>:
    </p>

    <listing lang="rust">
      <!--
        // libs/simulation/src/world.rs
        impl World {
            pub(crate) fn animals_mut(&mut self) -> &mut [Animal] {
                &mut self.animals
            }
        
            pub(crate) fn foods_mut(&mut self) -> &mut [Food] {
                &mut self.foods
            }
        }
        
        // libs/simulation/src/lib.rs
        impl Simulation {
            fn process_collisions(&mut self, rng: &mut dyn RngCore) {
                for animal in self.world.animals_mut() {
                    for food in self.world.foods_mut() {
                        /* ... */
                    }
                }
            }
        }
      -->
    </listing>
  </li>
  <li>
    <p>
      We could change <code>World</code>'s fields to be
      <b>crate-public</b> instead of private:
    </p>

    <listing lang="rust">
      <!--
        #[derive(Debug)]
        pub struct World {
            pub(crate) animals: Vec<Animal>,
            pub(crate) foods: Vec<Food>,
        }
      -->
    </listing>
  </li>
</ol>

<p>
  All fields (or functions, as seen in the first case) prepended with
  <code>pub(crate)</code> are visible to the entire code inside given crate - so
  <code>pub(crate) animals</code> means that all the code inside
  <code>lib-simulation</code> will be able to access <code>world.animals</code>,
  but it'll remain private for other crates.
</p>

<p>
  As for the difference between both snippets, it's pretty minor:
</p>

<ol>
  <li>
    <p>
      Some people advocate for mutable getters, because they make refactoring
      easier (e.g. you can rename the field from <code>animals</code> to
      <code>birds</code>, but keep <code>fn animals_mut()</code> to avoid
      introducing a breaking change),
    </p>
  </li>
  <li>
    <p>
      Some people advocate for crate-public fields, because they make the code
      shorter (there's no need to create additional functions).
    </p>
  </li>
</ol>

<p>
  For simplicity, we'll go with the second approach:
</p>

<listing-title>
  libs/simulation/src/animal.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct Animal {
  =     pub(crate) position: na::Point2<f32>,
  =     pub(crate) rotation: na::Rotation2<f32>,
  =     pub(crate) speed: f32,
    }
    
    /* ... */
  -->
</listing>

<listing-title>
  libs/simulation/src/food.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct Food {
  =     pub(crate) position: na::Point2<f32>,
    }
    
    /* ... */
  -->
</listing>

<listing-title>
  libs/simulation/src/world.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct World {
  =     pub(crate) animals: Vec<Animal>,
  =     pub(crate) foods: Vec<Food>,
    }
    
    /* ... */
  -->
</listing>

<listing-title>
  $ cargo check
</listing-title>

<listing lang="text">
  <!--
    Checking lib-simulation v0.1.0
        Checking lib-simulation-wasm v0.1.0
        Finished dev [unoptimized + debuginfo] target(s) in 0.57s
  -->
</listing>

<p>
  Nice ðŸ˜Ž - now we're ready to implement eyes!
</p>

<h3>
  Eye Of The Birdie
</h3>

<p>
  What's an eye?
</p>

<p>
  Well, a biologist might tell you that eye is an organ that provides vision; a
  philosopher's take might be that eye is a window to one's soul; and me? I
  think that an eye...â€‹
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    mod animal;
  = mod eye;
    mod food;
    mod world;

  = pub use self::{animal::*, eye::*, food::*, world::*};
  -->
</listing>

<p>
  ... is a struct!
</p>

<listing-title>
  libs/simulation/src/eye.rs
</listing-title>

<listing lang="rust">
  <!--
  = use crate::*;
  = 
  = #[derive(Debug)]
  = pub struct Eye;
  -->
</listing>

<p>
  Not just any struct, though - it's gotta have one function in particular:
</p>

<listing-title>
  libs/simulation/src/eye.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
  = impl Eye {
  =     pub fn process_vision() -> Vec<f32> {
  =         todo!()
  =     }
  = }
  -->
</listing>

<p>
  The result of this function is a vector of numbers, where each number - each
  eye cell - tells us how close the nearest food matching that eye cell is:
</p>

<figure class="sketch w-80">
  <img src="{{ assets }}/0adc49b4-c1cb-4012-9d63-25bbaed96de7.svg" />

  <figcaption>
    Example of an eye with three eye cells
  </figcaption>
</figure>

<p>
  Such an eye is defined by a few parameters:
</p>

<listing-title>
  libs/simulation/src/eye.rs
</listing-title>

<listing lang="rust">
  <!--
    use crate::*;
  = use std::f32::consts::*;
    
    /// How far our eye can see:
    ///
    /// -----------------
    /// |               |
    /// |               |
    /// |               |
    /// |@      %      %|
    /// |               |
    /// |               |
    /// |               |
    /// -----------------
    ///
    /// If @ marks our birdie and % marks food, then a FOV_RANGE of:
    ///
    /// - 0.1 = 10% of the map = bird sees no foods (at least in this case)
    /// - 0.5 = 50% of the map = bird sees one of the foods
    /// - 1.0 = 100% of the map = bird sees both foods
  = const FOV_RANGE: f32 = 0.25;
    
    /// How wide our eye can see.
    ///
    /// If @> marks our birdie (rotated to the right) and . marks the area
    /// our birdie sees, then a FOV_ANGLE of:
    ///
    /// - PI/2 = 90Â° =
    ///   -----------------
    ///   |             /.|
    ///   |           /...|
    ///   |         /.....|
    ///   |       @>......|
    ///   |         \.....|
    ///   |           \...|
    ///   |             \.|
    ///   -----------------
    ///
    /// - PI = 180Â° =
    ///   -----------------
    ///   |       |.......|
    ///   |       |.......|
    ///   |       |.......|
    ///   |       @>......|
    ///   |       |.......|
    ///   |       |.......|
    ///   |       |.......|
    ///   -----------------
    ///
    /// - 2 * PI = 360Â° =
    ///   -----------------
    ///   |...............|
    ///   |...............|
    ///   |...............|
    ///   |.......@>......|
    ///   |...............|
    ///   |...............|
    ///   |...............|
    ///   -----------------
    ///
    /// Field of view depends on both FOV_RANGE and FOV_ANGLE:
    ///
    /// - FOV_RANGE=0.4, FOV_ANGLE=PI/2:
    ///   -----------------
    ///   |       @       |
    ///   |     /.v.\     |
    ///   |   /.......\   |
    ///   |   ---------   |
    ///   |               |
    ///   |               |
    ///   |               |
    ///   -----------------
    ///
    /// - FOV_RANGE=0.5, FOV_ANGLE=2*PI:
    ///   -----------------
    ///   |               |
    ///   |      ---      |
    ///   |     /...\     |
    ///   |    |..@..|    |
    ///   |     \.../     |
    ///   |      ---      |
    ///   |               |
    ///   -----------------
  = const FOV_ANGLE: f32 = PI + FRAC_PI_4;
    
    /// How much photoreceptors there are in a single eye.
    ///
    /// More cells means our birds will have more "crisp" vision, allowing
    /// them to locate the food more precisely - but the trade-off is that
    /// the evolution process will then take longer, or even fail, unable
    /// to find any solution.
    ///
    /// I've found values between 3~11 sufficient, with eyes having more
    /// than ~20 photoreceptors yielding progressively worse results.
  = const CELLS: usize = 9;
    
    #[derive(Debug)]
  = pub struct Eye {
  =     fov_range: f32,
  =     fov_angle: f32,
  =     cells: usize,
  = }

    impl Eye {
  =     // FOV_RANGE, FOV_ANGLE & CELLS are the values we'll use during
  =     // simulation - but being able to create an arbitrary eye will
  =     // come handy during the testing:
  =     fn new(fov_range: f32, fov_angle: f32, cells: usize) -> Self {
  =         assert!(fov_range > 0.0);
  =         assert!(fov_angle > 0.0);
  =         assert!(cells > 0);
  = 
  =         Self { fov_range, fov_angle, cells }
  =     }
  = 
  =     pub fn cells(&self) -> usize {
  =         self.cells
  =     }
  = 
  =     pub fn process_vision(
  =         &self,
  =         position: na::Point2<f32>,
  =         rotation: na::Rotation2<f32>,
  =         foods: &[Food],
  =     ) -> Vec<f32> {
  =         todo!()
  =     }
    }
  = 
  = impl Default for Eye {
  =     fn default() -> Self {
  =         Self::new(FOV_RANGE, FOV_ANGLE, CELLS)
  =     }
  = }
  -->
</listing>

<p>
  The basic outline of our algorithm is:
</p>

<listing-title>
  libs/simulation/src/eye.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    pub fn process_vision(/* ... */) -> Vec<f32> {
  =     let mut cells = vec![0.0; self.cells];
  = 
  =     for food in foods {
  =         if food inside fov {
  =            cells[cell that sees this food] += how close the food is;
  =         }
  =     }
  = 
  =     cells
    }
    
    /* ... */
  -->
</listing>

<p>
  How can we check if some food is inside our field of view? Two conditions must
  be fulfilled:
</p>

<ol>
  <li>
    <p>
      The distance between us and the food must be no greater than
      <code>FOV_RANGE</code>:
    </p>

    <listing-title>
      libs/simulation/src/eye.rs
    </listing-title>

    <listing lang="rust">
      <!--
        /* ... */
        
        for food in foods {
      =     let vec = food.position - position;
        
            // ^ Represents a *vector* from food to us
            //
            // In case this is the first time you hear the word `vector`, a
            // quick definition would be:
            //
            // > A vector is an object that has *magnitude* (aka length)
            // > and *direction*.
            //
            // You could say a vector is an arrow:
            //
            //   --\-> this is a vector of magnitude=3 (if we count each
            //        dash as a single "unit of space") and direction=0Â°
            //        (at least relative to the X axis)
            //
            //    |   this is a vector of magnitude=1 and direction=90Â°
            //    v   (at least when we treat direction clockwise)
            //
            // Our food-to-birdie vectors are no different:
            //
            // ---------
            // |       |  gets us this vector:
            // |@     %|          <-----
            // |       |  (magnitude=5, direction=180Â°)
            // ---------
            //
            // ---------  gets us this vector:
            // |   %   |           |
            // |       |           |
            // |   @   |           v
            // ---------  (magnitude=2, direction=90Â°)
            //
            // This is not to be confused with Rust's `Vec` or C++'s
            // `std::vector`, which technically *are* vectors, but in a more
            // abstract sense -- better not to overthink it.
            //
            // (https://stackoverflow.com/questions/581426/why-is-a-c-vector-called-a-vector).
            //
            // ---
            // | Fancy way of saying "length of the vector".
            // ----------- v----v
      =     let dist = vec.norm();
      = 
      =     if dist >= self.fov_range {
      =         continue;
      =     }
        }
        
        /* ... */
      -->
    </listing>
  </li>
  <li>
    <p>
      The angle between us and the food must be no greater than
      <code>FOV_ANGLE</code> - and since our birdie's vision is symmetrical
      (they see the same amount "on the left" and "on the right", just like
      humans do), this means that our angle must be
      <code>&lt;-FOV_ANGLE/2, +FOV_ANGLE/2&gt;</code>:
    </p>

    <listing-title>
      libs/simulation/src/eye.rs
    </listing-title>

    <listing lang="rust">
      <!--
        /* ... */
        
        for food in foods {
            /* ... */
        
            // Returns vector's direction relative to the Y axis, that is:
            //
            //    ^
            //    |  = 0Â° = 0
            //
            //   -\-> = 90Â° = -PI / 2
            //
            //    |  = 180Â° = -PI
            //    v
            //
            // (if you've been measuring rotations before - this is atan2
            // in disguise.)
      =     let angle = na::Rotation2::rotation_between(
      =         &na::Vector2::y(),
      =         &vec,
      =     ).angle();
        
            // Because our bird is *also* rotated, we have to include its
            // rotation too:
      =     let angle = angle - rotation.angle();
        
            // Rotation is wrapping (from -PI to PI), that is:
            //
            //   = angle of 2*PI
            //   = angle of PI    (because 2*PI >= PI)
            //   = angle of 0     (          PI >= PI)
            //                    (           0 < PI)
            //
            //  angle of 2*PI + PI/2
            //  = angle of 1*PI + PI/2  (because 2*PI + PI/2 >= PI)
            //  = angle of PI/2         (          PI + PI/2 >= PI)
            //                          (               PI/2 < PI)
            //
            //  angle of -2.5*PI
            //  = angle of -1.5*PI  (because -2.5*PI <= -PI)
            //  = angle of -0.5*PI  (        -1.5*PI <= -PI)
            //                      (        -0.5*PI > -PI)
            //
            // Intuitively:
            //
            // - when you rotate yourself twice around the axis, it's the
            //   same as if you rotated once, as if you've never rotated
            //   at all.
            //
            //   (your bony labyrinth might have a different opinion tho.)
            //
            // - when you rotate by 90Â° and then by 360Â°, it's the same
            //   as if you rotated only by 90Â° (*or* by 270Â°, just in the
            //   opposite direction).
      =     let angle = na::wrap(angle, -PI, PI);
        
            // If current angle is outside our birdie's field of view, jump
            // to the next food
      =     if angle < -self.fov_angle / 2.0 || angle > self.fov_angle / 2.0 {
      =         continue;
      =     }
        }
        
        /* ... */
      -->
    </listing>
  </li>
</ol>

<p>
  Ok, we've rejected all the foods outside our birdie's field of view - for the
  eye to work, we need one more thing:
</p>

<listing lang="rust">
  <!--
    cells[cell that sees this food] += how close the food is;
  -->
</listing>

<p>
  Determining which concrete cell sees the food is a bit tricky, but it distills
  to looking at the angle between the food and our eye - e.g. for an eye with
  three cells and fov of 120Â°:
</p>

<figure class="sketch">
  <img src="{{ assets }}/17d07e2f-952f-4c16-a71a-aace25683c5e.svg" />
</figure>

<p>
  In the poetic language of code:
</p>

<listing-title>
  libs/simulation/src/eye.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    for food in foods {
        /* ... */
    
        // Makes angle *relative* to our birdie's field of view - that is:
        // transforms it from <-FOV_ANGLE/2,+FOV_ANGLE/2> to <0,FOV_ANGLE>.
        //
        // After this operation:
        // - an angle of 0Â° means "the beginning of the FOV",
        // - an angle of self.fov_angle means "the ending of the FOV".
  =     let angle = angle + self.fov_angle / 2.0;
    
        // Since this angle is now in range <0,FOV_ANGLE>, by dividing it by
        // FOV_ANGLE, we transform it to range <0,1>.
        //
        // The value we get can be treated as a percentage, that is:
        //
        // - 0.2 = the food is seen by the "20%-th" eye cell
        //         (practically: it's a bit to the left)
        //
        // - 0.5 = the food is seen by the "50%-th" eye cell
        //         (practically: it's in front of our birdie)
        //
        // - 0.8 = the food is seen by the "80%-th" eye cell
        //         (practically: it's a bit to the right)
  =     let cell = angle / self.fov_angle;
    
        // With cell in range <0,1>, by multiplying it by the number of
        // cells we get range <0,CELLS> - this corresponds to the actual
        // cell index inside our `cells` array.
        //
        // Say, we've got 8 eye cells:
        // - 0.2 * 8 = 20% * 8 = 1.6 ~= 1 = second cell (indexing from 0!)
        // - 0.5 * 8 = 50% * 8 = 4.0 ~= 4 = fifth cell
        // - 0.8 * 8 = 80% * 8 = 6.4 ~= 6 = seventh cell
  =     let cell = cell * (self.cells as f32);
    
        // Our `cell` is of type `f32` - before we're able to use it to
        // index an array, we have to convert it to `usize`.
        //
        // We're also doing `.min()` to cover an extreme edge case: for
        // cell=1.0 (which corresponds to a food being maximally to the
        // right side of our birdie), we'd get `cell` of `cells.len()`,
        // which is one element *beyond* what the `cells` array contains
        // (its range is <0, cells.len()-1>).
        //
        // Being honest, I've only caught this thanks to unit tests we'll
        // write in a moment, so if you consider my explanation
        // insufficient (pretty fair!), please feel free to drop the
        // `.min()` part later and see which tests fail - and why!
  =     let cell = (cell as usize).min(cells.len() - 1);
    }
    
    /* ... */
  -->
</listing>

<p>
  Now that we know the cell index, our final touch in here is:
</p>

<listing-title>
  libs/simulation/src/eye.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    for food in foods {
        /* ... */
    
        // Energy is inversely proportional to the distance between our
        // birdie and the currently checked food; that is - an energy of:
        //
        // - 0.0001 = food is barely in the field of view (i.e. far away),
        // - 1.0000 = food is right in front of the bird.
        //
        // We could also model energy in reverse manner - "the higher the
        // energy, the further away the food" - but from what I've seen, it
        // makes the learning process a bit harder.
        //
        // As always, feel free to experiment! -- overall this isn't the
        // only way of implementing eyes.
  =     let energy = (self.fov_range - dist) / self.fov_range;
  =
  =     cells[cell] += energy;
    }
    
    /* ... */
  -->
</listing>

<p>
  That's a lot of math! - how do we know it works? Of course, by testing it ðŸ˜Š
</p>

<h3>
  Nothing But Tests
</h3>

<p>
  The first obstacle is that our vision requires lot of parameters to compute:
</p>

<ul>
  <li>
    <p>
      FOV range (one <code>f32</code>),
    </p>
  </li>
  <li>
    <p>
      FOV angle (one <code>f32</code>),
    </p>
  </li>
  <li>
    <p>
      number of cells (one <code>usize</code>),
    </p>
  </li>
  <li>
    <p>
      position (two <code>f32</code>s),
    </p>
  </li>
  <li>
    <p>
      rotation (one <code>f32</code>).
    </p>
  </li>
</ul>

<p>
  Even ignoring the number of cells - which we can hard-code without losing
  much - this gets us <b>5</b> different tunables that affect each other, plus
  we've also got to specify locations of our foods; moon on a stick, checking
  all of the combinations, I tell ya'!
</p>

<p>
  The second obstacle is that our <code>Eye::process_vision()</code> returns
  <code>Vec&lt;f32&gt;</code>, so it's one of those functions that take some dry
  numbers and return some dry numbers; not only it's a bit boring, but also
  resilient to solid testing:
</p>

<p class="text-center">
  is <code>vec![0.0, 0.1, 0.7]</code> really the response we want for
  <code>x=0.2, y=0.5</code>? who knows!
</p>

<p>
  So, as for the first obstacle, my idea is to use a thing called
  <b>parameterized tests</b> - with a pinch of salt, parameterized tests are
  when you create a testing function:
</p>

<listing lang="rust">
  <!--
    #[test]
    fn some_test() {
        /* ... */
    }
  -->
</listing>

<p>
  ... and make it accept one or many parameters:
</p>

<listing lang="rust">
  <!--
    // This is just an example in pseudo-Rust
    
    #[test(x=10, y=20, z=30)]
    #[test(x=50, y=50, z=50)]
    #[test(x=0, y=0, z=0)]
    fn some_test(x: f32, y: f32, z: usize) {
        /* ... */
    }
  -->
</listing>

<p>
  This testing methodology allows to cover the input space more thoroughly than
  you'd do with copy-pasted <code>mod { ...â€‹ }</code>, simply because adding more
  edge cases is just so easy.
</p>

<p>
  Rust doesn't support parameterized tests natively - at least not in the manner
  that I've shown above - but there exist a few crates providing this
  functionality; we're going to use
  <a href="https://crates.io/crates/test-case">test-case</a>:
</p>

<listing-title>
  libs/simulation/Cargo.toml
</listing-title>

<listing lang="toml">
  <!--
    # ...
    
  = [dev-dependencies]
  = test-case = "3.3.1"
  -->
</listing>

<p>
  ... which has a pretty straightforward syntax:
</p>

<listing-title>
  libs/simulation/src/eye.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
  = #[cfg(test)]
  = mod tests {
  =     use super::*;
  =     use test_case::test_case;
  = 
  =     #[test_case(1.0)]
  =     #[test_case(0.5)]
  =     #[test_case(0.1)]
  =     fn fov_ranges(fov_range: f32) {
  =         todo!()
  =     }
  = }
  -->
</listing>

<p>
  This solves the first obstacle, at least for all the practical purposes; while
  we still won't be able to cover all the cases (remember how many numbers
  <code>f32</code> can encode?), the more test-cases we include, the more
  confident we can be that our code works as intended.
</p>

<p>
  As for the second hindrance: instead of comparing blunt vectors of number,
  whaddya say we compare <b>graphical representations</b> of what the bird sees?
</p>

<p>
  Stay with me: even if <code>process_vision()</code> returns something like
  <code>vec![0.0, 0.5, 0.0]</code>, it doesn't mean we're forced to compare
  that in our tests! If instead of a vector, what we compared was, hmm,
  <code>" * "</code>, it'd be waay easier to ensure our eye works correctly.
</p>

<p>
  So, baby steps:
</p>

<listing-title>
  libs/simulation/src/eye.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[cfg(test)]
    mod tests {
        use super::*;
        use test_case::test_case;
    
        fn test(
            foods: Vec<Food>,
            fov_range: f32,
            fov_angle: f32,
            x: f32,
            y: f32,
            rot: f32,
            expected_vision: &str,
        ) {
            todo!()
        }

        #[test_case(1.0)]
        #[test_case(0.5)]
        #[test_case(0.1)]
        fn fov_ranges(fov_range: f32) {
            super::test(
                todo!(),
                fov_range,
                todo!(),
                todo!(),
                todo!(),
                todo!(),
                todo!(),
             );
        }
    }
  -->
</listing>

<p>
  Hmmm, <b>no</b> - that's waaay too many parameters for a single function; how
  about a struct?
</p>

<listing-title>
  libs/simulation/src/eye.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[cfg(test)]
    mod tests {
        use super::*;
        use test_case::test_case;
    
  =     struct TestCase {
  =         foods: Vec<Food>,
  =         fov_range: f32,
  =         fov_angle: f32,
  =         x: f32,
  =         y: f32,
  =         rot: f32,
  =         expected_vision: &'static str,
  =     }
  = 
  =     impl TestCase {
  =         fn run(self) {
  =             todo!()
  =         }
  =     }

        #[test_case(1.0)]
        #[test_case(0.5)]
        #[test_case(0.1)]
        fn fov_ranges(fov_range: f32) {
  =         TestCase {
  =             foods: todo!(),
  =             fov_angle: todo!(),
  =             x: todo!(),
  =             y: todo!(),
  =             rot: todo!(),
  =             expected_vision: todo!(),
  =             fov_range,
  =         }.run()
        }
    }
  -->
</listing>

<p>
  Nice and readable; nice and readable.
</p>

<p>
  Our test's result, <code>expected_vision</code>, depends on
  <code>fov_range</code>, so it's a parameter, too:
</p>

<listing-title>
  libs/simulation/src/eye.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
  = #[test_case(1.0, "not sure yet")]
  = #[test_case(0.5, "not sure yet")]
  = #[test_case(0.1, "not sure yet")]
  = fn fov_ranges(fov_range: f32, expected_vision: &'static str) {
        TestCase {
            foods: todo!(),
            fov_angle: todo!(),
            x: todo!(),
            y: todo!(),
            rot: todo!(),
            fov_range,
  =         expected_vision,
        }.run()
    }
    
    /* ... */
  -->
</listing>

<p>
  About that <code>TestCase</code> - from a birds-eye view, what we're looking
  for is:
</p>

<listing lang="rust">
  <!--
    /* ... */
    
    impl TestCase {
        fn run(self) {
            let eye = Eye::new(/* ... */);
    
            let actual_vision = eye.process_vision(/* ... */);
            let actual_vision = make_human_readable(actual_vision);
    
            assert_eq!(actual_vision, self.expected_vision);
        }
    }
    
    /* ... */
  -->
</listing>

<p>
  Since our <code>TestCase</code> already knows all the parameters needed, we
  can start implementing it:
</p>

<listing-title>
  libs/simulation/src/eye.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    /// All our tests will use eyes hard-coded to thirteen eye cells.
    ///
    /// As for the "why":
    ///
    /// While we certainly *could* implement tests for different number of
    /// eye cells, after a while I've decided it's just not worth the
    /// hassle - as you'll see in a moment, we'll already get a good coverage
    /// via the other parameters, so creating a separate set of tests for
    /// different values of eye cells seemed like a waste of time.
    ///
    /// As for the "why this number in particular":
    ///
    /// I've checked a few numbers by hand and generally found 13 to yield
    /// pretty good results. As always, nothing special about 13 in
    /// particular, your (eye) mileage may vary.
  = const TEST_EYE_CELLS: usize = 13;
    
    impl TestCase {
        fn run(self) {
  =         let eye = Eye::new(self.fov_range, self.fov_angle,TEST_EYE_CELLS);
  =
  =         let actual_vision = eye.process_vision(
  =             na::Point2::new(self.x, self.y),
  =             na::Rotation2::new(self.rot),
  =             &self.foods,
  =         );
        }
    }
    
    /* ... */
  -->
</listing>

<p>
  Currently our <code>actual_vision</code> is <code>Vec&lt;f32&gt;</code> - we
  can convert it into a string via a chip of <code>.into_iter()</code>,
  <code>.map()</code> and <code>.join()</code> magic:
</p>

<listing-title>
  libs/simulation/src/eye.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    impl TestCase {
        fn run(self) {
            /* ... */
    
  =         let actual_vision: Vec<_> = actual_vision
  =             .into_iter()
  =             .map(|cell| {
  =                 // As a reminder, the higher cell's value, the closer
  =                 // the food is:
  = 
  =                 if cell >= 0.7 {
  =                     // <0.7, 1.0>
  =                     // food is right in front of us
  =                     "#"
  =                 } else if cell >= 0.3 {
  =                     // <0.3, 0.7)
  =                     // food is somewhat further
  =                     "+"
  =                 } else if cell > 0.0 {
  =                     // <0.0, 0.3)
  =                     // food is pretty far away
  =                     "."
  =                 } else {
  =                     // 0.0
  =                     // no food in sight, this cell sees empty space
  =                     " "
  =                 }
  =             })
  =             .collect();
    
            // As before, there's nothing special about the cell values
            // (`0.7`, `0.3`, `0.0`) or the characters (`#`, `+`, `.`).
            //
            // I've chosen hash because to my eye it seems to occupy the
            // most "visual space" out of all the ASCII characters (thus
            // it represents a food being close), and then plus and dot
            // are just smaller (representing food being further away).
    
            // `.join()` converts `Vec<String>` into `String` using a
            // separator - e.g. `vec!["a", "b", "c"].join("|")` would
            // return `a|b|c`.
  =         let actual_vision = actual_vision.join("");
  =
  =         assert_eq!(actual_vision, self.expected_vision);
        }
    }
    
    /* ... */
  -->
</listing>

<p>
  Just like that, our testing framework is complete! ðŸ¥³
</p>

<p>
  Now, as for the tests - allow me to present you pure beauty:
</p>

<listing-title>
  libs/simulation/src/eye.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
  = fn food(x: f32, y: f32) -> Food {
  =     Food {
  =         position: na::Point2::new(x, y),
  =     }
  = }

    /// During tests in this module, we're using a world that looks
    /// like this:
    ///
    /// -------------
    /// |           |
    /// |           |
    /// |     @     |
    /// |     v     | `v` here indicates where the birdie is looking at
    /// |           |
    /// |     %     |
    /// -------------
    ///
    /// Each test gradually reduces our birdie's field of view and
    /// checks what the birdie sees:
    ///
    /// -------------
    /// |           |
    /// |           |
    /// |     @     |
    /// |    /v\    |
    /// |  /.....\  | `.` here indicates the part of view the birdie sees
    /// |/....%....\|
    /// -------------
    ///
    /// -------------
    /// |           |
    /// |           |
    /// |     @     |
    /// |    /v\    |
    /// |  /.....\  |
    /// |     %     |
    /// -------------
    ///
    /// -------------
    /// |           |
    /// |           |
    /// |     @     |
    /// |    /.\    |
    /// |           |
    /// |     %     |
    /// -------------
    ///
    /// Over time, what we see is the food gradually disappearing
    /// into the emptiness:
    ///
    /// (well, technically the food and bird remain stationary - it's
    /// only the birdie's own field of view that gets reduced.)
  = #[test_case(1.0, "      +      ")] // Food is inside the FOV
  = #[test_case(0.9, "      +      ")] // ditto
  = #[test_case(0.8, "      +      ")] // ditto
  = #[test_case(0.7, "      .      ")] // Food slowly disappears
  = #[test_case(0.6, "      .      ")] // ditto
  = #[test_case(0.5, "             ")] // Food disappeared!
  = #[test_case(0.4, "             ")]
  = #[test_case(0.3, "             ")]
  = #[test_case(0.2, "             ")]
  = #[test_case(0.1, "             ")]
    fn fov_ranges(fov_range: f32, expected_vision: &'static str) {
        TestCase {
  =         foods: vec![food(0.5, 1.0)],
  =         fov_angle: FRAC_PI_2,
  =         x: 0.5,
  =         y: 0.5,
  =         rot: 0.0,
            fov_range,
            expected_vision,
        }.run()
    }
    
    /* ... */
  -->
</listing>

<p>
  Breath in, breath out:
</p>

<listing-title>
  $ cargo test -p lib-simulation
</listing-title>

<listing lang="text">
  <!--
    running 10 tests
    test eye::tests::fov_ranges::_0_4_ ... ok
    test eye::tests::fov_ranges::_0_2_ ... ok
    test eye::tests::fov_ranges::_0_5_ ... ok
    test eye::tests::fov_ranges::_0_1_ ... ok
    test eye::tests::fov_ranges::_0_3_ ... ok
    test eye::tests::fov_ranges::_0_8_ ... ok
    test eye::tests::fov_ranges::_0_9_ ... ok
    test eye::tests::fov_ranges::_1_0_ ... ok
    test eye::tests::fov_ranges::_0_7_ ... ok
    test eye::tests::fov_ranges::_0_6_ ... ok
    
    test result: ok. 10 passed; 0 failed
  -->
</listing>

<p>
  Ha, ha! - it works! And it's readable! (and, with luck, even maintainable!)
</p>

<note>
  <p>
    The code you see has the correct values for <code>expected_vision</code>
    already filled, but in reality I didn't know them up-front - behind the
    scenes, what I've done was:
  </p>

  <listing lang="rust">
    <!--
      #[test_case(1.0, "")]
      /* ... */
    -->
  </listing>

  <p>
    ... and then I've run <code>$ cargo test</code> and copy-pasted the actual
    result from the error message, analyzing whether it made sense or not (e.g.
    getting <code>#</code> for <code>fov_range</code> of <code>0.1</code> could
    indicate a bug, as a birdie with such a small <code>fov_range</code>
    shouldn't be able to see that food).
  </p>

  <p>
    Since all of this <code>$ cargo test</code> and copy-pasting is a rather
    mundane task, to avoid boring you, the code I'll provide in a moment will
    already contain all of the <code>expected_vision</code> pre-filled so that
    all of the tests pass; just keep in mind than in reality you'd have to start
    with e.g. empty assertion and see what comes out of it.
  </p>
</note>

<p>
  That's one parameter - four more to go! What about rotation?
</p>

<listing-title>
  libs/simulation/src/eye.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */

    /// World:
    ///
    /// -------------
    /// |           |
    /// |           |
    /// |%    @     |
    /// |     v     |
    /// |           |
    /// -------------
    ///
    /// Test cases:
    ///
    /// -------------
    /// |...........|
    /// |...........|
    /// |%....@.....|
    /// |.....v.....|
    /// |...........|
    /// -------------
    ///
    /// -------------
    /// |...........|
    /// |...........|
    /// |%...<@.....|
    /// |...........|
    /// |...........|
    /// -------------
    ///
    /// -------------
    /// |...........|
    /// |.....^.....|
    /// |%....@.....|
    /// |...........|
    /// |...........|
    /// -------------
    ///
    /// -------------
    /// |...........|
    /// |...........|
    /// |%....@>....|
    /// |...........|
    /// |...........|
    /// -------------
    ///
    /// ... and so on, until we do a full circle, 360Â° rotation:
  = #[test_case(0.00 * PI, "         +   ")] // Food is to our right
  = #[test_case(0.25 * PI, "        +    ")]
  = #[test_case(0.50 * PI, "      +      ")] // Food is in front of us
  = #[test_case(0.75 * PI, "    +        ")]
  = #[test_case(1.00 * PI, "   +         ")] // Food is to our left
  = #[test_case(1.25 * PI, " +           ")]
  = #[test_case(1.50 * PI, "            +")] // Food is behind us
  = #[test_case(1.75 * PI, "           + ")] // (we continue to see it
  = #[test_case(2.00 * PI, "         +   ")] // due to 360Â° fov_angle.)
  = #[test_case(2.25 * PI, "        +    ")]
  = #[test_case(2.50 * PI, "      +      ")]
  = fn rotations(rot: f32, expected_vision: &'static str) {
  =     TestCase {
  =         foods: vec![food(0.0, 0.5)],
  =         fov_range: 1.0,
  =         fov_angle: 2.0 * PI,
  =         x: 0.5,
  =         y: 0.5,
  =         rot,
  =         expected_vision,
  =     }.run()
  = }
    
    /* ... */
  -->
</listing>

<p>
  Testing positions is even more fun:
</p>

<listing-title>
  libs/simulation/src/eye.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */

    /// World:
    ///
    /// ------------
    /// |          |
    /// |         %|
    /// |          |
    /// |         %|
    /// |          |
    /// ------------
    ///
    /// Test cases for the X axis:
    ///
    /// ------------
    /// |          |
    /// |        /%|
    /// |       @>.|
    /// |        \%|
    /// |          |
    /// ------------
    ///
    /// ------------
    /// |        /.|
    /// |      /..%|
    /// |     @>...|
    /// |      \..%|
    /// |        \.|
    /// ------------
    ///
    /// ... and so on, going further left
    ///     (or, from the bird's point of view - going _back_)
    ///
    /// Test cases for the Y axis:
    ///
    /// ------------
    /// |     @>...|
    /// |       \.%|
    /// |        \.|
    /// |         %|
    /// |          |
    /// ------------
    ///
    /// ------------
    /// |      /...|
    /// |     @>..%|
    /// |      \...|
    /// |        \%|
    /// |          |
    /// ------------
    ///
    /// ... and so on, going further down
    ///     (or, from the bird's point of view - going _right_)
    
  = // Checking the X axis:
  = // (you can see the bird is "flying away" from the foods)
  = #[test_case(0.9, 0.5, "#           #")]
  = #[test_case(0.8, 0.5, "  #       #  ")]
  = #[test_case(0.7, 0.5, "   +     +   ")]
  = #[test_case(0.6, 0.5, "    +   +    ")]
  = #[test_case(0.5, 0.5, "    +   +    ")]
  = #[test_case(0.4, 0.5, "     + +     ")]
  = #[test_case(0.3, 0.5, "     . .     ")]
  = #[test_case(0.2, 0.5, "     . .     ")]
  = #[test_case(0.1, 0.5, "     . .     ")]
  = #[test_case(0.0, 0.5, "             ")]
  = //
  = // Checking the Y axis:
  = // (you can see the bird is "flying alongside" the foods)
  = #[test_case(0.5, 0.0, "            +")]
  = #[test_case(0.5, 0.1, "          + .")]
  = #[test_case(0.5, 0.2, "         +  +")]
  = #[test_case(0.5, 0.3, "        + +  ")]
  = #[test_case(0.5, 0.4, "      +  +   ")]
  = #[test_case(0.5, 0.6, "   +  +      ")]
  = #[test_case(0.5, 0.7, "  + +        ")]
  = #[test_case(0.5, 0.8, "+  +         ")]
  = #[test_case(0.5, 0.9, ". +          ")]
  = #[test_case(0.5, 1.0, "+            ")]
  = fn positions(x: f32, y: f32, expected_vision: &'static str) {
  =     TestCase {
  =         foods: vec![food(1.0, 0.4), food(1.0, 0.6)],
  =         fov_range: 1.0,
  =         fov_angle: FRAC_PI_2,
  =         rot: 3.0 * FRAC_PI_2,
  =         x,
  =         y,
  =         expected_vision,
  =     }.run()
  = }

    /* ... */
  -->
</listing>

<p>
  We've got only one more parameter left to cover: field of view's angle.
</p>

<p>
  We'll use the same framework, but imagining what happens in here is tiny bit
  more complicated (or at least it took me a minute to ensure the behavior is
  correct):
</p>

<listing-title>
  libs/simulation/src/eye.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    /// World:
    ///
    /// ------------
    /// |%        %|
    /// |          |
    /// |%        %|
    /// |    @>    |
    /// |%        %|
    /// |          |
    /// |%        %|
    /// ------------
    ///
    /// Test cases:
    ///
    /// ------------
    /// |%        %|
    /// |         /|
    /// |%      /.%|
    /// |    @>....|
    /// |%      \.%|
    /// |         \|
    /// |%        %|
    /// ------------
    ///
    /// ------------
    /// |%      /.%|
    /// |      /...|
    /// |%    /...%|
    /// |    @>....|
    /// |%    \...%|
    /// |      \...|
    /// |%      \.%|
    /// ------------
    ///
    /// ------------
    /// |%........%|
    /// |\.........|
    /// |% \......%|
    /// |    @>....|
    /// |% /......%|
    /// |/.........|
    /// |%........%|
    /// ------------
    ///
    /// ... and so on, until we reach the full, 360Â° FOV
  = #[test_case(0.25 * PI, " +         + ")] // FOV is narrow = 2 foods
  = #[test_case(0.50 * PI, ".  +     +  .")]
  = #[test_case(0.75 * PI, "  . +   + .  ")] // FOV gets progressively
  = #[test_case(1.00 * PI, "   . + + .   ")] // wider and wider...
  = #[test_case(1.25 * PI, "   . + + .   ")]
  = #[test_case(1.50 * PI, ".   .+ +.   .")]
  = #[test_case(1.75 * PI, ".   .+ +.   .")]
  = #[test_case(2.00 * PI, "+.  .+ +.  .+")] // FOV is the widest = 8 foods
  = fn fov_angles(fov_angle: f32, expected_vision: &'static str) {
  =     TestCase {
  =         foods: vec![
  =             food(0.0, 0.0),
  =             food(0.0, 0.33),
  =             food(0.0, 0.66),
  =             food(0.0, 1.0),
  =             food(1.0, 0.0),
  =             food(1.0, 0.33),
  =             food(1.0, 0.66),
  =             food(1.0, 1.0),
  =         ],
  =         fov_range: 1.0,
  =         x: 0.5,
  =         y: 0.5,
  =         rot: 3.0 * FRAC_PI_2,
  =         fov_angle,
  =         expected_vision,
  =     }.run()
  = }

    /* ... */
  -->
</listing>

<p>
  Nice:
</p>

<listing-title>
  cargo test -p lib-simulation
</listing-title>

<listing lang="text">
  <!--
    test result: ok. 49 passed; 0 failed
  -->
</listing>

<p>
  So - we've got eyez, but what about brainz? Fortunately, we've already
  implemented it!
</p>

<listing-title>
  libs/simulation/Cargo.toml
</listing-title>

<listing lang="toml">
  <!--
    # ...
    
    [dependencies]
    # ...
    
  = lib-neural-network = { path = "../neural-network" }
    
    # ...
  -->
</listing>

<listing-title>
  libs/simuation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
  = use lib_neural_network as nn;
    use nalgebra as na;
    use rand::{Rng, RngCore};
    
    /* ... */
  -->
</listing>

<listing-title>
  libs/simulation/src/animal.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct Animal {
        /* ... */
  =     pub(crate) eye: Eye,
  =     pub(crate) brain: nn::Network,
    }
    
    impl Animal {
        pub fn random(rng: &mut dyn RngCore) -> Self {
            /* ... */

  =         let eye = Eye::default();
  = 
  =         let brain = nn::Network::random(
  =             rng,
  =             &[
                    // The Input Layer
                    //
                    // Because our eye returns Vec<f32>, and our neural
                    // network works on Vec<f32>, we can pass-through
                    // numbers from eye into the neural network directly.
                    //
                    // Had our birdies had, I dunno, ears, we could do
                    // something like: `eye.cells() + ear.nerves()` etc.
  =                 nn::LayerTopology {
  =                     neurons: eye.cells(),
  =                 },
    
                    // The Hidden Layer
                    //
                    // There is no best answer as to "how many neurons
                    // the hidden layer should contain" (or how many
                    // hidden layers there should be, even - there could
                    // be zero, one, two or more!).
                    //
                    // The rule of thumb is to start with a single hidden
                    // layer that has somewhat more neurons that the input
                    // layer and see how well the network performs.
  =                 nn::LayerTopology {
  =                     neurons: 2 * eye.cells(),
  =                 },
    
                    // The Output Layer
                    //
                    // Since the brain will control our bird's speed and
                    // rotation, this gives us two numbers = two neurons.
  =                 nn::LayerTopology { neurons: 2 },
  =             ],
  =         );
    
            Self {
                /* ... */
  =             eye,
  =             brain,
            }
        }
    
        /* ... */
    }
  -->
</listing>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    // FRAC_PI_2 = PI / 2.0; a convenient shortcut
  = use std::f32::consts::FRAC_PI_2;
    
    /// Minimum speed of a bird.
    ///
    /// Keeping it above zero prevents birds from getting stuck in one place.
  = const SPEED_MIN: f32 = 0.001;
    
    /// Maximum speed of a bird.
    ///
    /// Keeping it "sane" prevents birds from accelerating up to infinity,
    /// which makes the simulation... unrealistic :-)
  = const SPEED_MAX: f32 = 0.005;
    
    /// Speed acceleration; determines how much the brain can affect bird's
    /// speed during one step.
    ///
    /// Assuming our bird is currently flying with speed=0.5, when the brain
    /// yells "stop flying!", a SPEED_ACCEL of:
    ///
    /// - 0.1 = makes it take 5 steps ("5 seconds") for the bird to actually
    ///         slow down to SPEED_MIN,
    ///
    /// - 0.5 = makes it take 1 step for the bird to slow down to SPEED_MIN.
    ///
    /// This improves simulation faithfulness, because - as in real life -
    /// it's not possible to increase speed from 1km/h to 50km/h in one
    /// instant, even if your brain very much wants to.
  = const SPEED_ACCEL: f32 = 0.2;
    
    /// Ditto, but for rotation:
    ///
    /// - 2 * PI = it takes one step for the bird to do a 360Â° rotation,
    /// - PI = it takes two steps for the bird to do a 360Â° rotation,
    ///
    /// I've chosen PI/2, because - as our motto goes - this value seems
    /// to play nice.
  = const ROTATION_ACCEL: f32 = FRAC_PI_2;
    
    impl Simulation {
        /* ... */
    
        pub fn step(&mut self, rng: &mut dyn RngCore) {
            self.process_collisions(rng);
  =         self.process_brains();
            self.process_movements();
        }
    
        /* ... */
    
  =     fn process_brains(&mut self) {
  =         for animal in &mut self.world.animals {
  =             let vision = animal.eye.process_vision(
  =                 animal.position,
  =                 animal.rotation,
  =                 &self.world.foods,
  =             );
  = 
  =             let response = animal.brain.propagate(vision);
    
                // ---
                // | Limits number to given range.
                // -------------------- v---v
  =             let speed = response[0].clamp(-SPEED_ACCEL, SPEED_ACCEL);
  =             let rotation = response[1].clamp(-ROTATION_ACCEL, ROTATION_ACCEL);
    
                // Our speed & rotation here are *relative* - that is: when
                // they are equal to zero, what the brain says is "keep
                // flying as you are now", not "stop flying".
                //
                // Both values being relative is crucial, because our bird's
                // brain doesn't know its own speed and rotation*, meaning
                // that it fundamentally cannot return absolute values.
                //
                // * they'd have to be provided as separate inputs to the
                //   neural network, which would make the evolution process
                //   waaay longer, if even possible.
    
  =             animal.speed = (animal.speed + speed).clamp(SPEED_MIN, SPEED_MAX);
  =             animal.rotation = na::Rotation2::new(animal.rotation.angle() + rotation);
    
                // (btw, there is no need for ROTATION_MIN or ROTATION_MAX,
                // because rotation automatically wraps from 2*PI back to 0 -
                // we've already witnessed that when we were testing eyes,
                // inside `fn rotations { ... }`.)
  =         }
  =     }
    
        /* ... */
    }
  -->
</listing>

<p>
  Does it work? Let's find out!
</p>

<listing-title>
  $ wasm-pack build
</listing-title>

<listing lang="text">
  <!--
    ...
    [INFO]: :-) Done in 12.20s
    [INFO]: :-) Your wasm pkg is ready to publish at /home/pwy/Projects/...
  -->
</listing>

<p>
  Oh my, oh my, oh my!
</p>

<figure>
  <video src="{{ assets }}/d8d74b38-d9be-48a2-94b4-f1f917a1a63d.mp4" />
</figure>

<blockquote>
  <p>
    Birds were flying from continent to continent long before we were. They
    reached the coldest place on Earth, Antarctica, long before we did. They can
    survive in the hottest of deserts. Some can remain on the wing for years at
    a time. They can girdle the globe.
  </p>

  <p class="attribution">
    - David Attenborough about our simulation (hypothesized)
  </p>
</blockquote>

<p>
  What we see is enchanting: each bird, equipped with a randomized brain,
  <i>decides</i> where it wants to fly, trying to adjust its behavior to its
  surroundings.
</p>

<p>
  Some of our birds fly in circles, some exhibit more complex behaviors - and,
  if you're lucky (try refreshing the page a few times!), what you'll see is a
  bird actually steering into the food, as if it understood.
</p>

<p>
  Currently this is pure luck though; our next, and the last, milestone will be
  about <i>teaching</i> - we'll augment our simulation with the final piece of
  puzzle: the genetic algorithm.
</p>

<h2 id="huggin-n-evolvin">
  Huggin' & Evolvin'
</h2>

<p>
  Even though our birds can fly, their brains remain entirely random - in this
  chapter we'll see how we can integrate our simulation with the genetic
  algorithm, so that our birdies can learn & evolve.
</p>

<p>
  Broadly speaking, we want to <b>maximize</b> the amount of food eaten -
  that'll be our fitness function; and the way we'll achieve that is that we'll
  run the simulation for some time (called a <b>generation</b>), note down how
  many foods have been eaten by each bird and then, uhm, <i>reproduce</i> the
  best birdies.
</p>

<p>
  Let's get to it!
</p>

<listing-title>
  libs/simulation/Cargo.toml
</listing-title>

<listing lang="toml">
  <!--
    # ...
    
    [dependencies]
    # ...
    
  = lib-genetic-algorithm = { path = "../genetic-algorithm" }
    lib-neural-network = { path = "../neural-network" }
    
    # ...
  -->
</listing>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
  = use lib_genetic_algorithm as ga;
    use lib_neural_network as nn;
    /* ... */
  -->
</listing>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    /// How much `.step()`-s have to occur before we push data into the
    /// genetic algorithm.
    ///
    /// Value that's too low might prevent the birds from learning, while
    /// a value that's too high will make the evolution unnecessarily
    /// slower.
    ///
    /// You can treat this number as "for how many steps each bird gets
    /// to live"; 2500 was chosen with a fair dice roll.
  = const GENERATION_LENGTH: usize = 2500;
    
    pub struct Simulation {
        world: World,
  =     ga: ga::GeneticAlgorithm<ga::RouletteWheelSelection>,
  =     age: usize,
    }
    
    impl Simulation {
        pub fn random(rng: &mut dyn RngCore) -> Self {
  =         let world = World::random(rng);
  = 
  =         let ga = ga::GeneticAlgorithm::new(
  =             ga::RouletteWheelSelection,
  =             ga::UniformCrossover,
  =             ga::GaussianMutation::new(0.01, 0.3),
  =             // ---------------------- ^--^ -^-^
  =             // | Chosen with a bit of experimentation.
  =             // |
  =             // | Higher values can make the simulation more chaotic,
  =             // | which - a bit counterintuitively - might allow for
  =             // | it to discover *better* solutions; but the trade-off
  =             // | is that higher values might also cause current, good
  =             // | enough solutions to be discarded.
  =             // ---
  =         );
  = 
  =         Self { world, ga, age: 0 }
        }
    
        /* ... */
    
        pub fn step(&mut self, rng: &mut dyn RngCore) {
            self.process_collisions(rng);
            self.process_brains();
            self.process_movements();
    
  =         self.age += 1;
  = 
  =         if self.age > GENERATION_LENGTH {
  =             self.evolve(rng);
  =         }
        }
    
        /* ... */
    
  =     fn evolve(&mut self, rng: &mut dyn RngCore) {
  =         self.age = 0;
  = 
  =         // Step 1: Prepare birdies to be sent into the genetic algorithm
  =         let current_population = todo!();
  = 
  =         // Step 2: Evolve birdies
  =         let evolved_population = self.ga.evolve(rng, &current_population);
  = 
  =         // Step 3: Bring birdies back from the genetic algorithm
  =         self.world.animals = todo!();
  = 
  =         // Step 4: Restart foods
  =         //
  =         // (this is not strictly necessary, but it allows to easily spot
  =         // when the evolution happens - so it's more of a UI thing.)
  =         for food in &mut self.world.foods {
  =             food.position = rng.gen();
  =         }
  =     }
    }
  -->
</listing>

<p>
  As you might remember, our <code>GenenticAlgorithm::evolve()</code> requires
  for the "evolvable" type to implement a trait called <code>Individual</code>:
</p>

<listing-title>
  libs/genetic-algorithm/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    impl<S> GeneticAlgorithm<S>
    where
        S: SelectionMethod,
    {
        /* ... */

        pub fn evolve<I>(&self, rng: &mut dyn RngCore, population: &[I]) -> Vec<I>
        where
            I: Individual,
        {
            /* ... */
        }
    }
  -->
</listing>

<p>
  ... so a naÃ¯ve approach could be to simply implement <code>Individual</code>
  for <code>Animal</code> - after all, birdies <i>are</i> the thing we want to
  evolve:
</p>

<listing-title>
  libs/simulation/src/animal.rs
</listing-title>

<listing lang="rust" class="listing-invalid">
  <!--
    /* ... */
    
    impl ga::Individual for Animal {
        fn create(chromosome: ga::Chromosome) -> Self {
            todo!()
        }
    
        fn chromosome(&self) -> &ga::Chromosome {
            todo!()
        }
    
        fn fitness(&self) -> f32 {
            todo!()
        }
    }
  -->
</listing>

<p>
  But as soon as we try to actually implement those, we get backed into a corner
  - for instance: how can we implement <code>fn chromosome()</code> that returns
  a reference to <code>ga::Chromosome</code> if our <code>Animal</code> doesn't
  contain a field called <code>chromosome</code>?
</p>

<listing-title>
  libs/simulation/src/animal.rs
</listing-title>

<listing lang="rust" class="listing-invalid">
  <!--
    impl ga::Individual for Animal {
        /* ... */
    
        fn chromosome(&self) -> &ga::Chromosome {
           &self.what // :'-(
        }
    
        /* ... */
    }
  -->
</listing>

<p>
  Granted, you could say that since we control the code inside
  <code>lib-genetic-algorithm</code>, we could just change
  <code>fn chromosome()</code> to work on owned <code>Chromosome</code>s
  instead - and you'd be right, partially! This doesn't actually solve the
  underlying design issue, merely pushes it somewhere else:
</p>

<listing-title>
  libs/simulation/src/animal.rs
</listing-title>

<listing lang="rust" class="listing-invalid">
  <!--
    /* ... */
    
    impl ga::Individual for Animal {
        fn create(chromosome: ga::Chromosome) -> Self {
            Self {
                position: rng.gen(), // err: we don't have access to PRNG
                                     // in here!
                /* ... */
            }
        }
    
        /* ... */
    }
  -->
</listing>

<p>
  So, for the sake of argument, let's assume that our
  <code>ga::Individual</code> is designed correctly - how can we integrate
  <code>Animal</code> with it, then?
</p>

<p>
  Most easily - by creating a dedicated struct:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    mod animal;
  = mod animal_individual;
    /* ... */
    
  = use self::animal_individual::*;
    use lib_genetic_algorithm as ga;
    use lib_neural_network as nn;
    /* ... */
  -->
</listing>

<listing-title>
  libs/simulation/src/animal_individual.rs
</listing-title>

<listing lang="rust">
  <!--
  = use crate::*;
  = 
  = pub struct AnimalIndividual;
  = 
  = impl ga::Individual for AnimalIndividual {
  =     fn create(chromosome: ga::Chromosome) -> Self {
  =         todo!()
  =     }
  = 
  =     fn chromosome(&self) -> &ga::Chromosome {
  =         todo!()
  =     }
  = 
  =     fn fitness(&self) -> f32 {
  =         todo!()
  =     }
  = }
  -->
</listing>

<p>
  As we see, this structure has to contain at least those two fields:
</p>

<listing-title>
  libs/simulation/src/animal_individual.rs
</listing-title>

<listing lang="rust">
  <!--
    use crate::*;
    
  = pub struct AnimalIndividual {
  =     fitness: f32,
  =     chromosome: ga::Chromosome,
  = }
    
    impl ga::Individual for AnimalIndividual {
        fn create(chromosome: ga::Chromosome) -> Self {
  =         Self {
  =             fitness: 0.0,
  =             chromosome,
  =         }
        }
    
        fn chromosome(&self) -> &ga::Chromosome {
  =         &self.chromosome
        }
    
        fn fitness(&self) -> f32 {
  =         self.fitness
        }
    }
  -->
</listing>

<p>
  Let's go back to <code>fn evolve()</code> and see how it fits there:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    fn evolve(&mut self, rng: &mut dyn RngCore) {
        self.age = 0;
    
        // Transforms `Vec<Animal>` to `Vec<AnimalIndividual>`
  =     let current_population: Vec<_> = self
  =         .world
  =         .animals
  =         .iter()
  =         .map(|animal| convert Animal to AnimalIndividual)
  =         .collect();
    
        // Evolves this `Vec<AnimalIndividual>`
        let evolved_population = self.ga.evolve(
            rng,
            &current_population,
        );
    
        // Transforms `Vec<AnimalIndividual>` back into `Vec<Animal>`
  =     self.world.animals = evolved_population
  =         .into_iter()
  =         .map(|individual| convert AnimalIndividual to Animal)
  =         .collect();
    
        for food in &mut self.world.foods {
            food.position = rng.gen();
        }
    }
    
    /* ... */
  -->
</listing>

<p>
  Seems like this might just work!
</p>

<p>
  To implement those <code>.map()</code>s, we'll need two conversion methods:
</p>

<listing-title>
  libs/simulation/src/animal_individual.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
  = impl AnimalIndividual {
  =     pub fn from_animal(animal: &Animal) -> Self {
  =         todo!()
  =     }
  = 
  =     pub fn into_animal(self, rng: &mut dyn RngCore) -> Animal {
  =         todo!()
  =     }
  = }
    
    /* ... */
  -->
</listing>

<p>
  ... which allow us to:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    fn evolve(&mut self, rng: &mut dyn RngCore) {
        /* ... */
    
        let current_population: Vec<_> = self
            .world
            .animals
            .iter()
  =         .map(AnimalIndividual::from_animal)
            .collect();
    
        /* ... */
    
        self.world.animals = evolved_population
            .into_iter()
  =         .map(|individual| individual.into_animal(rng))
            .collect();
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>
  Ok, so: how can we implement those two conversion methods?
</p>

<h3>
  from_animal
</h3>

<p>
  Let's bring into the picture the important bits:
</p>

<listing-title>
  libs/simulation/src/animal_individual.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    pub struct AnimalIndividual {
        fitness: f32,
        chromosome: ga::Chromosome,
    }
    
    impl AnimalIndividual {
        pub fn from_animal(animal: &Animal) -> Self {
  =         Self {
  =             fitness: todo!(),
  =             chromosome: todo!(),
  =         }
        }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>
  What are we supposed to do inside <code>::from_animal()</code>? Well, looks
  like two things:
</p>

<ol>
  <li>
    <p>
      determine animal's <b>fitness score</b>,
    </p>
  </li>
  <li>
    <p>
      determine animal's <b>chromosome</b> (aka genotype).
    </p>
  </li>
</ol>

<p>
  Finding out fitness score is pretty easy - since we already handle collisions,
  all we've gotta do is to count them:
</p>

<listing-title>
  libs/simulation/src/animal.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct Animal {
        /* ... */
    
        /// Number of foods eaten by this animal
  =     pub(crate) satiation: usize,
    }
    
    impl Animal {
        pub fn random(rng: &mut dyn RngCore) -> Self {
            /* ... */
    
            Self {
                /* ... */
  =             satiation: 0,
            }
        }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
        fn process_collisions(&mut self, rng: &mut dyn RngCore) {
            for animal in &mut self.world.animals {
                for food in &mut self.world.foods {
                    /* ... */
    
                    if distance <= 0.01 {
  =                     animal.satiation += 1;
                        food.position = rng.gen();
                    }
                }
            }
        }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<listing-title>
  libs/simulation/src/animal_individual.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    impl AnimalIndividual {
        pub fn from_animal(animal: &Animal) -> Self {
            Self {
  =             fitness: animal.satiation as f32,
                chromosome: todo!(),
            }
        }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>
  Ah, I love when all the pieces just fit together.
</p>

<p>
  When it comes to the second field, <code>chromosome</code>, there'll be a bit
  more work there. As a reminder, what we mean by chromosome here is weights of
  the neural network - so ideally we'd write:
</p>

<listing-title>
  libs/simulation/src/animal_individual.rs
</listing-title>

<listing lang="rust" class="listing-invalid">
  <!--
    /* ... */
    
    impl AnimalIndividual {
        pub fn from_animal(animal: &Animal) -> Self {
            Self {
                /* ... */
  =             chromosome: animal.brain.weights(),
            }
        }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>
  ... but our <code>lib-neural-network</code>'s <code>Network</code> doesn't
  have such method...â€‹ yet!
</p>

<p>
  To implement <code>.weights()</code>, let's go back to
  <code>lib-neural-network</code> - what we're looking for is:
</p>

<listing-title>
  libs/neural-network/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Network {
        /* ... */
    
  =     pub fn weights(&self) -> Vec<f32> {
  =         todo!()
  =     }
    }
    
    /* ... */
  -->
</listing>

<p>
  For fun, let's start with a test:
</p>

<listing-title>
  libs/neural-network/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[cfg(test)]
    mod tests {
        /* ... */
    
  =    #[test]
  =    fn weights() {
  =        let network = Network {
  =            layers: vec![
  =                Layer {
  =                    neurons: vec![Neuron {
  =                        bias: 0.1,
  =                        weights: vec![0.2, 0.3, 0.4],
  =                    }],
  =                },
  =                Layer {
  =                    neurons: vec![Neuron {
  =                        bias: 0.5,
  =                        weights: vec![0.6, 0.7, 0.8],
  =                    }],
  =                },
  =            ],
  =        };
  =
  =        let actual = network.weights();
  =        let expected = vec![0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8];
  =
  =        assert_relative_eq!(actual.as_slice(), expected.as_slice());
  =    }
    }
  -->
</listing>

<p>
  As for the implementation, I'll show you three - one uses <code>for</code>
  loops, while the other two work on combinators:
</p>

<ol>
  <li>
    <p>
      Loops:
    </p>

    <listing-title>
      libs/neural-network/src/lib.rs
    </listing-title>

    <listing lang="rust">
      <!--
        impl Network {
            /* ... */

      =     pub fn weights(&self) -> Vec<f32> {
      =         let mut weights = Vec::new();
      =
      =         for layer in &self.layers {
      =             for neuron in &layer.neurons {
      =                 weights.push(neuron.bias);
      =
      =                 for weight in &neuron.weights {
      =                     weights.push(*weight);
      =                 }
      =             }
      =         }
      =
      =         weights
      =     }
        }
      -->
    </listing>
  </li>

  <li>
    <p>
      Combinators:
    </p>

    <listing-title>
      libs/neural-network/src/lib.rs
    </listing-title>

    <listing lang="rust">
      <!--
      = use std::iter::once;

        /* ... */

        impl Network {
            /* ... */

      =     pub fn weights(&self) -> Vec<f32> {
      =         self.layers
      =             .iter()
      =             .flat_map(|layer| layer.neurons.iter())
      =             .flat_map(|neuron| once(&neuron.bias).chain(&neuron.weights))
      =             .copied()
      =             .collect()
      =     }
        }
      -->
    </listing>
  </li>

  <li>
    <p>
      Combinators + iterator:
    </p>

    <listing-title>
      libs/neural-network/src/lib.rs
    </listing-title>

    <listing lang="rust">
      <!--
      = use std::iter::once;

        /* ... */

        impl Network {
            /* ... */

      =     pub fn weights(&self) -> impl Iterator<Item = f32> + '_ {
      =         self.layers
      =             .iter()
      =             .flat_map(|layer| layer.neurons.iter())
      =             .flat_map(|neuron| once(&neuron.bias).chain(&neuron.weights))
      =             .copied()
      =     }
        }

        /* ... */

        #[cfg(test)]
        mod tests {
            /* ... */

            #[test]
            fn weights() {
                /* ... */

      =         let actual: Vec<_> = network.weights().collect();

                /* ... */
            }
        }
      -->
    </listing>
  </li>
</ol>

<p>
  I consider the last approach better, because it allows you to avoid allocating
  the vector, but when push comes to shove, maintenability is usually more
  important than performance, so choose whichever version you prefer yourself.
</p>

<p>
  Also, while we're here, let's implement the inverse -
  <code>::from_weights()</code>:
</p>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Network {
        /* ... */
    
  =     pub fn from_weights(
  =         layers: &[LayerTopology],
  =         weights: impl IntoIterator<Item = f32>,
  =     ) -> Self {
  =         todo!()
  =     }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>
  Ideally, we'd like for the following identity to hold:
</p>

<listing lang="rust">
  <!--
    network == Network::from_weights(network.weights())
  -->
</listing>

<p>
  ... so let's base our tests exactly on that:
</p>

<listing lang="rust">
  <!--
    /* ... */
    
    #[cfg(test)]
    mod tests {
        /* ... */
    
  =     #[test]
  =     fn from_weights() {
  =         let layers = &[
  =             LayerTopology { neurons: 3 },
  =             LayerTopology { neurons: 2 },
  =         ];
  =
  =         let weights = vec![0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8];
  =         let network = Network::from_weights(layers, weights.clone());
  =         let actual: Vec<_> = network.weights().collect();
  =
  =         assert_relative_eq!(actual.as_slice(), weights.as_slice());
  =     }

        /* ... */
    }
  -->
</listing>

<p>
  ... and then an example implementation could be:
</p>

<listing-title>
  libs/neural-network/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Network {
        /* ... */
    
  =     pub fn from_weights(
  =         layers: &[LayerTopology],
  =         weights: impl IntoIterator<Item = f32>,
  =     ) -> Self {
  =         assert!(layers.len() > 1);
  = 
  =         let mut weights = weights.into_iter();
  = 
  =         let layers = layers
  =             .windows(2)
  =             .map(|layers| {
  =                 Layer::from_weights(
  =                     layers[0].neurons,
  =                     layers[1].neurons,
  =                     &mut weights,
  =                 )
  =             })
  =             .collect();
  = 
  =         if weights.next().is_some() {
  =             panic!("got too many weights");
  =         }
  = 
  =         Self { layers }
  =     }
    
        /* ... */
    }
    
    impl Layer {
        /* ... */
    
  =     fn from_weights(
  =         input_size: usize,
  =         output_size: usize,
  =         weights: &mut dyn Iterator<Item = f32>,
  =     ) -> Self {
  =         let neurons = (0..output_size)
  =             .map(|_| Neuron::from_weights(input_size, weights))
  =             .collect();
  = 
  =         Self { neurons }
  =     }
    
        /* ... */
    }
    
    impl Neuron {
        /* ... */
    
  =     fn from_weights(
  =         input_size: usize,
  =         weights: &mut dyn Iterator<Item = f32>,
  =     ) -> Self {
  =         let bias = weights.next().expect("got not enough weights");
  = 
  =         let weights = (0..input_size)
  =             .map(|_| weights.next().expect("got not enough weights"))
  =             .collect();
  = 
  =         Self { bias, weights }
  =     }
    
        /* ... */
    }
  -->
</listing>

<p>
  Recreating network from weights is quite complex, so don't worry if this code
  takes a moment to sink-in - took a while to write, too!
</p>

<h3>
  Refactoring
</h3>

<p>
  Our <code>Network</code> has now everything we need to make it compatible with
  genetic algorithm - but before we do that, let's take a moment to refactor one
  thing.
</p>

<p>
  Inside our <code>Animal</code>, what we have now is:
</p>

<listing-title>
  libs/simulation/src/animal.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct Animal {
        /* ... */
        pub(crate) brain: nn::Network,
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>
  ... and what I have on mind is to refactor <code>brain: nn::Network</code>
  into a distinct, em, body part:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
  = pub use self::{animal::*, brain::*, eye::*, food::*, world::*};
    
    mod animal;
    mod animal_individual;
  = mod brain;
    /* ... */
  -->
</listing>

<listing-title>
  libs/simulation/src/brain.rs
</listing-title>

<listing lang="rust">
  <!--
  = use crate::*;
  = 
  = #[derive(Debug)]
  = pub struct Brain {
  =     pub(crate) nn: nn::Network,
  = }
  = 
  = impl Brain {
  =     pub fn random(rng: &mut dyn RngCore, eye: &Eye) -> Self {
  =         Self {
  =             nn: nn::Network::random(rng, &Self::topology(eye)),
  =         }
  =     }
  = 
  =     pub(crate) fn as_chromosome(&self) -> ga::Chromosome {
  =         self.nn.weights().collect()
  =     }
  = 
  =     fn topology(eye: &Eye) -> [nn::LayerTopology; 3] {
  =         [
  =             nn::LayerTopology {
  =                 neurons: eye.cells(),
  =             },
  =             nn::LayerTopology {
  =                 neurons: 2 * eye.cells(),
  =             },
  =             nn::LayerTopology { neurons: 2 },
  =         ]
  =     }
  = }
  -->
</listing>

<listing-title>
  libs/simulation/src/animal.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct Animal {
        /* ... */
  =     pub(crate) brain: Brain,
        /* ... */
    }
    
    impl Animal {
  =     pub fn random(rng: &mut dyn RngCore) -> Self {
  =         let eye = Eye::default();
  =         let brain = Brain::random(rng, &eye);
  = 
  =         Self::new(eye, brain, rng)
  =     }
    
  =     pub(crate) fn as_chromosome(&self) -> ga::Chromosome {
  =         // We evolve only our birds' brains, but technically there's no
  =         // reason not to simulate e.g. physical properties such as size.
  =         //
  =         // If that was to happen, this function could be adjusted to
  =         // return a longer chromosome that encodes not only the brain,
  =         // but also, say, birdie's color.
  = 
  =         self.brain.as_chromosome()
  =     }
    
        /* ... */
    
  =     fn new(eye: Eye, brain: Brain, rng: &mut dyn RngCore) -> Self {
  =         Self {
  =             position: rng.gen(),
  =             rotation: rng.gen(),
  =             speed: 0.002,
  =             eye,
  =             brain,
  =             satiation: 0,
  =         }
  =     }
    }
  -->
</listing>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    fn process_brains(&mut self) {
        for animal in &mut self.world.animals {
            /* ... */
    
  =         let response = animal.brain.nn.propagate(vision);
    
            /* ... */
        }
    }
  -->
</listing>

<p>
  All this allows us to complete <code>AnimalIndividual::from_animal()</code>:
</p>

<listing-title>
  libs/simulation/src/animal_individual.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    impl AnimalIndividual {
        pub fn from_animal(animal: &Animal) -> Self {
            Self {
                fitness: animal.satiation as f32,
  =             chromosome: animal.as_chromosome(),
            }
        }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>
  Once again, all the pieces fit together ðŸ¥³
</p>

<h3>
  into_animal
</h3>

<p>
  With our latest changes we can transform <code>Animal</code> into
  <code>AnimalIndividual</code> and send it into the genetic algorithm - now
  it's time to implement the reverse operation: given a brand-new
  <code>AnimalIndividual</code> fresh from the genetic algorithm, we have to
  convert it into <code>Animal</code>:
</p>

<listing-title>
  libs/simulation/src/animal_individual.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    impl AnimalIndividual {
        /* ... */
    
        pub fn into_animal(self, rng: &mut dyn RngCore) -> Animal {
  =         Animal::from_chromosome(self.chromosome, rng)
        }
    }
    
    /* ... */
  -->
</listing>

<listing-title>
  libs/simulation/src/animal.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Animal {
        /* ... */
    
        /// "Restores" bird from a chromosome.
        ///
        /// We have to have access to the PRNG in here, because our
        /// chromosomes encode only the brains - and while we restore the
        /// bird, we have to also randomize its position, direction, etc.
        /// (so it's stuff that wouldn't make sense to keep in the genome.)
  =     pub(crate) fn from_chromosome(
  =         chromosome: ga::Chromosome,
  =         rng: &mut dyn RngCore,
  =     ) -> Self {
  =         let eye = Eye::default();
  =         let brain = Brain::from_chromosome(chromosome, &eye);
  = 
  =         Self::new(eye, brain, rng)
  =     }
    
        pub(crate) fn as_chromosome(&self) -> ga::Chromosome {
            self.brain.as_chromosome()
        }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<listing-title>
  libs/simulation/src/brain.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Brain {
        /* ... */
    
  =     pub(crate) fn from_chromosome(
  =         chromosome: ga::Chromosome,
  =         eye: &Eye,
  =     ) -> Self {
  =         Self {
  =             nn: nn::Network::from_weights(
  =                 &Self::topology(eye),
  =                 chromosome,
  =             ),
  =         }
  =     }
    
        pub(crate) fn as_chromosome(&self) -> ga::Chromosome {
            self.nn.weights().collect()
        }
    
        /* ... */
    }
  -->
</listing>

<p>
  Looks like...â€‹ we're done! Are we done??
</p>

<h2 id="ready-set">
  Ready, Set...â€‹
</h2>

<p>
  We're kinda-sorta done - while you could just launch
  <code>wasm-pack build</code>, take your binoculars and start to watch the
  wildlife mingle, there are two things we can do to make this experience less
  frustrating:
</p>

<ol>
  <li>
    <p>
      First of all: since evolution happens once every 2500 steps and we perform
      60 steps per second (there's one step per one frame, and the browser tries
      to keep steady 60 FPSÂ¹), then in real-time we're talking about <b>one
      evolution per ~40 seconds</b>.
    </p>

    <p>
      Â¹ or 120 FPS, or 144 FPS etc., depending on your display
    </p>

    <p>
      <ref>
        https://xkcd.com/1205/
      </ref>

      If we wanted to witness birdies getting smarter and smarter, we'd have to
      wait around 10 generations (speaking from experience), so roughly 6.5
      minutes. <b>6.5 minutes</b> of bluntly staring into the screen - <a>what a
      waste of time</a>!
    </p>

    <p>
      But if we had some kind of a "fast-forward" button...â€‹
    </p>
  </li>
  <li>
    <p>
      Second of all: even if evolution works (with big emphasis on <i>if</i>,
      'cause - you know - we're skeptics!), at the moment we'd have no way of
      knowing.
    </p>

    <p>
      I mean, do our current birds <b>really</b> fly better than those from ten
      minutes ago?
    </p>

    <p>
      Luckily to us, because we're <span class="text-rainbow">digital</span>,
      finding evidence for evolution gets pretty easy: we'll just enhance
      <code>lib-genetic-algorithm</code> so that it returns statistics - such as
      the average fitness score - and we'll use <code>console.log()</code> to
      see if those statistics grow.
    </p>
  </li>
</ol>

<p>
  &lt;slowly-breaths-out /&gt;
</p>

<p>
  Our journey heads towards its end - the code that we'll write in a moment will
  be the culminating point of all the hard work we've done. So, my friend - are
  you ready to knock on wood and begin our final birdie-adventure?
</p>

<h3>
  Fast-Forward & Statistics
</h3>

<p>
  Inside our JavaScript code we invoke <code>.step()</code> only during
  <code>redraw()</code> - that's what makes our simulation "stuck" to 60 FPS:
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
    function redraw() {
        /* ... */
    
        simulation.step();
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>
  To make our simulation faster, we could either invoke
  <code>.step()</code> many times at once:
</p>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
    function redraw() {
        /* ... */
    
        // Performs 10 steps per frame, which makes simulation 10x faster
        // (at least if your computer can catch up!)
        for (let i = 0; i < 10; i += 1) {
            simulation.step();
        }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>
  ... or, a bit better, we could provide a dedicated method that "fast-forwards"
  an entire generation - this way we could keep the simulation running at 1x
  speed and only bind this "fast-forwarding" to a button; make it fast-forward
  on-demand.
</p>

<p>
  To use a shorter noun, instead of calling it <code>fn fast_forward()</code>,
  let's go with <code>fn train()</code>:
</p>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
  =     pub fn step(&mut self, rng: &mut dyn RngCore) -> bool {
            /* ... */
    
            self.age += 1;
    
            if self.age > GENERATION_LENGTH {
                self.evolve(rng);
  =             true
  =         } else {
  =             false
  =         }
        }
    
        /// Fast-forwards 'till the end of the current generation.
  =     pub fn train(&mut self, rng: &mut dyn RngCore) {
  =         loop {
  =             if self.step(rng) {
  =                 return;
  =             }
  =         }
  =     }
    
        /* ... */
    }
  -->
</listing>

<listing-title>
  libs/simulation-wasm/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[wasm_bindgen]
    impl Simulation {
        /* ... */
    
  =     pub fn train(&mut self) {
  =         self.sim.train(&mut self.rng);
  =     }
    }
    
    /* ... */
  -->
</listing>

<listing-title>
  www/index.html
</listing-title>

<listing lang="html">
  <!--
    <!-- ... -\->
    <style>
      /* ... */
    
  =   #train {
  =       position: absolute;
  =       top: 0;
  =       margin: 15px;
  =   }
    </style>
    <body>
      <canvas id="viewport" width="800" height="800"></canvas>
  =   <button id="train">train please, thank u</button>
      <script src="./bootstrap.js"></script>
    </body>
    <!-- ... -\->
  -->
</listing>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    import * as sim from "lib-simulation-wasm";
    
    let simulation = new sim.Simulation();
    
  = document.getElementById('train').onclick = function() {
  =     simulation.train();
  = };
    
    const viewport = document.getElementById('viewport');
    const viewportScale = window.devicePixelRatio || 1;
    
    /* ... */
  -->
</listing>

<note>
  <blockquote>
    <p>
      But wait - doesn't this code require some kind of <code>RwLock</code> or
      <code>Mutex</code>?
    </p>

    <p>
      I mean, what happens when user clicks
      <code>train please, thank u</code> during the time <code>.step()</code> is
      working - won't this cause our Rust code to be invoked twice at the same
      time, destroying the entire universe and everything we love?
    </p>
  </blockquote>

  <p>
    Fear not: JavaScript is single threaded - when browser executes our
    <code>.step()</code> (or rather <code>redraw()</code>), it "hangs" the tab.
  </p>

  <p>
    <ref>
      https://stackoverflow.com/questions/2734025/is-javascript-guaranteed-to-be-single-threaded/2734311#2734311
    </ref>

    <a>Simplifying a bit</a>, you could say that only one line of JavaScript
    code is running at a time - it's not possible to execute both
    <code>.step()</code> and <code>.train()</code> at once (which would also
    violate the <code>&mut self</code> requirement on the Rust's side); if user
    clicks <code>train</code> when <code>.step()</code> is working, the browser
    will schedule the click event to be executed in the next frame.
  </p>
</note>

<p>
  Ok, now that we can speed-up the evolution, let's get our hands dirty with
  statistics - the simplest thing we have at hand are fitness scores, so
  <code>lib-genetic-algorithm</code> seems like a nice place to implement them:
</p>

<listing-title>
  libs/genetic-algorithm/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */

    impl<S> GeneticAlgorithm<S>
    where
        S: SelectionMethod,
    {
        /* ... */
    
  =     pub fn evolve<I>(/* ... */) -> (Vec<I>, Statistics)
        where
            I: Individual,
        {
            assert!(!population.is_empty());
    
  =         let new_population = (0..population.len())
                .map(|_| {
                    /* ... */
                })
  =             .collect();
    
  =         let stats = Statistics::new(population);
  = 
  =         (new_population, stats)
        }
    }
    
    /* ... */

  = #[derive(Clone, Debug)]
  = pub struct Statistics {
  =     pub min_fitness: f32,
  =     pub max_fitness: f32,
  =     pub avg_fitness: f32,
  = }
  =
  = impl Statistics {
  =     fn new<I>(population: &[I]) -> Self
  =     where
  =         I: Individual,
  =     {
  =         assert!(!population.is_empty());
  = 
  =         let mut min_fitness = population[0].fitness();
  =         let mut max_fitness = min_fitness;
  =         let mut sum_fitness = 0.0;
  = 
  =         for individual in population {
  =             let fitness = individual.fitness();
  = 
  =             min_fitness = min_fitness.min(fitness);
  =             max_fitness = max_fitness.max(fitness);
  =             sum_fitness += fitness;
  =         }
  = 
  =         Self {
  =             min_fitness,
  =             max_fitness,
  =             avg_fitness: sum_fitness / (population.len() as f32),
  =         }
  =     }
  = }
  -->
</listing>

<listing-title>
  libs/simulation/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
  =     pub fn step(&mut self, rng: &mut dyn RngCore) -> Option<ga::Statistics> {
            /* ... */
    
            if self.age > GENERATION_LENGTH {
  =             Some(self.evolve(rng))
            } else {
  =             None
            }
        }
    
  =     pub fn train(&mut self, rng: &mut dyn RngCore) -> ga::Statistics {
            loop {
  =             if let Some(summary) = self.step(rng) {
  =                 return summary;
                }
            }
        }
    
        /* ... */
    
  =     fn evolve(&mut self, rng: &mut dyn RngCore) -> ga::Statistics {
            /* ... */
    
  =         let (evolved_population, stats) = self.ga.evolve(rng, &current_population);

            /* ... */
    
  =         stats
        }
    }
  -->
</listing>

<listing-title>
  libs/simulation-wasm/src/lib.rs
</listing-title>

<listing lang="rust">
  <!--
    /* ... */
    
    #[wasm_bindgen]
    impl Simulation {
        /* ... */
    
        /// min = minimum amount of food eaten by any bird
        ///
        /// max = maximum amount of food eaten by any bird
        ///
        /// avg = sum of all the food eaten by all the birds,
        ///       divided by the number of birds
        ///
        /// Median could also come useful!
  =     pub fn train(&mut self) -> String {
  =         let stats = self.sim.train(&mut self.rng);
  = 
  =         format!(
  =             "min={:.2}, max={:.2}, avg={:.2}",
  =             stats.min_fitness,
  =             stats.max_fitness,
  =             stats.avg_fitness,
  =         )
  =     }
    }
  -->
</listing>

<listing-title>
  www/index.js
</listing-title>

<listing lang="javascript">
  <!--
    /* ... */
    
    document.getElementById('train').onclick = function() {
  =     console.log(simulation.train());
    };
    
    /* ... */
  -->
</listing>

<p>
  This time, when building, don't forget about the <code>--release</code> switch
  - it enables optimizations which are crucial to get <code>.train()</code>
  working at reasonable performance:
</p>

<listing-title>
  $ wasm-pack build --release
</listing-title>

<listing lang="text">
  <!--
    ...
    [INFO]: :-) Done in 40.00s
    [INFO]: :-) Your wasm pkg is ready to publish at /home/pwy/Projects/...
  -->
</listing>

<h2 id="ready-set-go">
  Ready, Set, Go!
</h2>

<p>
  Finally, ultimately, eventually, <i>at last</i> - the outcome of our diligent,
  assiduous coding; u ready?
</p>

<figure>
  <video src="{{ assets }}/3c9592ed-e1ef-4fc5-8b72-607fc9692a25.mp4" />
</figure>

<style>
  #_tada {
    margin-top: 0.3em;
    text-align: center;
    font-size: 3em;
  }
</style>

<div id="_tada">ðŸŽ‰</div>

<p>
  Nice?
</p>

<ul>
  <li>
    <p>
      birdies are cute? âœ…
    </p>
  </li>
  <li>
    <p>
      birdies eat food? âœ…
    </p>
  </li>
  <li>
    <p>
      birdies learn to catch food better and better? âœ…
    </p>
  </li>
</ul>

<p>
  Nice!
</p>

<note>
  <p>
    The concrete statistics you get are most likely different than mine, but the
    general trend - min, max and average going up - should be visible in most of
    the simulations.
  </p>

  <p>
    The results won't be rising up to infinity - from what I saw, most of the
    time you'll get averages up to 40~50, everything above will be pretty much
    exceptional.
  </p>

  <p>
    Also, please remember that we're putting a lot of faith in random
    numbers! - if your birds seem to be getting stuck in local optimum too soon,
    try refreshing the simulation.
  </p>
</note>

<h2 id="closing-thoughts">
  Closing Thoughts
</h2>

<p>
  Started from the bottom, haven't we?
</p>

<p>
  From rough sketches, through our very first <code>struct Network</code>, we've
  designed a genetic algorithm, implemented tests for <i>eyes</i> (how awesome
  is that!) and ended up with a bunch of self-governing birdies that certainly
  don't look like <i>this much</i> code on the surface!
</p>

<p>
  I'd like to thank you for your time - I hope this series showed you a fair
  share of Rust idioms, testing techniques and delivered on its promise of using
  WebAssembly in an interesting way.
</p>

<p>
  And, champ, that's for you:
</p>

<figure class="sketch w-70">
  <img src="{{ assets }}/e5313753-9b47-4c39-a198-df190f2db9c4.svg" />

  <figcaption>
    A <a href="https://en.wikipedia.org/wiki/Horned_lark">shorelark</a> (or at
    least my attempt at drawing one)
  </figcaption>
</figure>

<h3>
  What now?
</h3>

<p>
  If you want to fiddle a bit on your own, there's still a few <i>very</i>
  interesting left things to do here!
</p>

<p>
  You remember all those constants such as <code>FOV_RANGE</code>?
</p>

<p>
  If instead of keeping them hard-coded, you made them configurable via some
  <code>struct Config</code>, you could then create an application that'd
  check different combinations of those parameters, trying to find the most
  optimal ones:
</p>

<listing lang="rust">
  <!--
    let mut stats = Vec::new();
    
    for fov_range in vec![0.1, 0.2, 0.3, 0.4, ..., PI] {
        for fov_distance in vec![0.1, 0.2, 0.3, 0.4, ..., 1.0] {
            let current_stats = run_simulation(
                fov_range,
                fov_distance,
                /* ... */,
            );
    
            stats.push((fov_range, fov_distance, current_stats));
        }
    }
    
    // TODO using `stats`, find out which combinations yielded the best results
  -->
</listing>

<p>
  Bonus points for using <a href="https://github.com/rayon-rs/rayon">rayon</a>!
</p>

<p>
  As a reminder: the entire source code, a bit refactored, is available
  <a href="https://github.com/patryk27/shorelark">at my GitHub</a>.
</p>
