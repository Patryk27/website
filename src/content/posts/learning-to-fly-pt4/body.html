<p>
  This is the last part of the <b>Learning to Fly</b> series in which we're
  coding a simulation of evolution using <b>neural network</b> and
  <b>genetic algorithm</b>:
</p>

<figure>
  <a href="https://shorelark.pwy.io">
    <img src="/posts/learning-to-fly-pt1/assets/intro-outcome.png" />
  </a>

  <figcaption>
    <div class="title">
      <a href="https://shorelark.pwy.io">shorelark.pwy.io</a>
    </div>
  </figcaption>
</figure>

<p>In today's, final episode:</p>

<style>
  ._intro-card {
    text-align: center;
    margin-bottom: 1.5em;
  }

  ._intro-card-title {
    padding-bottom: 8px;
    font-weight: bold;
  }

  ._intro-card-body img {
    width: 200px;
  }

  ._intro-card-body pre {
    margin: -5px 0 0 0;
    padding: 0;
  }

  @media only screen and (min-width: 992px) {
    #_intro {
      display: flex;
    }

    ._intro-card {
      flex: 1;
      margin-bottom: 0;
      padding: 5px;
    }

    ._intro-card-body img {
      width: 100%;
    }
  }
</style>

<div id="_intro">
  <div class="_intro-card">
    <div class="_intro-card-title">Sexy Polygons</div>

    <div class="_intro-card-body">
      <img
        src="{{ assets }}/37718e09-3278-44ef-a104-28cb5486e4ff.png"
      />
    </div>
  </div>

  <div class="_intro-card">
    <div class="_intro-card-title">ISO-Certified ASCII Diagrams</div>

    <div class="_intro-card-body">
      <pre>
------------
| \...%....|
|   \......|
|    @&gt;....|
|      \...|
|        \.|
------------</pre
      >
    </div>
  </div>

  <div class="_intro-card">
    <div class="_intro-card-title">Cool Numbers</div>

    <div class="_intro-card-body">
      <img
        src="{{ assets }}/2c33e3da-bfad-4f75-8a0c-c175c4fb1694.png"
      />
    </div>
  </div>
</div>

<hr />

<p>
  Now that we have implemented neural network and genetic algorithm, what awaits
  is the most delightful part: modelling the ecosystem and displaying
  <span class="text-rainbow">them dancing triangles</span> on our screens!
</p>

<p>
  I'm obliged say that at this point we're basically on a runner's high, so if
  you considered the previous three parts even remotely interesting, then going
  through this one will feel like eating Nutella for the first time in your
  life.
</p>

<p class="text-center text-dim">
  <b>content warning</b>: this article contains traces of javascript
</p>

<aside class="note">
  <p>
    No worries if JavaScript or HTML are unfamiliar to you — I'll try to explain
    various concepts as we go.
  </p>
</aside>

<h2 id="plan">
  <a href="#plan">Plan</a>
</h2>

<p>
  We've got <code>struct NeuralNetwork</code> and
  <code>struct GeneticAlgorithm</code> — but what about
  <code>struct Eye</code> or <code>struct World</code>? After all, our birds
  have to have eyes and a place to live!
</p>

<figure class="sketch">
  <img src="/posts/learning-to-fly-pt1/assets/sketches/design-4.svg" />
</figure>

<p>
  So that's what we'll be doing today; we'll implement all those functions
  that'll determine <code>what a bird sees</code> or
  <code>how a bird moves</code>. We'll also — at last! — create a user interface
  that'll allow us to see beyond dry numbers; it's about time we engage that
  visual cortex of ours better!
</p>

<p>
  I'm not a great salesman, but lemme give it a shot — in a marketing gabble:
</p>

<p class="text-center">
  <i
    >we'll see our code in action (<span class="text-rainbow">!</span>), in
    real-time (<span class="text-rainbow">!!</span>), in a web browser (<span
      class="text-rainbow"
      >!!!</span
    >)</i
  >
</p>

<p>If you're into diagrams, what we're aiming for is:</p>

<figure class="sketch w-90">
  <img
    src="{{ assets }}/sketches/9af5a3d9-83f9-47eb-b191-7ee523846ecf.svg"
  />

  <figcaption>
    <div class="title">
      green tick = already implemented, blue dot = will be done today
    </div>
  </figcaption>
</figure>

<p>
  As always, next to coding, we'll also investigate what's
  <i>exactly</i> happening underneath all the layers of abstractions we're
  given — if you're not into that, feel free to skip those yellow boxes.
</p>

<p>Ready? Off we go!</p>

<h2 id="prerequisites">
  <a href="#prerequisites">Prerequisites</a>
</h2>

<p>
  As a reminder, we're using <b>Rust 1.53.0</b> — to avoid unpleasant
  unpleasentaries, don't forget to either execute:
</p>

<listing lang="shell">
  <!--
    $ rustup default nightly-2021-03-25
  -->
</listing>

<p>
  ... or create a file next to <code>Cargo.toml</code> called
  <a href="https://rust-lang.github.io/rustup/overrides.html"
    ><code>rust-toolchain</code></a
  >
  that says:
</p>

<div class="listing-title">rust-toolchain</div>

<listing lang="text">
  <!--
    nightly-2021-03-25
  -->
</listing>

<p>
  In addition, for a <span class="text-spaced">fearless</span> WebAssembly
  experience, we'll need two other tools:
</p>

<ul>
  <li>
    <p>
      <a href="https://www.npmjs.com/get-npm"><code>npm</code></a> (like Cargo,
      but for JavaScript),
    </p>
  </li>
  <li>
    <p>
      <a href="https://rustwasm.github.io/wasm-pack/installer/"
        ><code>wasm-pack</code></a
      >
      (set of tools that make compiling Rust into WebAssembly easier).
    </p>
  </li>
</ul>

<p>
  Before continuing, please install those tools according to the system you're
  using.
</p>

<aside class="note">
  <p>
    If you're into <a href="https://nixos.org/">Nix</a>, installing both
    applications is as easy as creating a file called <code>shell.nix</code>:
  </p>

  <div class="listing-title">shell.nix</div>

  <listing lang="nix">
    <!--
      let
        pkgs = import <nixpkgs> { };
      
      in
        pkgs.mkShell {
          buildInputs = with pkgs; [
            nodejs
            wasm-pack
          ];
        }
    -->
  </listing>

  <p>... and executing <code>nix-shell</code>.</p>
</aside>

<h2 id="hello-wasm-rust">
  <a href="#hello-wasm-rust">Hello, WebAssembly World! (the Rust part)</a>
</h2>

<p>
  Let's begin by creating a new crate — as in the diagram, it will be
  responsible for interacting with our frontend application:
</p>

<aside class="note">
  <p>
    Formally, this kind of "talking to another system" module is known as a
    <b>bridge</b> or an
    <a href="https://en.wikipedia.org/wiki/Interoperation"
      ><strong>interop</strong></a
    >.
  </p>
</aside>

<listing lang="shell">
  <!--
    $ cd libs
    $ cargo new simulation-wasm --lib --name lib-simulation-wasm
    
    # (this crate's name doesn't have to contain `wasm` - it's just a
    # convention of mine, so that the crate's purpose is explicit)
  -->
</listing>

<aside class="note">
  <p>
    By the way, I've gotta apologize as I've made a small mistake in the
    previous two parts: our <code>cargo new</code> was missing the
    <code>--name</code> parameter.
  </p>

  <p>
    This parameter affects the value of <code>name</code> inside a manifest,
    meaning that we should've had:
  </p>

  <div class="listing-title">libs/genetic-algorithm/Cargo.toml</div>

  <listing lang="toml">
    <!--
      [package]
    = name = "lib-genetic-algorithm"
      
      # instead of:
      # name = "genetic-algorithm"
      
      # ...
    -->
  </listing>

  <div class="listing-title">libs/neural-network/Cargo.toml</div>

  <listing lang="toml">
    <!--
      [package]
    = name = "lib-neural-network"
      
      # instead of:
      # name = "neural-network"
      
      # ...
    -->
  </listing>

  <p>
    This is a minor thing that I consider a good practice — by prefixing
    workspace-crates, you reduce the risk of your local crate name-clashing with
    something from crates.io.
  </p>

  <p>
    Say, we're about to create <code>libs/rand</code> — by calling it
    <code>lib-rand</code> instead of just <code>rand</code>, we can avoid
    confusing other programmers who might stumble upon our code in the future.
  </p>

  <p>Similar approaches include:</p>

  <ul>
    <li>
      <p>
        prefixing with project's name (that's what
        <a
          href="https://github.com/rust-lang/rust/tree/ff34b919075f35a1787659e9c448a34b06bab8de/compiler"
          >rustc</a
        >
        does, for example),
      </p>
    </li>
    <li>
      <p>
        prefixing with whatever else you want (e.g. <code>local-foo</code> or
        <code>crate_foo</code>),
      </p>
    </li>
    <li>
      <p>not prefixing at all (also valid!).</p>
    </li>
  </ul>

  <p>Please, fix those two manifests, and let's get going.</p>
</aside>

<p>
  To make our crate WebAssembly-<i>aware</i>, there are
  <a
    href="https://rustwasm.github.io/docs/wasm-pack/tutorials/npm-browser-packages/getting-started/manual-setup.html"
    >two things</a
  >
  we have to add to its manifest:
</p>

<ol>
  <li>
    <p>
      We have to set
      <a href="https://doc.rust-lang.org/reference/linkage.html"
        ><code>crate-type</code></a
      >
      to <code>cdylib</code>:
    </p>

    <div class="listing-title">libs/simulation-wasm/Cargo.toml</div>

    <listing lang="toml">
      <!--
        [package]
        # ...
        
      = [lib]
      = crate-type = ["cdylib"]
      -->
    </listing>

    <aside class="note">
      <p>
        Compiler transforms code into <i>something</i>, and
        <code>crate-type</code> determines what that <i>something</i> — also
        called an <b>artifact</b> — gets to be:
      </p>

      <ul>
        <li>
          <p>
            <code>crate-type = ["bin"]</code> means: compiler, pretty please
            produce a <b>program</b> <br />
            (e.g. an <code>.exe</code> file for Windows),
          </p>
        </li>
        <li>
          <p>
            <code>crate-type = ["lib"]</code> means: compiler, pretty please
            produce a <b>library</b> <br />
            (e.g. a <code>.dll</code> file for Windows, <code>.so</code> for
            Linux).
          </p>
        </li>
      </ul>

      <p>Where:</p>

      <ul>
        <li>
          <p>
            a <b>program</b> is something that you can execute directly (e.g.
            from your terminal),
          </p>
        </li>
        <li>
          <p>
            a <b>library</b> is a piece of code that provides functions
            <i>for others</i> to use.
          </p>
        </li>
      </ul>

      <p>
        The type we have to use,
        <a
          href="https://github.com/rust-lang/rfcs/blob/master/text/1510-cdylib.md"
          ><code>cdylib</code></a
        >, stands for <b>C dynamic library</b>, and it tells the compiler:
      </p>

      <ul>
        <li>
          <p>
            that it should export only those functions which are intended to be
            called from outside, ignoring Rust-specific <i>internal</i> stuff.
          </p>

          <p>
            This prevents bloating the library with "useless" metadata, and so
            it's important for WebAssembly (we don't want our users to go
            bankrupt over internet bills, do we?).
          </p>
        </li>
        <li>
          <p>
            that it should generate a <b>dynamic library</b> — that is: a piece
            of code that will get invoked <i>by somebody else</i>.
          </p>

          <p>
            This is required for WebAssembly, because — as you'll see in a
            moment — our Rust code won't run standalone: it'll be at
            JavaScript's beck and call.
          </p>

          <p>
            In practice, what this means is that we won't have any
            <code>fn main() { …​ }</code>, but rather
            <code>pub fn do_something() { …​ }</code>.
          </p>
        </li>
      </ul>
    </aside>
  </li>
  <li>
    <p>
      We have to include
      <a href="https://github.com/rustwasm/wasm-bindgen"
        ><code>wasm-bindgen</code></a
      >
      in our dependencies:
    </p>

    <div class="listing-title">libs/simulation-wasm/Cargo.toml</div>

    <listing lang="toml">
      <!--
        # ...
        
        [dependencies]
      = wasm-bindgen = "0.2"
      -->
    </listing>

    <aside class="note">
      <p>
        <code>wasm-bindgen</code> provides types and macros that facilitate
        writing WebAssembly-aware code.
      </p>

      <p>
        <a
          href="https://www.novatec-gmbh.de/blog/look-ma-no-js-compiling-rust-to-webassembly/"
          >It is possible</a
        >
        to write Rust + WebAssembly without it — just less convenient.
      </p>
    </aside>
  </li>
</ol>

<p>When it comes to adjustments, that's all — now it's Rust-time!</p>

<p>
  Since creating the simulation will take some time, and it'd be nice to see
  <i>something</i> working as soon as possible, I say we begin by creating a
  function that we'll be able to invoke from JavaScript right away — you know,
  just to ensure that this <i>"WebAssembly"</i> thing isn't just a hoax:
</p>

<div class="listing-title">libs/simulation-wasm/src/lib.rs</div>

<listing lang="rust">
  <!--
  = pub fn whos_that_dog() -> String {
  =     "Mister Peanutbutter".into()
  = }
  -->
</listing>

<p>
  If we were building a regular crate to publish on crates.io, that'd be
  all — but for WebAssembly, there's one more thing we have to
  add — <code>#[wasm_bindgen]</code>:
</p>

<div class="listing-title">libs/simulation-wasm/src/lib.rs</div>

<listing lang="rust">
  <!--
  = use wasm_bindgen::prelude::*;
    
  = #[wasm_bindgen]
    pub fn whos_that_dog() -> String {
        "Mister Peanutbutter".into()
    }
  -->
</listing>

<aside class="note">
  <p>
    Simplifying a bit, the <code>#[wasm_bindgen]</code>
    <a
      href="https://doc.rust-lang.org/book/ch19-06-macros.html#procedural-macros-for-generating-code-from-attributes"
      >procedural macro</a
    >
    informs the compiler that you want to <b>export</b> given function or
    type — that is: make it visible on the JavaScript's side.
  </p>

  <p>
    All Rust symbols eventually are compiled into WebAssembly, but only those
    prepended with <code>#[wasm_bindgen]</code> can be invoked from the
    JavaScript code <i>directly</i>.
  </p>

  <p>
    If you're curious, you can further use
    <a href="https://github.com/dtolnay/cargo-expand"
      ><code>cargo-expand</code></a
    >
    to inspect what this macro does:
  </p>

  <div class="listing-title">$ cargo expand</div>

  <listing lang="rust">
    <!--
      use wasm_bindgen::prelude::*;
      
      pub fn whos_that_dog() -> String {
          "Mister Peanutbutter".into()
      }
      
      //  v--------v
      pub extern "C" fn __wasm_bindgen_generated_whos_that_dog() ->
          <String as wasm_bindgen::convert::ReturnWasmAbi>::Abi
      {
          let _ret = { whos_that_dog() };
          <String as wasm_bindgen::convert::ReturnWasmAbi>::return_abi(_ret)
      }
      //  ^ `extern` informs compiler (and linker) that this function must
      //  | be exported (it must be visible from outside the Rust code).
      //  |
      //  | While `pub` determines how given symbol is visible _inside_ Rust
      //  | code, `extern` says "other languages should be able to invoke
      //  | this function, too".
      //  |
      //  | `"C"` determines a so-called application binary interface (ABI),
      //  | which describes _how exactly_ the function gets to be exported
      //  | (there are many different conventions that define how parameters
      //  | and return values must be passed in order to be understood "on
      //  | the other side").
      //  |
      //  | If you want to know more - which it's not required to follow
      //  | the article - there's:
      //  |
      //  | https://doc.rust-lang.org/reference/items/external-blocks.html#abi
      //  ---
    -->
  </listing>

  <p>
    ... and if you're <i>even more</i> curious, then you'll like the
    <a
      href="https://rustwasm.github.io/docs/wasm-bindgcontributing/design/index.html"
      >rustwasm book</a
    >
    :-)
  </p>
</aside>

<p>
  To build a WebAssembly crate, we'll use that <b>wasm-pack</b> tool we've just
  installed:
</p>

<listing lang="shell">
  <!--
    $ cd simulation-wasm
    $ wasm-pack build
  -->
</listing>

<p>
  The difference between plain <code>cargo</code> and <code>wasm-pack</code> is
  that the latter not only compiles the code, but also generates a lot of handy
  JavaScript files that otherwise we'd have to write by hand — we can find them
  all inside a newly-created directory called <code>pkg</code>:
</p>

<listing lang="text">
  <!--
    $ tree pkg
    pkg
    ├── lib_simulation_wasm_bg.js
    ├── lib_simulation_wasm_bg.wasm
    ├── lib_simulation_wasm_bg.wasm.d.ts
    ├── lib_simulation_wasm.d.ts
    ├── lib_simulation_wasm.js
    └── package.json
  -->
</listing>

<p>To ground ourselves, let's take a brief look at what we've got:</p>

<ul>
  <li>
    <p>
      <code>package.json</code> is like
      <a href="https://www.npmjs.com/">npm</a>-'s <code>Cargo.toml</code> — it
      contains metadata about the module itself:
    </p>

    <div class="listing-title">libs/simulation-wasm/pkg/package.json</div>

    <listing lang="javascript">
      <!--
        {
          "name": "lib-simulation-wasm",
          "collaborators": [
            "Patryk Wychowaniec <pwychowaniec@pm.me>"
          ],
          "version": "0.1.0",
          /* ... */
        }
      -->
    </listing>
  </li>
  <li>
    <p>
      <code>lib_simulation_wasm.d.ts</code> contains
      <a href="https://en.wikipedia.org/wiki/Forward_declaration"
        >forward declarations</a
      >
      for IDEs to provide type hints:
    </p>

    <div class="listing-title">
      libs/simulation-wasm/pkg/lib_simulation_wasm.d.ts
    </div>

    <listing lang="javascript">
      <!--
        /**
         * @returns {string}
         */
        export function whos_that_dog(): string;
      -->
    </listing>
  </li>
  <li>
    <p>
      <code>lib_simulation_wasm_bg.wasm</code> is <i>the essence</i>, as it
      contains the WebAssembly
      <a href="https://en.wikipedia.org/wiki/Bytecode"
        ><strong>bytecode</strong></a
      >
      of our crate; it's like <code>.dll</code> or <code>.so</code>, and you can
      use <a href="https://github.com/WebAssembly/wabt">wabt</a> to inspect it
      (mainly for fun, I guess):
    </p>

    <div class="listing-title">$ wasm2wat pkg/lib_simulation_wasm_bg.wasm</div>

    <listing lang="lisp">
      <!--
        (module
          (func (type 1) (param i32) (result i32)
            (local i32 i32 i32 i32)
            global.get 0
            i32.const 16
            i32.sub
            local.tee 11
            ;; ...
      -->
    </listing>
  </li>
  <li>
    <p>
      <code>lib_simulation_wasm_bg.js</code> contains a rather spine-chilling
      code that actually invokes our WebAssembly library:
    </p>

    <div class="listing-title">
      libs/simulation-wasm/pkg/lib_simulation_wasm_bg.js
    </div>

    <listing lang="javascript">
      <!--
        /**
         * @returns {string}
         */
        export function whos_that_dog() {
            try {
                const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
                wasm.whos_that_dog(retptr);
                var r0 = getInt32Memory0()[retptr / 4 + 0];
                var r1 = getInt32Memory0()[retptr / 4 + 1];
                return getStringFromWasm0(r0, r1);
            } finally {
                wasm.__wbindgen_add_to_stack_pointer(16);
                wasm.__wbindgen_free(r0, r1);
            }
        }
      -->
    </listing>

    <aside class="note">
      <p>Wait — if our Rust code does next to <i>nothing</i>:</p>

      <div class="listing-title">libs/simulation-wasm/src/lib.rs</div>

      <listing lang="rust">
        <!--
          pub fn whos_that_dog() -> String {
              "Mister Peanutbutter".into()
          }
        -->
      </listing>

      <p>... then why does <i>that</i> piece look so complex?</p>

      <p>
        Well, in short, it's because WebAssembly
        <b>doesn't support strings</b> — and wasm-pack, being neat,
        transparently hacks its way around it.
      </p>

      <p>But first, the terminology:</p>

      <ul>
        <li>
          <p>
            When you move a value from one function into another, when both
            functions work in different environments and/or when they are
            written in different languages, you make it
            <b
              >cross the foreign function interface (<a
                href="https://doc.rust-lang.org/nomicon/ffi.html"
                >FFI</a
              >) boundary</b
            >:
          </p>

          <figure class="sketch w-80">
            <img
              src="{{ assets }}/sketches/962da22e-fe0c-49b1-afb6-c333e5a18447.svg"
            />
          </figure>

          <p>
            In this case we'd say that our
            <code>fn whos_that_dog()</code> returns a <code>String</code> that
            crosses the FFI boundary from Rust (where it's created) into
            JavaScript (where it's used).
          </p>

          <p>
            Crossing the FFI boundary is a big deal, because different languages
            tend to have different <b>memory representations</b> of objects — so
            even if Rust's <code>struct Foo</code> and JavaScript's
            <code>class Foo</code> look alike on the surface, their
            <b>memory layout</b> is different.
          </p>

          <p>
            This means that when you want to send a value from one language into
            another, you cannot just say "hey, there's a few bytes at 0x0000CAFE
            - that's Foo" — instead, you have to <b>convert</b> that value into
            something the other party can understand:
          </p>

          <figure class="sketch w-80">
            <img
              src="{{ assets }}/sketches/d152e743-8a56-4f39-8376-ce72bca8c88c.svg"
            />
          </figure>

          <p>
            (so it's just like speech: while you can't <i>show</i> somebody
            what's inside your head, you can
            <i>describe it</i> — <i>serialize</i> — using words.)
          </p>
        </li>
        <li>
          <p>
            When you convert a value into another representation, you
            <b>serialize</b> it.
          </p>

          <p>For instance, a type such as this one:</p>

          <listing lang="rust">
            <!--
              struct Foo {
                  value: String,
              }
            -->
          </listing>

          <p>
            ... can be <i>serialized</i> into, say, JSON that looks like this:
          </p>

          <listing lang="json">
            <!--
              {
                "value": "Hi!"
              }
            -->
          </listing>

          <p>
            ... which can be then easily <b>deserialized</b> on the JavaScript's
            side:
          </p>

          <listing lang="javascript">
            <!--
              const foo = JSON.parse('{ "value": "Hi!" }');
              console.log(foo);
            -->
          </listing>

          <p>
            (serialization isn't limited to human-readable formats such as JSON,
            YAML or XML - there's also e.g.
            <a
              href="https://hacks.mozilla.org/2019/04/crossing-the-rust-ffi-frontier-with-protocol-buffers/"
              >Protocol Buffers</a
            >.)
          </p>
        </li>
      </ul>

      <p>Now:</p>

      <p>
        While both Rust and JavaScript support strings, WebAssembly understands
        mostly numbers — this means that all the functions that we export via
        <code>#[wasm_bindgen]</code> might accept and return <i>at most</i> a
        handful of numbers (from WebAssembly's point of view).
      </p>

      <p>
        This means that in order to return a string, wasm-pack had to get
        creative — it generated this boi we've already seen a moment ago:
      </p>

      <div class="listing-title">
        (generated automatically during compilation)
      </div>

      <listing lang="rust">
        <!--
          pub extern "C" fn __wasm_bindgen_generated_whos_that_dog()
              -> <String as ReturnWasmAbi>::Abi
          {
              let _ret = { whos_that_dog() };
              <String as ReturnWasmAbi>::return_abi(_ret)
          }
        -->
      </listing>

      <p>
        In general, this is known as <b>shim</b> (or <b>glue-function</b>, or
        <b>glue-code</b>).
      </p>

      <p>
        This one converts Rust's <code>String</code> into a pair of
        numbers — following the JavaScript code:
      </p>

      <ul>
        <li>
          <p>
            <code>r0</code> which determines location of returned string in
            memory (it's good-old
            <a
              href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)"
              >pointer</a
            >),
          </p>
        </li>
        <li>
          <p><code>r1</code> which determines length of returned string.</p>
        </li>
      </ul>

      <p>
        Those two numbers are then used by <code>getStringFromWasm0()</code> to
        <b>recreate</b> ("deserialize") the string on JavaScript's side — all
        without us having to lift a single finger.
      </p>

      <p>Pretty neat!</p>

      <p>
        (to avoid diluting this article — if you're further interested in
        WebAssembly's memory model,
        <a href="https://radu-matei.com/blog/practical-guide-to-wasm-memory/"
          >here’s</a
        >
        a nice introduction.)
      </p>
    </aside>
  </li>
</ul>

<p>
  Phew, that's a lot of information for one <code>fn() -&gt; String</code> that
  we <i>still</i> haven't seen working — but that's only because I wanted to
  give you an introduction as to
  <i>"why wasm-pack generates so many files"</i> and
  <i>"why no cargo build"</i>; later we won't be inspecting those artifacts
  again.
</p>

<p>So, now that our crate is compiled, &lt;deep-breath/&gt;,</p>

<p class="text-center">
  <b>how do we run it?</b>
</p>

<h2 id="hello-wasm-js">
  <a href="#hello-wasm-js">Hello, WebAssembly World! (the JavaScript part)</a>
</h2>

<p>Frontend time!</p>

<p>
  To start our frontend application, let's go back to the project's root
  directory (next to our top-level <code>Cargo.toml</code>):
</p>

<listing lang="shell">
  <!--
    $ cd ../..
  -->
</listing>

<p>
  Setting up a frontend requires a bit of boilerplate too — luckily, this time
  we can use <code>npm init</code> to copy-paste the
  <a href="https://github.com/rustwasm/create-wasm-app"
    >WebAssembly frontend template project</a
  >
  for us:
</p>

<listing lang="shell">
  <!--
    $ npm init wasm-app www
  -->
</listing>

<p>
  You should now see a directory called <code>www</code> with a handful of
  files:
</p>

<listing lang="text">
  <!--
    $ tree www
    www
    ├── bootstrap.js
    ├── index.html
    ├── index.js
    ├── LICENSE-APACHE
    ├── LICENSE-MIT
    ├── package.json
    ├── package-lock.json
    ├── README.md
    └── webpack.config.js
  -->
</listing>

<p>... let's briefly go through them.</p>

<h3>Knowing your enemy</h3>

<p>
  <i>Le point d'entrée</i>, similar to Rust's <code>main.rs</code>, here is
  <code>index.html</code>:
</p>

<div class="listing-title">www/index.html</div>

<listing lang="html">
  <!--
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="utf-8">
        <title>Hello wasm-pack!</title>
      </head>
    
      <body>
        <script src="./bootstrap.js"></script>
      </body>
    </html>
  -->
</listing>

<p>A quick primer on HTML:</p>

<ul>
  <li>
    <p><code>&lt;something&gt;</code> is called a <b>tag</b>,</p>
  </li>
  <li>
    <p>
      a tag has an <b>opening</b>: <code>&lt;something&gt;</code>; and an
      <b>ending</b>: <code>&lt;/something&gt;</code>,
    </p>
  </li>
  <li>
    <p>a tag might contain <b>attributes</b>: <code>key="value"</code>,</p>
  </li>
  <li>
    <p>a tag might contain <b>children</b> (i.e. more tags inside of it).</p>
  </li>
</ul>

<p>
  Overall, an HTML document describes a
  <a href="https://en.wikipedia.org/wiki/Document_Object_Model"
    >tree representation</a
  >
  of the web page:
</p>

<listing lang="text">
  <!--
    html
    ├── head
    │   ├── meta
    │   └── title
    └── body
        └── script
  -->
</listing>

<p>... which browser analyzes, trying to make something nice out of it.</p>

<p>Each tag has a certain meaning:</p>

<ul>
  <li>
    <p><code>html</code> wraps the entire document,</p>
  </li>
  <li>
    <p>
      <code>head</code> contains document's metadata (such as its language or
      title),
    </p>
  </li>
  <li>
    <p><code>body</code> contains document's contents,</p>
  </li>
  <li>
    <p><code>script</code> loads and executes a JavaScript file,</p>
  </li>
  <li>
    <p>
      <code>p</code> (not used here, just provided as an example) prints text,
    </p>
  </li>
  <li>
    <p><code>b</code> (ditto) prints text in bold:</p>

    <listing lang="html">
      <!--
        <body>
          <p>yes... ha ha ha... <b>yes!</b></p>
        </body>
      -->
    </listing>

    <figure class="sketch w-30">
      <img
        src="{{ assets }}/ab2b7ba1-2fbb-44a7-8126-592e2c8f4a1f.png"
      />
    </figure>
  </li>
</ul>

<p>
  Armed with all this knowledge, we can see that our page doesn't actually do
  that much — the most important thing is that it loads
  <code>bootstrap.js</code>:
</p>

<div class="listing-title">www/bootstrap.js</div>

<listing lang="javascript">
  <!--
    import("./index.js")
      .catch(e => console.error("Error importing `index.js`:", e));
  -->
</listing>

<p>
  <code>import</code> is like Rust's <code>use</code> or
  <code>extern crate</code>. Contrary to Rust, in JavaScript
  <code>import</code> can be used as a <b>statement</b>, meaning that it
  <b>returns a value</b>; in pseudo-Rust, what happens above is:
</p>

<listing lang="rust">
  <!--
    (mod "./index.js")
        .await
        .map_err(|err| {
            eprintln!("Error importing ...", err);
        });
  -->
</listing>

<p>
  We can see that this code loads <code>index.js</code>, so let's take a look
  there:
</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    import * as wasm from "hello-wasm-pack";
    //                     ^-------------^
    //                      defined in package.json
    
    wasm.greet();
  -->
</listing>

<p>
  This <code>import</code> is a bit different in that it resembles
  <code>extern crate</code> more:
</p>

<listing lang="rust">
  <!--
    extern crate hello_wasm_pack as wasm;
    
    wasm::greet();
  -->
</listing>

<p>When it comes to the application's code itself, that's all.</p>

<p>
  We can also spot one more file, called <code>webpack.config.js</code> — while
  we won't have to touch it, it won't hurt to take a look either:
</p>

<div class="listing-title">www/webpack.config.js</div>

<listing lang="javascript">
  <!--
    const CopyWebpackPlugin = require("copy-webpack-plugin");
    const path = require('path');
    
    module.exports = {
      entry: "./bootstrap.js",
      output: {
        path: path.resolve(__dirname, "dist"),
        filename: "bootstrap.js",
      },
      mode: "development",
      plugins: [
        new CopyWebpackPlugin(['index.html'])
      ],
    };
  -->
</listing>

<p>
  This file contains configuration for
  <a href="https://webpack.js.org/">webpack</a>, which is…​ kinda like Cargo,
  but for JavaScript 😅
</p>

<aside class="note">
  <p>
    Since this is the second time I say "like Cargo", it's time to get more
    specific:
  </p>

  <ul>
    <li>
      <p><a href="https://www.npmjs.com/">npm</a> manages dependencies,</p>
    </li>
    <li>
      <p>
        <a href="https://webpack.js.org/">webpack</a> builds application (in
        part, it's like
        <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"
          >build.rs</a
        >).
      </p>
    </li>
  </ul>

  <p>
    Cargo does all of those things on its own (how comfy!), but for JavaScript
    we need those two, separate applications.
  </p>
</aside>

<h3>What To Do After You Know Your Enemy</h3>

<p>
  Having exchanged pleasantries with the filesystem, let's get back to the
  business:
</p>

<ol>
  <li>
    <p>
      Currently <code>npm</code> doesn't know about
      <code>lib-simulation-wasm</code> — let's fix it:
    </p>

    <div class="listing-title">www/package.json</div>

    <listing lang="javascript">
      <!--
        {
          /* ... */
          "devDependencies": {
      =     "lib-simulation-wasm": "file:../libs/simulation-wasm/pkg",
            /* ... */
          }
        }
      -->
    </listing>
  </li>
  <li>
    <p>After that, we have to let <code>npm</code> know about that change:</p>

    <listing lang="shell">
      <!--
        $ cd www
        $ npm install
      -->
    </listing>

    <aside class="note">
      <p>This command might print a few scary-looking messages:</p>

      <listing lang="text">
        <!--
          npm WARN optional SKIPPING OPTIONAL DEPENDENCY: ...
        -->
      </listing>

      <listing lang="text">
        <!--
          found 362 vulnerabilities (348 low, 4 moderate, 10 high)
            run `npm audit fix` to fix them, or `npm audit` for details
        -->
      </listing>

      <p>
        ... but worry not — that's just <code>npm</code> being <code>npm</code>;
        if it succeeds, then everything's alright.
      </p>
    </aside>
  </li>
  <li>
    <p>Now it's time for <code>index.js</code>:</p>

    <div class="listing-title">www/index.js</div>

    <listing lang="javascript">
      <!--
      = import * as sim from "lib-simulation-wasm";
      = 
      = alert("Who's that dog? " + sim.whos_that_dog() + "!");
      -->
    </listing>

    <aside class="note">
      <p>
        There's no <code>function main() { }</code> — that's because JavaScript
        doesn't need one: all the code gets to be executed top-down (<a
          href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting"
          >more or less</a
        >, at least).
      </p>

      <p class="text-center"><i>they're savages, I know!</i> /s</p>
    </aside>
  </li>
  <li>
    <p>
      With everything ready, we can now launch our application — this is
      basically <code>cargo run</code>:
    </p>

    <listing lang="shell">
      <!--
        $ npm run start
      -->
    </listing>

    <listing lang="text">
      <!--
        ...
        ℹ ｢wds｣: Project is running at http://localhost:8080/
        ...
      -->
    </listing>
  </li>
</ol>

<p>
  When you now open this link in your browser, you'll be greeted with a peppy,
  springy & spry:
</p>

<figure class="sketch">
  <img
    src="{{ assets }}/42ca83b3-8949-4b70-aa72-3b1b1a8bed17.png"
  />
</figure>

<p class="text-center">yay 🎉 yay</p>

<aside class="note">
  <p>
    By the way: when <code>npm run start</code> is working, it automatically
    listens for changes.
  </p>

  <p>
    If you'd like to modify this alert's message, simply go back to
    <code>lib.rs</code>, do whatever you want, run <code>wasm-pack build</code>,
    and — in a few seconds — the site should automatically reload.
  </p>

  <p>
    The same applies for HTML and JS, though you don't have to re-run
    <code>wasm-pack</code> then.
  </p>
</aside>

<h2 id="hello-wasm-summary">
  <a href="#hello-wasm-summary">Hello, WebAssembly World! (the summary part)</a>
</h2>

<p>So…​ what is all this?</p>

<p>
  Granted, displaying an alert message doesn't exactly qualify us for Da Nobel
  Prize (unless i'm mistaken in which case please let me know
  <b><i>urgently</i></b> thanks) — but our point was to get something running
  quickly, and we <i>did</i> get something running pretty quickly.
</p>

<p>
  In the next section, we'll lay the foundations for our simulation — just
  enough to have something to send to JavaScript.
</p>

<h2 id="hello-simulation">
  <a href="#hello-simulation">Hello, Simulation!</a>
</h2>

<p>
  As before, to keep the boundaries clean & tidy, let's start by creating a new
  crate:
</p>

<listing lang="shell">
  <!--
    $ cd ../libs
    $ cargo new simulation --lib --name lib-simulation
  -->
</listing>

<p>
  This crate will contain our
  <span class="text-rainbow">simulation engine</span>:
</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
  = pub struct Simulation;
  -->
</listing>

<p>
  Now, to avoid conjuring a design out of
  <span class="text-spaced">thin air</span>, let's recall our drawing from
  before:
</p>

<figure class="sketch">
  <img src="/posts/learning-to-fly-pt1/assets/sketches/design-4.svg" />
</figure>

<p>What do we see there? Hmm, well — certainly a <b>world</b>:</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
  = pub struct Simulation {
  =     world: World,
  = }
    
  = #[derive(Debug)]
  = pub struct World;
  -->
</listing>

<p>
  ... which contains some <b>animals</b> (<i>birds!</i>) and <b>foods</b> (<i
    >rich in protein & fiber!</i
  >):
</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
  = pub struct World {
  =     animals: Vec<Animal>,
  =     foods: Vec<Food>,
  = }
    
  = #[derive(Debug)]
  = pub struct Animal;
    
  = #[derive(Debug)]
  = pub struct Food;
  -->
</listing>

<p>... which are located at some <b>coordinates</b>:</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
  = pub struct Animal {
  =     position: ?,
  = }
    
    #[derive(Debug)]
  = pub struct Food {
  =     position: ?,
  = }
  -->
</listing>

<aside class="note">
  <p>
    <i>Fun Related Note</i>
  </p>

  <p>
    Here, we're designing our models using object-oriented
    programming — although that's a correct approach, it's <i>not</i> the only
    one!
  </p>

  <p>
    There exists a marvelous pattern called
    <a href="https://ianjk.com/ecs-in-rust/"
      ><strong>entity-component-system</strong></a
    >
    which allows to express certain model &lt;-&gt; property relations (such as
    <code>animal &lt;-&gt; position</code>) in a bit different,
    cleaner-when-there-are-lots-of-properties way.
  </p>

  <p>
    Using ECS goes beyond the scope of this article, so I'm merely sowing a seed
    if you happen to be looking for a cool design pattern to learn in the
    future.
  </p>
</aside>

<p>Our world is two-dimensional, which sets us at:</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct Animal {
  =     position: Point2,
    }
    
    #[derive(Debug)]
    pub struct Food {
  =     position: Point2,
    }
    
  = #[derive(Debug)]
  = pub struct Point2 {
  =     x: f32,
  =     y: f32,
  = }
  -->
</listing>

<p>Moreover, animals are of certain <b>rotati</b>…​</p>

<p class="text-center">wait — did you hear that?</p>

<p class="text-center">oh no</p>

<p class="text-center">who's that?</p>

<p class="text-center">oh no</p>

<p class="text-center">
  🚨 it's the
  <a href="https://en.wikipedia.org/wiki/Not_invented_here"
    >not-invented-here</a
  >
  police 🚨
</p>

<p>
  So far we've been writing a lot of code by hand — you know, that genetic
  algorithm and neural network, to name a few.
</p>

<p>
  At least now, when it comes to a few mathematical data structures, I'd like to
  avoid reinventing the wheel — in part because there's barely anything
  educational in writing:
</p>

<listing lang="rust" class="listing-invalid">
  <!--
    #[derive(Copy, Clone, Debug)]
    pub struct Point2 {
        x: f32,
        y: f32,
    }
    
    impl Point2 {
        pub fn new(...) -> Self {
            /* ... */
        }
    
        /* ... */
    }
    
    impl Add<Point2> for Point2 {
        /* ... */
    }
    
    impl Sub<Point2> for Point2 {
        /* ... */
    }
    
    impl Mul<Point2> for f32 {
        /* ... */
    }
    
    impl Mul<f32> for Point2 {
        /* ... */
    }
    
    #[cfg(test)]
    mod tests {
        /* ... */
    }
  -->
</listing>

<p>
  ... and in part because I'd like to introduce you to a crate that I love:
  <a href="https://nalgebra.org">nalgebra</a>!
</p>

<p>
  Quoting
  <a href="https://docs.rs/nalgebra/0.26.2/nalgebra/">their documentation</a>:
</p>

<blockquote>
  <p>nalgebra is a linear algebra library written for Rust targeting:</p>

  <ul>
    <li>
      <p>General-purpose linear algebra (still lacks a lot of features…)</p>
    </li>
    <li>
      <p>Real-time computer graphics.</p>
    </li>
    <li>
      <p>Real-time computer physics.</p>
    </li>
  </ul>
</blockquote>

<p>
  In other words: <i>math for the people, done right</i>; and it
  <a href="https://www.nalgebra.org/docs/user_guide/wasm_and_embedded_targets/"
    >plays nice with WebAssembly</a
  >.
</p>

<p>
  nalgebra provides a variety of different tools: from simple functions such as
  <a href="https://docs.rs/nalgebra/0.26.2/nalgebra/fn.clamp.html">clamp</a>,
  through somewhat complicated structures such as
  <a
    href="https://docs.rs/nalgebra/0.26.2/nalgebra/geometry/type.UnitDualQuaternion.html"
    >quaternions</a
  >, to our beloved
  <a href="https://docs.rs/nalgebra/0.26.2/nalgebra/geometry/type.Point2.html"
    ><code>Point2</code></a
  >.
</p>

<p>
  Since it's just a crate, installing it boils down to editing the manifest:
</p>

<div class="listing-title">libs/simulation/Cargo.toml</div>

<listing lang="toml">
  <!--
    # ...
    
    [dependencies]
  = nalgebra = "0.26"
  -->
</listing>

<p>... and then our code from a moment ago becomes:</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
  = use nalgebra as na;
    // --------- ^^
    // | This kind of import - one that uses `as` - is called an alias.
    // | You'd say that we're aliasing `nalgebra` as `na`.
    // ---
    
    /* ... */
    
    #[derive(Debug)]
    pub struct Animal {
  =     position: na::Point2<f32>,
    }
    
    #[derive(Debug)]
    pub struct Food {
  =     position: na::Point2<f32>,
    }
  -->
</listing>

<p>
  Where were we? Ah, right — animals are of certain <b>rotation</b> and
  <b>speed</b>:
</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct Animal {
        position: na::Point2<f32>,
  =     rotation: na::Rotation2<f32>,
  =     speed: f32,
    }
    
    /* ... */
  -->
</listing>

<aside class="note">
  <p>
    Overall, rotation and speed can be also represented together as a
    <b>vector</b>:
  </p>

  <listing lang="rust">
    <!--
      #[derive(Debug)]
      pub struct Animal {
          position: na::Point2<f32>,
          velocity: na::Vector2<f32>,
      }
    -->
  </listing>

  <p>
    We'll continue with two separate fields, because it makes certain
    computations easier later, but should you though feel adventurous…​
  </p>
</aside>

<p>
  Now that we have a few models, it'd be nice if we could somehow construct
  them, so:
</p>

<div class="listing-title">libs/simulation/Cargo.toml</div>

<listing lang="toml">
  <!--
    # ...
    
    [dependencies]
    nalgebra = "0.26"
  = rand = "0.8"
  -->
</listing>

<p>
  ... and while we're here, let's enable nalgebra's support for rand — it'll
  come handy in a moment:
</p>

<div class="listing-title">libs/simulation/Cargo.toml</div>

<listing lang="toml">
  <!--
    # ...
    
    [dependencies]
  = nalgebra = { version = "0.26", features = ["rand-no-std"] }
    rand = "0.8"
  -->
</listing>

<p>
  We'll start with a few rudimentary constructors that just randomize
  everything:
</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    use nalgebra as na;
  = use rand::{Rng, RngCore};
    
    /* ... */
    
  = impl Simulation {
  =     pub fn random(rng: &mut dyn RngCore) -> Self {
  =         Self {
  =             world: World::random(rng),
  =         }
  =     }
  = }
  = 
  = impl World {
  =     pub fn random(rng: &mut dyn RngCore) -> Self {
  =         let animals = (0..40)
  =             .map(|_| Animal::random(rng))
  =             .collect();
  = 
  =         let foods = (0..60)
  =             .map(|_| Food::random(rng))
  =             .collect();
  = 
  =         // ^ Our algorithm allows for animals and foods to overlap, so
  =         // | it's hardly ideal - but good enough for our purposes.
  =         // |
  =         // | A more complex solution could be based off of e.g.
  =         // | Poisson disk sampling:
  =         // |
  =         // | https://en.wikipedia.org/wiki/Supersampling
  =         // ---
  = 
  =         Self { animals, foods }
  =     }
  = }
  = 
  = impl Animal {
  =     pub fn random(rng: &mut dyn RngCore) -> Self {
  =         Self {
  =             position: rng.gen(),
  =             // ------ ^-------^
  =             // | If not for `rand-no-std`, we'd have to do awkward
  =             // | `na::Point2::new(rng.gen(), rng.gen())` instead
  =             // ---
  = 
  =             rotation: rng.gen(),
  =             speed: 0.002,
  =         }
  =     }
  = }
  = 
  = impl Food {
  =     pub fn random(rng: &mut dyn RngCore) -> Self {
  =         Self {
  =             position: rng.gen(),
  =         }
  =     }
  = }
  -->
</listing>

<p>
  A <b>getter</b> is a function that allows to access object's state — a few of
  them will come useful:
</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
  =     pub fn world(&self) -> &World {
  =         &self.world
  =     }
    }
    
    impl World {
        /* ... */
    
  =     pub fn animals(&self) -> &[Animal] {
  =         &self.animals
  =     }
  = 
  =     pub fn foods(&self) -> &[Food] {
  =         &self.foods
  =     }
    }
    
    impl Animal {
        /* ... */
    
  =     pub fn position(&self) -> na::Point2<f32> {
  =         // ------------------ ^
  =         // | No need to return a reference, because na::Point2 is Copy.
  =         // |
  =         // | (meaning: it's so small that cloning it is cheaper than
  =         // | messing with references.)
  =         // |
  =         // | Of course you don't have to memorize which types are Copy
  =         // | and which aren't - if you accidentally return a reference
  =         // | to a type that's Copy, rust-clippy will point it out and
  =         // | suggest a change :-)
  =         // ---
  = 
  =         self.position
  =     }
  = 
  =     pub fn rotation(&self) -> na::Rotation2<f32> {
  =         self.rotation
  =     }
    }
    
    impl Food {
        /* ... */
    
  =     pub fn position(&self) -> na::Point2<f32> {
  =         self.position
  =     }
    }
  -->
</listing>

<p>Nice?</p>

<ul>
  <li>
    <p>world? ✅ exists</p>
  </li>
  <li>
    <p>animals? ✅ exist</p>
  </li>
  <li>
    <p>foods? ✅ exist</p>
  </li>
</ul>

<p>Nice.</p>

<p>
  There's a lot of code still missing, but at this point we've got enough to get
  ✨ something ✨ displayed on the screen via JavaScript.
</p>

<h3>All About That JS</h3>

<p>Now, you might be wondering:</p>

<blockquote>
  <p>
    If we want to invoke this code from JavaScript, shouldn't we have
    <code>#[wasm_bindgen]</code> all over the place?
  </p>
</blockquote>

<p>... to which I'll reply:</p>

<p>Excellent question! &lt;high-fives himself/&gt;</p>

<ul>
  <li>
    <p>
      First of all, wasm-bindgen doesn't support returning vectors of custom
      types
      <a href="https://github.com/rustwasm/wasm-bindgissues/111">yet</a>:
    </p>

    <listing lang="rust" class="listing-invalid">
      <!--
        #[wasm_bindgen]
        #[derive(Debug)]
        struct World {
            pub animals: Vec<Animal>,
            pub foods: Vec<Food>,
        }
      -->
    </listing>

    <listing lang="text">
      <!--
        error[E0277]: the trait bound `Box<[Animal]>: IntoWasmAbi` is not
                      satisfied
         -\-> libs/simulation-wasm/src/lib.rs
          |
          | #[wasm_bindgen]
          | ^^^^^^^^^^^^^^^ the trait `IntoWasmAbi` is not implemented for
          |                 `Box<[Animal]>`
      -->
    </listing>

    <p>
      It's not that vectors are entirely forbidden — they can be <i>used</i>,
      just cannot be <i>exported</i>:
    </p>

    <listing lang="rust" class="listing-invalid">
      <!--
        #[wasm_bindgen]
        #[derive(Debug)]
        struct World {
            // Ok:
            animals: Vec<Animal>,
        
            // Error:
            pub foods: Vec<Food>,
        }
        
        #[wasm_bindgen]
        impl World {
            // Error:
            pub fn animals(&self) -> &[Animal] {
                todo!()
            }
        
            // Error:
            pub fn animals_cloned(&self) -> Vec<Animal> {
                todo!()
            }
        }
        
        impl World {
            // Ok:
            //
            // (Notice missing `#[wasm_bindgen]` - this is allowed, because
            // this function won't be exported to JavaScript.)
            pub fn foods(&self) -> &[Food] {
                todo!()
            }
        }
      -->
    </listing>
  </li>
  <li>
    <p>
      Second of all, even if wasm-bindgen did support vectors of custom types, I
      think that it's important to remember about
      <a href="https://en.wikipedia.org/wiki/Separation_of_concerns"
        >separation of concerns</a
      > — that is: <code>lib-simulation</code> should be all about
      <i>"how to simulate evolution"</i>, not
      <i>"how to simulate evolution <b>and</b> integrate with WebAssembly"</i>.
    </p>

    <p>
      In a second we'll be implementing <code>lib-simulation-wasm</code> — and
      if we keep <code>lib-simulation</code> frontend-agnostic, it'll be easy to
      create, say, <code>lib-simulation-bevy</code> or
      <code>lib-simulation-cli</code> next; all sharing the same simulation code
      underneath.
    </p>
  </li>
</ul>

<p>
  Ok, let's go back to <code>lib-simulation-wasm</code> — we have to make it
  aware of <code>rand</code> and <code>lib-simulation</code>:
</p>

<div class="listing-title">libs/simulation-wasm/Cargo.toml</div>

<listing lang="toml">
  <!--
    # ...
    
    [dependencies]
  = rand = "0.8"
    wasm-bindgen = "0.2"
    
  = lib-simulation = { path = "../simulation" }
                            # ^ path relative to _this_ Cargo.toml
  -->
</listing>

<p>
  Now inside <code>lib-simulation-wasm</code> we can refer to
  <code>lib_simulation</code>:
</p>

<div class="listing-title">libs/simulation-wasm/src/lib.rs</div>

<listing lang="rust">
  <!--
  = use lib_simulation as sim;
  -->
</listing>

<p>
  ... and implement a WebAssembly-aware <b>wrapper</b> (also known as
  <a href="https://en.wikipedia.org/wiki/Proxy_pattern">proxy</a>):
</p>

<div class="listing-title">libs/simulation-wasm/src/lib.rs</div>

<listing lang="rust">
  <!--
    use lib_simulation as sim;
  = use rand::prelude::*;
  = use wasm_bindgen::prelude::*;
  = 
  = #[wasm_bindgen]
  = pub struct Simulation {
  =     rng: ThreadRng,
  =     sim: sim::Simulation,
  = }
  = 
  = #[wasm_bindgen]
  = impl Simulation {
  =     #[wasm_bindgen(constructor)]
  =     pub fn new() -> Self {
  =         let mut rng = thread_rng();
  =         let sim = sim::Simulation::random(&mut rng);
  = 
  =         Self { rng, sim }
  =     }
  = }
  -->
</listing>

<p>
  As for baby steps, this looks good — let's try compiling it; surely nothing
  can fail <i>just yet</i>!
</p>

<div class="listing-title">$ wasm-pack build</div>

<listing lang="text">
  <!--
    [INFO]: Checking for the Wasm target...
    [INFO]: Compiling to Wasm...
    
       Compiling getrandom v0.2.2
    
       error: target is not supported, for more information see:
              https://docs.rs/getrandom/#unsupported-targets
    -\-> /home/pwy/.cargo/registry/src/...
    3:9
        |
    213 | /         compile_error!("target is not supported, for more information see: \\
    214 | |                         https://docs.rs/getrandom/#unsupported-targets");
        | |_________________________________________________________________________^
    
    error[E0433]: failed to resolve: use of undeclared crate or module `imp`
       -\-> /home/pwy/.cargo/registry/src/...
    5:5
        |
    235 |     imp::getrandom_inner(dest)
        |     ^^^ use of undeclared crate or module `imp`
  -->
</listing>

<p class="text-center">
  <i>ayy, ayy</i>
</p>

<p>
  Being honest, this error took me by surprise — fortunately, the
  <a href="https://docs.rs/getrandom/0.2.2/getrandom/#unsupported-targets"
    >linked page</a
  >
  describes what's going on quite well: <code>rand</code> internally depends on
  <code>getrandom</code>, which <i>does</i> support WebAssembly inside a web
  browser, but only when asked explicitly:
</p>

<div class="listing-title">libs/simulation-wasm/Cargo.toml</div>

<listing lang="toml">
  <!--
    # ...
    
    [dependencies]
    # ...
    
  = getrandom = { version = "0.2", features = ["js"] }
  -->
</listing>

<p>Let's try rebuilding now:</p>

<div class="listing-title">$ wasm-pack build</div>

<listing lang="text">
  <!--
    [INFO]: Checking for the Wasm target...
    [INFO]: Compiling to Wasm...
    
    warning: field is never read: `rng`
        ...
    
    warning: field is never read: `sim`
        ...
    
    warning: 2 warnings emitted
    
        Finished release [optimized] target(s) in 0.01s
    
    [WARN]: origin crate has no README
    [INFO]: Installing wasm-bindgen...
    [INFO]: Optimizing wasm binaries with `wasm-opt`...
    [INFO]: Optional fields missing from Cargo.toml: 'description',
            'repository', and 'license'. These are not necessary, but
             recommended
    [INFO]: :-) Done in 0.63s
    [INFO]: :-) Your wasm pkg is ready to publish at /home/pwy/Projects/...
  -->
</listing>

<p>On the JavaScript's side, we can now do:</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    import * as sim from "lib-simulation-wasm";
    
  = const simulation = new sim.Simulation();
    // --------------- ^-^
    // | For all practical purposes, this is a fancy syntax for Rust's:
    // | `Simulation::new()`
    // ---
  -->
</listing>

<p>Great, we've got the simulation engine up and running!</p>

<p>
  However it's a pretty quiet engine, that one, because currently it just
  randomizes some animals and foods, and goes quiet. To make it fun, let's
  propagate more data into JavaScript.
</p>

<p>
  To do that, we'll need a few more models - they'll be <i>kinda</i> copy-pasted
  from <code>lib-simulation</code>, but with WebAssembly in mind:
</p>

<div class="listing-title">libs/simulation-wasm/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[wasm_bindgen]
    pub struct Simulation {
        /* ... */
    }
    
  = #[wasm_bindgen]
  = #[derive(Clone, Debug)]
  = pub struct World {
  =     pub animals: Vec<Animal>,
  = }
  = 
  = #[wasm_bindgen]
  = #[derive(Clone, Debug)]
  = pub struct Animal {
  =     pub x: f32,
  =     pub y: f32,
  = }
    
    // ^ This model is smaller than `lib_simulation::Animal` - that's
    // | because a bird's position is all we need on the JavaScript's
    // | side at the moment; there's no need to map rest of the fields.
    
    /* ... */
  -->
</listing>

<p>... and two conversion methods:</p>

<div class="listing-title">libs/simulation-wasm/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[wasm_bindgen]
    impl Simulation {
        /* ... */
    }
    
  = impl From<&sim::World> for World {
  =     fn from(world: &sim::World) -> Self {
  =         let animals = world
  =             .animals()
  =             .iter()
  =             .map(Animal::from)
  =             .collect();
  = 
  =         Self { animals }
  =     }
  = }
  = 
  = impl From<&sim::Animal> for Animal {
  =     fn from(animal: &sim::Animal) -> Self {
  =         Self {
  =             x: animal.position().x,
  =             y: animal.position().y,
  =         }
  =     }
  = }
  -->
</listing>

<p>With all that in our editor, we can now add:</p>

<div class="listing-title">libs/simulation-wasm/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[wasm_bindgen]
    impl Simulation {
        /* ... */
    
  =     pub fn world(&self) -> World {
  =         World::from(self.sim.world())
  =     }
    }
    
    /* ... */
  -->
</listing>

<p>... aaaand</p>

<p class="text-center">oh my</p>

<p class="text-center">heart starts to</p>

<p class="text-center">beat faster</p>

<p class="text-center">as i execute</p>

<p class="text-center">
  <code>$ wasm-pack build</code>
</p>

<p class="text-center">aaaaand</p>

<p class="text-center"><i>oh no</i> 😢</p>

<listing lang="text">
  <!--
    error[E0277]: the trait bound `Box<[Animal]>: IntoWasmAbi` is not
                  satisfied
     -\-> libs/simulation-wasm/src/lib.rs
      |
    3 | #[wasm_bindgen]
      | ^^^^^^^^^^^^^^^ the trait `IntoWasmAbi` is not implemented for
      |                 `Box<[Animal]>`
  -->
</listing>

<p>
  Ah, we <i>know</i> this message: it's because wasm-pack doesn't support
  vectors of custom types!
</p>

<p>Let's roll back and analyze what happened — wasm-pack gave up here:</p>

<div class="listing-title">libs/simulation-wasm/src/lib.rs</div>

<listing lang="rust">
  <!--
    #[wasm_bindgen]
    #[derive(Clone, Debug)]
    pub struct World {
        pub animals: Vec<Animal>,
        //           ^---------^
    }
  -->
</listing>

<p>
  ... if we can't rely on wasm-pack here, is there some other solution we could
  use? oh my — <b><i>yes</i></b
  >!
</p>

<h3>Serde Be My Guide</h3>

<p>Meet <a href="https://serde.rs/">Serde</a>:</p>

<blockquote>
  <p>
    Serde is a framework for serializing and deserializing Rust data structures
    efficiently and generically.
  </p>
</blockquote>

<p>
  Put another way: Serde takes a <code>struct Foo { }</code> and transforms it
  into (or from) JSON, YAML, or any other format you'd like (and there are
  <i>a lot</i> of them!).
</p>

<p>
  If you hadn't had the opportunity to use Serde yet, here's a demo (unrelated
  to our simulation):
</p>

<div class="listing-title">
  <a
    href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ece8e0d69098f8c5cfa74e25941764db"
    >open in playground</a
  >
</div>

<listing lang="rust">
  <!--
    use serde::Serialize;
    
    #[derive(Serialize)]
    struct User {
        name: &'static str,
        friends: Vec<&'static str>,
    }
    
    fn main() {
        let user = User {
            name: "Patryk",
            friends: vec![
                "Chinchilla named Flora",
                "Oak named Bartek",
            ],
        };
    
        println!(
            "JSON:\\n{}\\n",
            serde_json::to_string_pretty(&user).unwrap(),
        );
    
        println!(
            "YAML:\\n{}",
            serde_yaml::to_string(&user).unwrap(),
        );
    }
  -->
</listing>

<p>
  Installing Serde and making it compatible with <code>wasm-bindgen</code> is as
  easy as:
</p>

<div class="listing-title">libs/simulation-wasm/Cargo.toml</div>

<listing lang="toml">
  <!--
    # ...
    
    [dependencies]
  = serde = { version = "1.0", features = ["derive"] }
    # ------------------------------------- ^----^
    # | Enables the `#[derive(Serialize)]` and `#[derive(Deserialize)]`
    # | macros.
    # |
    # | Without this feature-switch, we'd have to write `impl Serialize` by
    # | hand, I guess, which ain't no fun.
    # ---
    
  = wasm-bindgen = { version = "0.2", features = ["serde-serialize"] }
    # -------------------------------------------- ^-------------^
    # | Enables `JsValue::from_serde()` that you'll see in a moment.
    # ---
    
    # ...
  -->
</listing>

<p>
  Since we don't want for wasm-bindgen to serialize our two models anymore,
  let's drop their <code>#[wasm_bindgen]</code>:
</p>

<div class="listing-title">libs/simulation-wasm/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
  = 
    #[derive(Clone, Debug)]
    pub struct World {
        pub animals: Vec<Animal>,
    }
    
  = 
    #[derive(Clone, Debug)]
    pub struct Animal {
        pub x: f32,
        pub y: f32,
    }
    
    /* ... */
  -->
</listing>

<p>... make them serializable by Serde:</p>

<div class="listing-title">libs/simulation-wasm/src/lib.rs</div>

<listing lang="rust">
  <!--
  = use serde::Serialize;
    
    /* ... */
    
  = #[derive(Clone, Debug, Serialize)]
    pub struct World {
        pub animals: Vec<Animal>,
    }
    
  = #[derive(Clone, Debug, Serialize)]
    pub struct Animal {
        pub x: f32,
        pub y: f32,
    }
    
    /* ... */
  -->
</listing>

<p>... and adjust <code>Simulation::world()</code>:</p>

<div class="listing-title">libs/simulation-wasm/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[wasm_bindgen]
    impl Simulation {
        /* ... */
    
  =     pub fn world(&self) -> JsValue {
  =         let world = World::from(self.sim.world());
  =         JsValue::from_serde(&world).unwrap()
  =     }
    }
    
    /* ... */
  -->
</listing>

<p>
  <span class="text-rainbow">Question time</span>: I'll take one from the
  audience.
</p>

<blockquote>
  <p>
    What happened? Can't wasm-pack do it on its own? Would you rather hug a
    horse-sized duck or 100 duck-sized horses?
  </p>
</blockquote>

<ol>
  <li>
    <p>
      What happened is that instead of letting wasm-pack serialize our models
      using <b>its own</b> serialization algorithm, we've <i>forced</i> them to
      be serialized into <b>JSON</b> — via <code>JsValue</code>.
    </p>

    <p>
      If not for Serde, wasm-pack would use a custom, binary format that's more
      compact…​ had it only supported vectors of custom types, that is.
    </p>
  </li>
  <li>
    <p>
      My guess is that while wasm-pack <i>could</i> opt for Serde by default,
      it's essentially a trade-off: JSON is more versatile, but its output tends
      to be longer than what a binary format can achieve, so it makes sense for
      wasm-pack to use the smaller format by default.
    </p>
  </li>
  <li>
    <p>I'd definitely hug a horse-sized duck - what a sublime creature!</p>
  </li>
</ol>

<p>
  Let's rebuild our Rust code (remember to run this command inside
  <code>libs/simulation-wasm</code>):
</p>

<div class="listing-title">$ wasm-pack build</div>

<listing lang="text">
  <!--
    [INFO]: Checking for the Wasm target...
    [INFO]: Compiling to Wasm...
    
    warning: field is never read: `rng`
        ...
    
    warning: 1 warning emitted
    
        Finished release [optimized] target(s) in 0.02s
    
    ...
  -->
</listing>

<p>K, nice.</p>

<p>So, in essence, what we've created is a function that returns a JSON:</p>

<listing lang="json">
  <!--
    {
      "animals": [
        { "x": 0.2, "y": 0.1 },
        { "x": 0.3, "y": 0.7 }
      ]
    }
  -->
</listing>

<p>... which can be then easily parsed by the web browser:</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    import * as sim from "lib-simulation-wasm";
    
    const simulation = new sim.Simulation();
  = const world = simulation.world();
    // --------------------- ^---^
    // | Parsing already happens inside this automatically-generated
    // | function - we don't have to do anything more in here.
    // ---
  -->
</listing>

<p>
  All this should work…​ in theory; but how can we be <i>sure</i> our
  <code>world</code> contains any meaningful data? By using our own eyes!
</p>

<p>
  Most browsers expose a thing called <code>developer console</code> (also known
  as <code>developer tools</code>), which you should be able to access by
  pressing <code>F12</code>:
</p>

<p class="text-dim">
  (<a
    href="https://support.apple.com/guide/safari/use-the-developer-tools-in-the-develop-menu-sfri20948/mac"
    >Safari users might require an extra hoop.</a
  >)
</p>

<figure class="sketch w-90">
  <img
    src="{{ assets }}/e24b0b5a-9e3b-4e14-a13e-f0529b35a05c.png"
  />
</figure>

<p>What can we do with this console? We can print stuff to it:</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
  = console.log(world);
  -->
</listing>

<p>
  <i
    >(I assume <code>npm run start</code> is still working in the
    background — if it's not, remember to re-launch it.)</i
  >
</p>

<figure class="sketch w-90">
  <img
    src="{{ assets }}/dc4ebef7-578b-4377-9a57-61d88aaac214.png"
  />
</figure>

<aside class="note">
  <listing lang="javascript">
    <!--
      // Nobody can stop us now:
      console.log(Array(16).join('wat' - 1) + ' Batman!');
      
      // Haha, ha:
      console.log(console.log);
    -->
  </listing>
</aside>

<p>
  Nice; now that we know the positions of animals, it means we can draw them!
</p>

<h2 id="hello-graphics">
  <a href="#hello-graphics">Hello, Graphics!</a>
</h2>

<p>
  Drawing stuff in HTML + JavaScript is relatively painless - we'll use a thing
  called
  <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial"
    ><code>&lt;canvas&gt;</code></a
  >:
</p>

<div class="listing-title">www/index.html</div>

<listing lang="html">
  <!--
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="utf-8">
        <title>Hello wasm-pack!</title>
      </head>
    
      <body>
  =     <canvas id="viewport"></canvas>
        <script src="./bootstrap.js"></script>
      </body>
    </html>
  -->
</listing>

<p>
  Our canvas has an attribute called <code>id</code> — this attribute is used to
  <i>name</i> tags, so that they can be easily found from inside JavaScript:
</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
  = const viewport = document.getElementById('viewport');
    // ------------- ^------^
    // | `document` is a global object that allows to access and modify
    // | current page (e.g. create or remove stuff from it).
    // ---
  -->
</listing>

<p>
  If you want to take a moment to digest what's happening, feel free to
  <code>console.log(viewport);</code> and click through its properties - there's
  a lot of them!
</p>

<p>
  To display stuff on <code>&lt;canvas&gt;</code>, we have to request for a
  specific <i>drawing mode</i> (think: 2D vs 3D):
</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
  = const ctxt = viewport.getContext('2d');
  -->
</listing>

<p>So far, so good!</p>

<aside class="note">
  <p>
    For reference, our <code>ctxt</code> here is of type
    <a
      href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D"
      ><code>CanvasRenderingContext2D</code></a
    >.
  </p>
</aside>

<p>
  There are many methods and properties we can invoke on
  <code>ctxt</code> — let's start by investigating <code>fillStyle</code> and
  <code>fillRect()</code>:
</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
    // ---
    // | Determines color of the upcoming shape.
    // - v-------v
  = ctxt.fillStyle = 'rgb(255, 0, 0)';
    // ------------------ ^-^ -^ -^
    // | Each of those three parameters is a number from range 0 up to 255:
    // |
    // | rgb(0, 0, 0) = black
    // |
    // | rgb(255, 0, 0) = red
    // | rgb(0, 255, 0) = green
    // | rgb(0, 0, 255) = blue
    // |
    // | rgb(255, 255, 0) = yellow
    // | rgb(0, 255, 255) = cyan
    // | rgb(255, 0, 255) = magenta
    // |
    // | rgb(128, 128, 128) = gray
    // | rgb(255, 255, 255) = white
    // ---
    
  = ctxt.fillRect(10, 10, 100, 50);
    // ---------- X   Y   W    H
    // | Draws rectangle filled with color determined by `fillStyle`.
    // |
    // | X = position on the X axis (left-to-right)
    // | Y = position on the Y axis (top-to-bottom)
    // | W = width
    // | X = height
    // |
    // | (unit: pixels)
    // ---
  -->
</listing>

<p>
  Launching this code should make our <code>&lt;canvas&gt;</code> print a red
  rectangle:
</p>

<figure class="sketch w-20">
  <img
    src="{{ assets }}/25e0b526-015d-4db5-8c1e-5516ef684b84.png"
  />
</figure>

<p>Ah, Mondrian would be so proud — I tell you: <i>we're going places!</i></p>

<aside class="note">
  <p>
    To be on the same page, <code>&lt;canvas&gt;</code>-'s coordinate system is:
  </p>

  <figure class="sketch w-60">
    <img
      src="{{ assets }}/sketches/3b2960ca-6511-4686-9acd-a384969e257a.svg"
    />
  </figure>
</aside>

<h3>It’s My Data</h3>

<p>
  Now that we know how to draw rectangles, let's bring our data back into the
  picture:
</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    import * as sim from "lib-simulation-wasm";
    
    const simulation = new sim.Simulation();
  = const viewport = document.getElementById('viewport');
  = const ctxt = viewport.getContext('2d');
  = 
  = ctxt.fillStyle = 'rgb(0, 0, 0)';
  = 
  = for (const animal of simulation.world().animals) {
  =     ctxt.fillRect(animal.x, animal.y, 15, 15);
  = }
  -->
</listing>

<p>... and:</p>

<figure class="sketch w-10">
  <img
    src="{{ assets }}/eb853ead-5d7e-4c0d-9e6a-ca26bb515a10.png"
  />
</figure>

<p>
  Well, ain't that a bummer — what happened? Let's investigate our data once
  again:
</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
  = console.log(simulation.world().animals);
  -->
</listing>

<figure class="sketch w-90">
  <img
    src="{{ assets }}/dc4ebef7-578b-4377-9a57-61d88aaac214.png"
  />
</figure>

<p>
  Ah, positions of our animals belong to range <code>&lt;0.0, 1.0&gt;</code>,
  while <code>&lt;canvas&gt;</code> expects coordinates in the unit of a
  <b>pixel</b> — we can fix this by <i>scaling</i> the numbers while rendering:
</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
    const viewport = document.getElementById('viewport');
  = const viewportWidth = viewport.width;
  = const viewportHeight = viewport.height;
    
    /* ... */
    
    for (const animal of simulation.world().animals) {
  =     ctxt.fillRect(
  =         animal.x * viewportWidth,
  =         animal.y * viewportHeight,
  =         15,
  =         15,
  =     );
    }
  -->
</listing>

<p>... which gets us:</p>

<figure class="sketch w-40">
  <img
    src="{{ assets }}/2e91178c-5441-4f66-9fbf-001d76ad752d.png"
  />
</figure>

<aside class="note">
  <p>
    If you've got an HiDPI display, you might notice that the canvas looks
    blurry — please do not adjust your television set, all's "correct".
  </p>

  <p>
    It's because most, if not all, browsers render canvases without adjusting
    for screen's pixel density, and then artificially <b>upscale</b> the image
    to match the actual resolution of the screen.
  </p>

  <p>
    Overcoming this inconvenience requires a bit of a trickery that boils down
    to enlarging the canvas manually before any drawing happens, as to "correct"
    the browser's default behavior:
  </p>

  <listing lang="javascript">
    <!--
      /* ... */
      
      const viewportWidth = viewport.width;
      const viewportHeight = viewport.height;
      
      const viewportScale = window.devicePixelRatio || 1;
      // ------------------------------------------ ^^^^
      // | Syntax-wise, it's like: .unwrap_or(1)
      // |
      // | This value determines how much physical pixels there are per
      // | each single pixel on a canvas.
      // |
      // | Non-HiDPI displays usually have a pixel ratio of 1.0, which
      // | means that drawing a single pixel on a canvas will lighten-up
      // | exactly one physical pixel on the screen.
      // |
      // | My display has a pixel ratio of 2.0, which means that for each
      // | single pixel drawn on a canvas, there will be two physical
      // | pixels modified by the browser.
      // ---
      
      // The Trick, part 1: we're scaling-up canvas' *buffer*, so that it
      // matches the screen's pixel ratio
      viewport.width = viewportWidth * viewportScale;
      viewport.height = viewportHeight * viewportScale;
      
      // The Trick, part 2: we're scaling-down canvas' *element*, because
      // the browser will automatically multiply it by the pixel ratio in
      // a moment.
      //
      // This might seem like a no-op, but the maneuver lies in the fact
      // that modifying a canvas' element size doesn't affect the canvas'
      // buffer size, which internally *remains* scaled-up:
      //
      // ----------- < our entire page
      // |         |
      // |   ---   |
      // |   | | < | < our canvas
      // |   ---   |   (size: viewport.style.width & viewport.style.height)
      // |         |
      // -----------
      //
      // Outside the page, in the web browser's memory:
      //
      // ----- < our canvas' buffer
      // |   | (size: viewport.width & viewport.height)
      // |   |
      // -----
      viewport.style.width = viewportWidth + 'px';
      viewport.style.height = viewportHeight + 'px';
      
      const ctxt = viewport.getContext('2d');
      
      // Automatically scales all operations by `viewportScale` - otherwise
      // we'd have to `* viewportScale` everything by hand
      ctxt.scale(viewportScale, viewportScale);
      
      // Rest of the code follows without any changes
      ctxt.fillStyle = 'rgb(0, 0, 0)';
      
      for (const animal of simulation.world().animals) {
          ctxt.fillRect(
              animal.x * viewportWidth,
              animal.y * viewportHeight,
              15,
              15,
          );
      }
    -->
  </listing>

  <p>As promised, this gets us a sharp image:</p>

  <figure class="sketch w-40">
    <img
      src="{{ assets }}/4248d354-2b4c-420b-87c1-c1d249cdff84.png"
    />
  </figure>
</aside>

<p>
  So…​ would you believe it, someone told me that squares are
  <b>not fashionable</b> anymore!
</p>

<p>Apparently ▼ triangles ▲ are all the rage, so let's try drawing one.</p>

<p>
  Somewhat unluckily, JavaScript doesn't provide any method for printing
  triangles, requiring us to draw them manually vertex-by-vertex instead.
</p>

<p>To get a grip of how it works, let's start with a hard-coded example:</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
    // Starts drawing a polygon
  = ctxt.beginPath();
    
    // Moves cursor at x=50, y=0
  = ctxt.moveTo(50, 0);
    
    // Draws a line from (50,0) to (100,50) and moves cursor there
    // (this gets us the right side of our triangle)
  = ctxt.lineTo(100, 50);
    
    // Draws a line from (100,50) to (0,50) and moves cursor there
    // (this gets us the bottom side of our triangle)
  = ctxt.lineTo(0, 50);
    
    // Draws a line from (0,50) to (50,0) and moves cursor there
    // (this gets us the left side of our triangle)
  = ctxt.lineTo(50, 0);
    
    // Fills our triangle with a black color
    //
    // (there's also `ctxt.stroke();`, which would render only our triangle's
    // outline instead.)
  = ctxt.fillStyle = 'rgb(0, 0, 0)';
  = ctxt.fill();
  -->
</listing>

<p>... aaaand, what a beauty!</p>

<figure class="sketch w-30">
  <img
    src="{{ assets }}/bc321864-81b2-4f69-90c0-57edda4ae04f.png"
  />
</figure>

<p>
  Since drawing a triangle requires a few steps, to make it easier to use, let's
  make it a function:
</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
  = function drawTriangle(ctxt, x, y, size) {
  =     ctxt.beginPath();
  =     ctxt.moveTo(x, y);
  =     ctxt.lineTo(x + size, y + size);
  =     ctxt.lineTo(x - size, y + size);
  =     ctxt.lineTo(x, y);
  = 
  =     ctxt.fillStyle = 'rgb(0, 0, 0)';
  =     ctxt.fill();
  = }
  = 
  = drawTriangle(ctxt, 50, 0, 50);
  -->
</listing>

<p>... or, a bit more idiomatic:</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
    // ---
    // | The type of our `ctxt`.
    // v------------------ v
  = CanvasRenderingContext2D.prototype.drawTriangle = function (x, y, size) {
  =     this.beginPath();
  =     this.moveTo(x, y);
  =     this.lineTo(x + size, y + size);
  =     this.lineTo(x - size, y + size);
  =     this.lineTo(x, y);
  = 
  =     this.fillStyle = 'rgb(0, 0, 0)';
  =     this.fill();
  = };
  = 
  = ctxt.drawTriangle(50, 0, 50);
  -->
</listing>

<aside class="note">
  <p>
    JavaScripts allows for methods to be created willy-nilly at runtime - a
    similar code in Rust would require creating a trait:
  </p>

  <listing lang="rust">
    <!--
      trait DrawTriangle {
          fn draw_triangle(&mut self, x: f32, y: f32, size: f32);
      }
      
      impl DrawTriangle for CanvasRenderingContext2D {
          fn draw_triangle(&mut self, x: f32, y: f32, size: f32) {
              self.begin_path();
              /* ... */
          }
      }
    -->
  </listing>
</aside>

<p>Equipped with <code>.drawTriangle()</code>, we can now do:</p>

<div class="listing-title">www/index.html</div>

<listing lang="html">
  <!--
    <!-- ... -\->
  = <canvas id="viewport" width="800" height="800"></canvas>
    <!-- ... -\->
  -->
</listing>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
  = for (const animal of simulation.world().animals) {
  =     ctxt.drawTriangle(
  =         animal.x * viewportWidth,
  =         animal.y * viewportHeight,
  =         0.01 * viewportWidth,
  =     );
  = }
  -->
</listing>

<figure class="sketch w-30">
  <img
    src="{{ assets }}/37718e09-3278-44ef-a104-28cb5486e4ff.png"
  />
</figure>

<aside class="note">
  <p>
    If those triangles look too small for you, feel free to adjust the canvas'
    size and the <code>0.01</code> parameter.
  </p>
</aside>

<p>Nice 😎</p>

<p>
  ... and you know what would be <i>even nicer</i>? If they were <b>rotated</b>!
</p>

<h3>Vertices Go Brr</h3>

<p>
  We already have a field called <code>rotation</code> inside
  <code>lib-simulation</code>:
</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct Animal {
        /* ... */
        rotation: na::Rotation2<f32>,
        /* ... */
    }
  -->
</listing>

<p>... so all we've gotta do is to pass it into JavaScript:</p>

<div class="listing-title">libs/simulation-wasm/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Clone, Debug, Serialize)]
    pub struct Animal {
        pub x: f32,
        pub y: f32,
  =     pub rotation: f32,
    }
    
    /* ... */
    
    impl From<&sim::Animal> for Animal {
        fn from(animal: &sim::Animal) -> Self {
            Self {
                x: animal.position().x,
                y: animal.position().y,
  =             rotation: animal.rotation().angle(),
            }
        }
    }
  -->
</listing>

<p>... now <code>wasm-pack build</code>:</p>

<div class="listing-title">$ wasm-pack build</div>

<listing lang="text">
  <!--
    ...
    [INFO]: :-) Done in 2.42s
    [INFO]: :-) Your wasm pkg is ready to publish at /home/pwy/Projects/...
  -->
</listing>

<p>... and we're back to JavaScript.</p>

<p>
  Since the rotation will be different for each triangle, we'll need to have
  another parameter:
</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
  = CanvasRenderingContext2D.prototype.drawTriangle =
  =     function (x, y, size, rotation) {
            /* ... */
  =     };
    
    /* ... */
  -->
</listing>

<p>Now, intuitively, what we're looking for is:</p>

<figure class="sketch w-80">
  <img
    src="{{ assets }}/sketches/d50a7a76-abc0-415c-b43c-dff76f18b242.svg"
  />
</figure>

<p>... generalized for <i>any</i> angle.</p>

<h3>Vertices Go Brrr (using math)</h3>

<p>
  Let's bring back our triangle — this time, together with its
  <b>circumscribed circle</b>:
</p>

<figure class="sketch w-40">
  <img
    src="{{ assets }}/sketches/0b4f3862-3b22-4499-a4b1-3d29099c5e76.svg"
  />
</figure>

<p>
  Under this circumstances, I'd casually describe rotating as
  <i>moving each vertex alongside the circle "with" certain angle</i>:
</p>

<figure class="sketch w-50">
  <img
    src="{{ assets }}/sketches/52ce2085-216f-4ff9-85b7-7dd0c5f44d26.svg"
  />
</figure>

<p>
  How do we know <i>where to</i> move those points? Well, whenever there's a
  circle involved, there's probably a fair share of trigonometry happening
  underneath — it's certainly true this time!
</p>

<p>
  You might've heard of <code>cos()</code> and <code>sin()</code> — while they
  aren't that impressive plotted separately:
</p>

<figure class="sketch w-90">
  <img
    src="{{ assets }}/sketches/0ee9c7b5-80a5-4c5e-92e0-f72104f4aeca.svg"
  />
</figure>

<p>
  ... when we juxtapose <i>both</i> of them on a circle, we might just spot that
  what <code>cos(angle)</code> returns in practice is the
  <code>y</code> coordinate of a point "rotated" with given angle — and,
  similarly, <code>sin(angle)</code> gives the <code>x</code> coordinate:
</p>

<figure class="sketch w-50">
  <img
    src="{{ assets }}/sketches/dd44883a-ab9b-4ed7-be1e-b97d4b50e128.svg"
  />
</figure>

<aside class="note">
  <p>
    I'm using quotes around <i>rotated</i>, because technically it makes little
    to no sense to talk about rotation of a <i>point</i> — but hopefully the
    mathematicians among you will forgive me for I have semantically-sinned in a
    <i>good faith</i>.
  </p>

  <p>
    Also, foreshadowing a bit: we're actually going to use
    <code>x = -sin(angle)</code>, because Nalgebra understands rotations
    counterclockwise.
  </p>
</aside>

<p>Speaking in code-terms — if what we have currently is:</p>

<listing lang="javascript">
  <!--
    this.moveTo(x, y);
  -->
</listing>

<p>
  ... then rotating the <code>x</code> coordinate requires applying
  <code>- sin()</code>:
</p>

<listing lang="javascript">
  <!--
    this.moveTo(
  =     x - Math.sin(rotation) * size,
        y,
    );
  -->
</listing>

<p>
  ... and rotating the <code>y</code> coordinate requires applying
  <code>+ cos()</code>:
</p>

<listing lang="javascript">
  <!--
    this.moveTo(
        x - Math.sin(rotation) * size,
  =     y + Math.cos(rotation) * size,
    );
  -->
</listing>

<p>
  ... where <code>rotation</code> is measured in <b>radians</b> — that is,
  <code>&lt;0°, 360°&gt;</code> shrank to <code>&lt;0, 2 * PI&gt;</code>:
</p>

<ul>
  <li>
    <p>0° ⇒ <code>rotation = 0</code></p>
  </li>
  <li>
    <p>180° ⇒ <code>rotation = PI</code></p>
  </li>
  <li>
    <p>360° ⇒ <code>rotation = 2 * PI</code></p>
  </li>
  <li>
    <p>90° ⇒ 180° / 2 ⇒ <code>rotation = PI / 2</code></p>
  </li>
  <li>
    <p>45° ⇒ 180° / 4 ⇒ <code>rotation = PI / 4</code></p>
  </li>
  <li>
    <p>and so on.</p>
  </li>
</ul>

<p>Okie — one vertex done:</p>

<figure class="sketch w-40">
  <img
    src="{{ assets }}/sketches/e0fa1f63-964b-49ba-9e32-4eab5d249a13.svg"
  />
</figure>

<p>... two more to go!</p>

<p>
  Since the entire circle takes 360° and we've got three vertices to draw, then
  each vertex is going to occupy 360° / 3 = 120°; considering that first vertex
  lays on 0°, the second vertex is going to be located at 120°.
</p>

<p>A quick conversion to radians, using proportions:</p>

<listing lang="text">
  <!--
    { 2 * PI = 360°
    {      x = 120°

             ^
             |
             v

    360° * x = 2 * PI * 120°    | divide by 2
    180° * x = PI * 120°        | divide by 180°
           x = PI * 120° / 180° | simplify
           x = PI * 2 / 3       | shuffle constant to left
           x = 2 / 3 * PI       | enjoy
  -->
</listing>

<p>... gives us:</p>

<listing lang="javascript">
  <!--
    this.moveTo(
        x - Math.sin(rotation) * size,
        y + Math.cos(rotation) * size,
    );
    
  = this.lineTo(
  =     x - Math.sin(rotation + 2.0 / 3.0 * Math.PI) * size,
  =     y + Math.cos(rotation + 2.0 / 3.0 * Math.PI) * size,
  = );
  -->
</listing>

<figure class="sketch w-40">
  <img
    src="{{ assets }}/sketches/bce2d60a-cd7e-4666-84f3-76ef6dbb043a.svg"
  />
</figure>

<p>Similarly, for the third vertex:</p>

<listing lang="text">
  <!--
    2 * PI = 360°
         x = 120° + 120°
    
    /* ... */
    
    x = 4 / 3 * PI
  -->
</listing>

<p>... giving us:</p>

<listing lang="javascript">
  <!--
    this.moveTo(
        x - Math.sin(rotation) * size,
        y + Math.cos(rotation) * size,
    );
    
    this.lineTo(
        x - Math.sin(rotation + 2.0 / 3.0 * Math.PI) * size,
        y + Math.cos(rotation + 2.0 / 3.0 * Math.PI) * size,
    );
    
  = this.lineTo(
  =     x - Math.sin(rotation + 4.0 / 3.0 * Math.PI) * size,
  =     y + Math.cos(rotation + 4.0 / 3.0 * Math.PI) * size,
  = );
  -->
</listing>

<figure class="sketch w-40">
  <img
    src="{{ assets }}/sketches/66781628-c317-4a0c-98ce-b5317abf4c4c.svg"
  />
</figure>

<aside class="note">
  <p>
    For what it's worth, instead of <code>+ 4.0 / 3.0</code>, we could've also
    used <code>- 2.0 / 3.0</code> (meaning "60° counterclockwise from the top
    vertex"):
  </p>

  <listing lang="javascript">
    <!--
      this.lineTo(
          x - Math.sin(rotation - 2.0 / 3.0 * Math.PI) * size,
          y + Math.cos(rotation - 2.0 / 3.0 * Math.PI) * size,
      );
    -->
  </listing>

  <p>
    ... as both
    <a
      href="https://www.wolframalpha.com/input/?i=sin%28x+-+2%2F3+*+pi%29+%3D+sin%28x+%2B+4%2F3+*+pi%29"
      >are identical</a
    >.
  </p>
</aside>

<p>
  As you might see in the drawing, now we're missing only the very last edge
  going from the third vertex back into the first:
</p>

<figure class="sketch w-40">
  <img
    src="{{ assets }}/sketches/13650115-7ac4-47d2-a1d5-bcf1c3c7b370.svg"
  />
</figure>

<p>... so:</p>

<listing lang="javascript">
  <!--
    /* ... */
    
    this.lineTo(
        x - Math.sin(rotation + 4.0 / 3.0 * Math.PI) * size,
        y + Math.cos(rotation + 4.0 / 3.0 * Math.PI) * size,
    );
    
  = this.lineTo(
  =     x - Math.sin(rotation) * size,
  =     y + Math.cos(rotation) * size,
  = );
  -->
</listing>

<p>In all its glory, our code is:</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
  = CanvasRenderingContext2D.prototype.drawTriangle =
  =     function (x, y, size, rotation) {
  =         this.beginPath();
  = 
  =         this.moveTo(
  =             x - Math.sin(rotation) * size,
  =             y + Math.cos(rotation) * size,
  =         );
  = 
  =         this.lineTo(
  =             x - Math.sin(rotation + 2.0 / 3.0 * Math.PI) * size,
  =             y + Math.cos(rotation + 2.0 / 3.0 * Math.PI) * size,
  =         );
  = 
  =         this.lineTo(
  =             x - Math.sin(rotation + 4.0 / 3.0 * Math.PI) * size,
  =             y + Math.cos(rotation + 4.0 / 3.0 * Math.PI) * size,
  =         );
  = 
  =         this.lineTo(
  =             x - Math.sin(rotation) * size,
  =             y + Math.cos(rotation) * size,
  =         );
  = 
  =         this.stroke();
  =     };
  = 
  = ctxt.drawTriangle(50, 50, 25, Math.PI / 4);
  -->
</listing>

<p>Does it work? Apparently:</p>

<figure class="sketch w-20">
  <img
    src="{{ assets }}/7c0a009c-202c-4666-ac69-e6c03cf75bae.png"
  />
</figure>

<p>
  ... but it's kinda hard to spot that it's rotated — what if we
  <i>extruded</i> one of the vertices?
</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
    CanvasRenderingContext2D.prototype.drawTriangle =
        function (x, y, size, rotation) {
            this.beginPath();
    
            this.moveTo(
  =             x - Math.sin(rotation) * size * 1.5,
  =             y + Math.cos(rotation) * size * 1.5,
            );
    
            /* ... */
    
            this.lineTo(
  =             x - Math.sin(rotation) * size * 1.5,
  =             y + Math.cos(rotation) * size * 1.5,
            );
    
            this.stroke();
        };
    
    /* ... */
  -->
</listing>

<p>There, better:</p>

<figure class="sketch w-30">
  <img
    src="{{ assets }}/e53c3146-b334-4b4d-8492-09b6c37b4293.png"
  />
</figure>

<h3>Animals Go Brrr</h3>

<p>
  Now that we are able to render rotated triangles, we can adjust our code from
  before:
</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
    for (const animal of simulation.world().animals) {
        ctxt.drawTriangle(
            animal.x * viewportWidth,
            animal.y * viewportHeight,
            0.01 * viewportWidth,
  =         animal.rotation,
        );
    }
  -->
</listing>

<p>... which gives us:</p>

<figure class="sketch w-60">
  <img
    src="{{ assets }}/e5597f34-11e5-48cc-b76c-329f0ee543d6.png"
  />
</figure>

<p>Neat; high five, <span class="text-rainbow">pal</span> — we've earned it!</p>

<h2 id="stepping-stones">
  <a href="#stepping-stones">step()-ping stones</a>
</h2>

<p>
  Stationary triangles are cool — <i>obviously!</i> — but
  <b>moving</b> triangles are even better.
</p>

<p>
  Our birds don't have brains, but they do have rotation & speed — this means we
  can simulate physics on them, even if they won't be able to interact with
  their environment <i>yet</i>:
</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
        /// Performs a single step - a single second, so to say - of our
        /// simulation.
  =     pub fn step(&mut self) {
  =         for animal in &mut self.world.animals {
  =             animal.position += animal.rotation * animal.speed;
  =         }
  =     }
    }
    
    /* ... */
  -->
</listing>

<p>One <code>cargo check</code> after:</p>

<div class="listing-title">$ cargo check</div>

<listing lang="text">
  <!--
    error[E0277]: cannot multiply `Rotation<f32, 2_usize>` by `f32`
       |
       |             animal.position += animal.rotation * animal.speed;
       |                                                ^
       |             -----------------------------------|
       |             no implementation for `Rotation<f32, 2_usize> * f32`
       |
       = help: the trait `Mul<f32>` is not implemented for
         `Rotation<f32, 2_usize>`
  -->
</listing>

<p>
  Hmm, nalgebra doesn't provide <code>Rotation2 * f32</code> — maybe we can use
  a vector instead?
</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
  = animal.position += animal.rotation * na::Vector2::new(0.0, animal.speed);
    /* ... */
  -->
</listing>

<div class="listing-title">$ cargo check</div>

<listing lang="text">
  <!--
    Finished dev [unoptimized + debuginfo] target(s) in 18.04s
  -->
</listing>

<p>Bingo!</p>

<aside class="note">
  <blockquote>
    <p>Wait, wait — why <code>::new(0.0, animal.speed)</code>?</p>
  </blockquote>

  <p>
    nalgebra assumes no specific <i>point of reference</i> — instruction
    <code>please move at 45°</code> doesn't contain enough information to
    actually compute where the birdie should get moved:
    <i>it's 45° according to which axis</i>?
  </p>

  <figure class="sketch w-80">
    <img
      src="{{ assets }}/sketches/2b162f23-e9ab-4c46-8f61-0ce617366de0.svg"
    />
  </figure>

  <p>
    So that's the issue our <code>::new(0.0, animal.speed)</code> solves — it
    says that we're interested in rotating relative to the <code>y</code> axis,
    that is: a bird with rotation of 0° will fly <b>upwards</b>.
  </p>

  <p>
    All said, this is a rather arbitrary decision that just neatly aligns with
    how we render triangles on <code>&lt;canvas&gt;</code>; we might've as well
    done e.g. <code>::new(-animal.speed, 0.0)</code> and adjust our
    <code>drawTriangle()</code> to account for that.
  </p>
</aside>

<p>
  With <code>step()</code> inside <code>lib-simulation</code>, we can now expose
  it via <code>lib-simulation-wasm</code>:
</p>

<div class="listing-title">libs/simulation-wasm/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[wasm_bindgen]
    impl Simulation {
        /* ... */
    
  =     pub fn step(&mut self) {
  =         self.sim.step();
  =     }
    }
    
    /* ... */
  -->
</listing>

<p>... and compile:</p>

<div class="listing-title">$ wasm-pack build</div>

<listing lang="text">
  <!--
    ....
    [INFO]: :-) Done in 3.58s
    [INFO]: :-) Your wasm pkg is ready to publish at /home/pwy/Projects/...
  -->
</listing>

<p>
  As for invoking <code>.step()</code> from JavaScript — while in some languages
  we might've used a loop:
</p>

<listing lang="javascript" class="listing-invalid">
  <!--
    /* ... */
    
    while (true) {
         ctxt.clearRect(0, 0, viewportWidth, viewportHeight);
    
         simulation.step();
    
         for (const animal of simulation.world().animals) {
             ctxt.drawTriangle(
                 animal.x * viewportWidth,
                 animal.y * viewportHeight,
                 0.01 * viewportWidth,
                 animal.rotation,
             );
         }
    }
  -->
</listing>

<p>
  ... the web browser environment makes it a bit harder, because our code
  <b>mustn't block</b>. That's because when JavaScript is working, browser waits
  for it to finish, hanging the tab and preventing user from interacting with
  the page.
</p>

<p>
  The more time it takes for the code to complete, the longer the tab is
  blocked — it's essentially <i>single-threaded</i>. So if we wrote
  <code>while (true) { …​ }</code>, the browser would just hang the tab forever,
  patiently waiting for the code to finish working.
</p>

<p>
  Instead of blocking, we can use a function called
  <a
    href="https://developer.mozilla.org/pl/docs/Web/API/Window/requestAnimationFrame"
    ><code>requestAnimationFrame()</code></a
  > — it <b>schedules</b> a function to be executed just before the next frame
  is drawn, and finishes immediately:
</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
  = function redraw() {
  =     ctxt.clearRect(0, 0, viewportWidth, viewportHeight);
  = 
  =     simulation.step();
  = 
  =     for (const animal of simulation.world().animals) {
  =         ctxt.drawTriangle(
  =             animal.x * viewportWidth,
  =             animal.y * viewportHeight,
  =             0.01 * viewportWidth,
  =             animal.rotation,
  =         );
  =     }
  = 
  =     // requestAnimationFrame() schedules code only for the next frame.
  =     //
  =     // Because we want for our simulation to continue forever, we've
  =     // gotta keep re-scheduling our function:
  =     requestAnimationFrame(redraw);
  = }
  = 
  = redraw();
  -->
</listing>

<p>And voilà:</p>

<figure>
  <video
    src="{{ assets }}/4828f46c-2f2a-44a9-9d64-56ef61aa692e.mp4"
    controls=""
  >
    Your browser does not support the video tag.
  </video>
</figure>

<p>... or rather voil-<i>whaaat</i> — why do they disappear after a while?</p>

<p>Let's go back to <code>lib-simulation</code> and investigate:</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
        pub fn step(&mut self) {
            for animal in &mut self.world.animals {
                animal.position +=
                    animal.rotation * na::Vector2::new(animal.speed, 0.0);
            }
        }
    }
    
    /* ... */
  -->
</listing>

<p>
  So we add rotation to position and…​ ah, right! Our map is bounded by
  <code>&lt;0.0, 1.0&gt;</code> — anything beyond those coordinates can exist,
  but it'd be rendered <i>outside</i> the canvas; as we've just seen.
</p>

<p>Let's fix it:</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
        pub fn step(&mut self) {
            for animal in &mut self.world.animals {
                animal.position +=
                    animal.rotation * na::Vector2::new(0.0, animal.speed);
    
  =             animal.position.x = na::wrap(animal.position.x, 0.0, 1.0);
  =             animal.position.y = na::wrap(animal.position.y, 0.0, 1.0);
            }
        }
    }
    
    /* ... */
  -->
</listing>

<p>
  <a href="https://docs.rs/nalgebra/0.26.2/nalgebra/fn.wrap.html"
    ><code>wrap()</code></a
  >
  does pretty much what it says — the first argument is the number being
  checked, while the second and third arguments determine minimum and maximum
  allowed values:
</p>

<ul>
  <li>
    <p>
      <code>na::wrap(0.5, 0.0, 1.0) == 0.5</code> (numbers between
      <code>[min,max]</code> are left untouched),
    </p>
  </li>
  <li>
    <p>
      <code>na::wrap(-0.5, 0.0, 1.0) == 1.0</code> (<code
        >if number &lt; min { return max; }</code
      >),
    </p>
  </li>
  <li>
    <p>
      <code>na::wrap(1.5, 0.0, 1.0) == 0.0</code> (<code
        >if number &gt; max { return min; }</code
      >).
    </p>
  </li>
</ul>

<p>With this fix, let's <code>$ wasm-pack build</code> — and:</p>

<figure>
  <video
    src="{{ assets }}/0653f996-eb04-4c17-a1ff-06733b46f30c.mp4"
    controls=""
  >
    Your browser does not support the video tag.
  </video>
</figure>

<p>Woohoo!</p>

<h2 id="ur-somebody-else">
  <a href="#ur-somebody-else">You’re Somebody Else (when you’re hungry)</a>
</h2>

<p>
  All said, birds constitute for only half of our ecosystem - we've also got
  food.
</p>

<h3>Rendering food</h3>

<p>
  Fortunately, because we've already written lots of the code, rendering food
  distills to just a few changes:
</p>

<div class="listing-title">libs/simulation-wasm/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Clone, Debug, Serialize)]
    pub struct World {
        pub animals: Vec<Animal>,
  =     pub foods: Vec<Food>,
    }
    
  = #[derive(Clone, Debug, Serialize)]
  = pub struct Food {
  =     pub x: f32,
  =     pub y: f32,
  = }
    
    /* ... */
    
    impl From<&sim::World> for World {
        fn from(world: &sim::World) -> Self {
            /* ... */
    
  =         let foods = world
  =             .foods()
  =             .iter()
  =             .map(Food::from)
  =             .collect();
    
  =         Self { animals, foods }
        }
    }
    
    /* ... */
    
  = impl From<&sim::Food> for Food {
  =     fn from(food: &sim::Food) -> Self {
  =         Self {
  =             x: food.position().x,
  =             y: food.position().y,
  =         }
  =     }
  = }
  -->
</listing>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
  = CanvasRenderingContext2D.prototype.drawCircle =
  =     function(x, y, radius) {
  =         this.beginPath();
  = 
  =         // ---
  =         // | Circle's center.
  =         // ----- v -v
  =         this.arc(x, y, radius, 0, 2.0 * Math.PI);
  =         // ------------------- ^ -^-----------^
  =         // | Range at which the circle starts and ends, in radians.
  =         // |
  =         // | By manipulating these two parameters you can e.g. draw
  =         // | only half of a circle, Pac-Man style.
  =         // ---
  = 
  =         this.fillStyle = 'rgb(0, 0, 0)';
  =         this.fill();
  =     };
    
    function redraw() {
        ctxt.clearRect(0, 0, viewportWidth, viewportHeight);
    
        simulation.step();
    
  =     const world = simulation.world();
    
  =     for (const food of world.foods) {
  =         ctxt.drawCircle(
  =             food.x * viewportWidth,
  =             food.y * viewportHeight,
  =             (0.01 / 2.0) * viewportWidth,
  =         );
  =     }
    
  =     for (const animal of world.animals) {
            /* ... */
        }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>Believe me or not, it's enough!</p>

<div class="listing-title">$ wasm-pack build</div>

<listing lang="text">
  <!--
    ....
    [INFO]: :-) Done in 1.25s
    [INFO]: :-) Your wasm pkg is ready to publish at /home/pwy/Projects/...
  -->
</listing>

<figure>
  <video
    src="{{ assets }}/87172540-2d9b-4f8d-a4ff-1e0a456bfffe.mp4"
    controls=""
  >
    Your browser does not support the video tag.
  </video>
</figure>

<h3>Pimpin'-up</h3>

<p>
  Our math checks out, but our simulation's appearance is…​ daunting — let's try
  pimpin' it up:
</p>

<div class="listing-title">www/index.html</div>

<listing lang="html">
  <!--
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="utf-8">
  =     <title>Shorelark</title>
      </head>
  =   <style>
  =     body {
  =       background: #1f2639; /* A nice navy blue color that I found by
  =                               a nice trial and error */
  =     }
  =   </style>
      <body>
        <canvas id="viewport" width="800" height="800"></canvas>
        <script src="./bootstrap.js"></script>
      </body>
    </html>
  -->
</listing>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
    CanvasRenderingContext2D.prototype.drawTriangle =
        function (x, y, size, rotation) {
            /* ... */
    
  =         this.fillStyle = 'rgb(255, 255, 255)'; // A nice white color
  =         this.fill();
        };
    
    CanvasRenderingContext2D.prototype.drawCircle =
        function(x, y, radius) {
            /* ... */
    
  =         this.fillStyle = 'rgb(0, 255, 128)'; // A nice green color
            this.fill();
        };
    
    /* ... */
  -->
</listing>

<p>There, better:</p>

<figure>
  <video
    controls=""
    src="{{ assets }}/cac427f6-316d-4d90-80bd-609d1511e885.mp4"
  >
    Your browser does not support the video tag.
  </video>
</figure>

<h3>Simulating food</h3>

<p>
  At the moment, when our birdies collide with food, nothing happens — time to
  improve it!
</p>

<p>First, let's refactor <code>step()</code> a bit:</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
        pub fn step(&mut self) {
  =         self.process_movements();
        }
    
  =     fn process_movements(&mut self) {
  =         for animal in &mut self.world.animals {
  =             animal.position +=
  =                 animal.rotation * na::Vector2::new(0.0, animal.speed);
  = 
  =             animal.position.x = na::wrap(animal.position.x, 0.0, 1.0);
  =             animal.position.y = na::wrap(animal.position.y, 0.0, 1.0);
  =         }
  =     }
    }
    
    /* ... */
  -->
</listing>

<p>Now:</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
        pub fn step(&mut self) {
  =         self.process_collisions();
            self.process_movements();
        }
    
  =     fn process_collisions(&mut self) {
  =         todo!();
  =     }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>In plain English, what we want to achieve is:</p>

<listing lang="rust">
  <!--
    /* ... */
    
    fn process_collisions(&mut self) {
        for each animal {
            for each food {
                if animal collides with food {
                    handle collision
                }
            }
        }
    }
    
    /* ... */
  -->
</listing>

<p>
  The process of checking whether two polygons collide is called
  <a href="https://en.wikipedia.org/wiki/Hit-testing">hit-testing</a> — so since
  our birds are triangles and our foods are circles, the thing we
  <i>should</i> be duckduckgoing for is
  <code>triangle circle hit test algorithm</code> (or
  <code>triangle circle collision</code> etc.).
</p>

<p>
  But — funny thing — this kind of hit-testing is
  <a href="http://www.phatcode.net/articles.php?id=459">unbearably complex</a>,
  so whaddya say we try something simpler; hang tight:
</p>

<p class="text-center">What if we assumed our birds are <b>circles</b>?</p>

<p>
  You know, we can keep <i>drawing</i> them as triangles — it's only about the
  physics engine.
</p>

<p>Agreed? <i>(just kidding, I know you can't reply here.)</i></p>

<p>
  Ok, so circle-circle hit testing relies on checking whether the distance
  between two cirles is shorter or equal than the sum of their radii:
</p>

<figure class="sketch w-80">
  <img
    src="{{ assets }}/sketches/eaeec88c-f532-4976-8e1d-0b3b7660c136.svg"
  />

  <figcaption>
    <div class="title">
      distance(A, B) &gt; radius(A) + radius(B) ⇒ no collision
    </div>
  </figcaption>
</figure>

<figure class="sketch w-80">
  <img
    src="{{ assets }}/sketches/b5eac4ea-8667-4590-91bb-0c77412d8cb1.svg"
  />

  <figcaption>
    <div class="title">
      distance(A, B) &lt;= radius(A) + radius(B) ⇒ collision
    </div>
  </figcaption>
</figure>

<p>In practice, this reduces to a single <code>if</code>:</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
  = pub fn step(&mut self, rng: &mut dyn RngCore) {
  =     self.process_collisions(rng);
        self.process_movements();
    }
    
  = fn process_collisions(&mut self, rng: &mut dyn RngCore) {
  =     for animal in &mut self.world.animals {
  =         for food in &mut self.world.foods {
  =             let distance = na::distance(
  =                 &animal.position,
  =                 &food.position,
  =             );
  = 
  =             if distance <= 0.01 {
  =                 food.position = rng.gen();
  =             }
  =         }
  =     }
  = }
    
    /* ... */
  -->
</listing>

<div class="listing-title">libs/simulation-wasm/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[wasm_bindgen]
    impl Simulation {
        /* ... */
    
        pub fn step(&mut self) {
  =         self.sim.step(&mut self.rng);
        }
    }
    
    /* ... */
  -->
</listing>

<p>
  The distance returned by nalgebra is in the same units as our positions - so a
  distance of, say, 0.5 means that our animal and food are half a map apart from
  each other, while 0.0 means that both are at the exact same coordinates.
</p>

<p>
  <code>0.01</code> determines the radius of our food — I've chosen
  <code>0.01</code> because it seems to play nice with the sizes we're using for
  drawing.
</p>

<p>Overall, does it work? Oh my!</p>

<figure>
  <video
    src="{{ assets }}/64cb25d6-7c9f-43a8-b7ea-e022410a962a.mp4"
    controls=""
  >
    Your browser does not support the video tag.
  </video>
</figure>

<h2 id="birdie-and-the-brain">
  <a href="#birdie-and-the-brain">Birdie and the Brain</a>
</h2>

<p>
  Our birds can fly, but they can't interact with their environment yet — in
  this chapter we'll implement <b>eyes</b>, allowing for our birds to see the
  food, and <b>brains</b>, allowing for our birds to decide where they want to
  fly.
</p>

<h3>Refactoring</h3>

<p>
  There's a lot of code inside <code>libs/simulation/src/lib.rs</code> - before
  we go further, let's take a moment to refactor it.
</p>

<p>A good rule of thumb is to keep a struct per file, so:</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
  = pub use self::{animal::*, food::*, world::*};
  = 
  = mod animal;
  = mod food;
  = mod world;
    
    use nalgebra as na;
    use rand::{Rng, RngCore};
    
    pub struct Simulation {
        /* ... */
    }
    
    impl Simulation {
        /* ... */
    }
  -->
</listing>

<div class="listing-title">libs/simulation/src/animal.rs</div>

<listing lang="rust">
  <!--
  = use crate::*;
  = 
  = #[derive(Debug)]
  = pub struct Animal {
  =     /* ... */
  = }
  = 
  = impl Animal {
  =     /* ... */
  = }
  -->
</listing>

<div class="listing-title">libs/simulation/src/food.rs</div>

<listing lang="rust">
  <!--
  = use crate::*;
  = 
  = #[derive(Debug)]
  = pub struct Food {
  =     /* ... */
  = }
  = 
  = impl Food {
  =     /* ... */
  = }
  -->
</listing>

<div class="listing-title">libs/simulation/src/world.rs</div>

<listing lang="rust">
  <!--
  = use crate::*;
  = 
  = #[derive(Debug)]
  = pub struct World {
  =     /* ... */
  = }
  = 
  = impl World {
  =     /* ... */
  = }
  -->
</listing>

<p>... and now:</p>

<div class="listing-title">$ cargo check</div>

<listing lang="text">
  <!--
    error[E0616]: field `animals` of struct `world::World` is private
      -\-> libs/simulation/src/lib.rs
       |
       |         for animal in &mut self.world.animals {
       |                                       ^^^^^^^ private field
    
    error[E0616]: field `foods` of struct `world::World` is private
      -\-> libs/simulation/src/lib.rs
       |
       |             for food in &mut self.world.foods {
       |                                         ^^^^^ private field
    
    /* ... */
  -->
</listing>

<p>
  Oh no; we've only shuffled some code around — what happened? Let's see the
  offending place:
</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
        fn process_collisions(&mut self, rng: &mut dyn RngCore) {
            for animal in &mut self.world.animals {
                //                       ^------^
    
                for food in &mut self.world.foods {
                    //                     ^----^
    
                    /* ... */
                }
            }
        }
    }
  -->
</listing>

<p>
  Previously, when all four structs were in the same file, Rust's
  <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html"
    >visibility rules</a
  >
  allowed for all of them to access each other's private fields. Now that our
  structs are in separate files, they can't access non-pub fields anymore.
</p>

<p>There are two ways we could solve this issue:</p>

<ol>
  <li>
    <p>We could provide <b>mutable getters</b>:</p>

    <listing lang="rust">
      <!--
        // libs/simulation/src/world.rs
        impl World {
            pub(crate) fn animals_mut(&mut self) -> &mut [Animal] {
                &mut self.animals
            }
        
            pub(crate) fn foods_mut(&mut self) -> &mut [Food] {
                &mut self.foods
            }
        }
        
        // libs/simulation/src/lib.rs
        impl Simulation {
            fn process_collisions(&mut self, rng: &mut dyn RngCore) {
                for animal in self.world.animals_mut() {
                    for food in self.world.foods_mut() {
                        /* ... */
                    }
                }
            }
        }
      -->
    </listing>
  </li>
  <li>
    <p>
      We could change <code>World</code>-'s fields to be
      <b>crate-public</b> instead of private:
    </p>

    <listing lang="rust">
      <!--
        #[derive(Debug)]
        pub struct World {
            pub(crate) animals: Vec<Animal>,
            pub(crate) foods: Vec<Food>,
        }
      -->
    </listing>
  </li>
</ol>

<p>
  All fields (or functions, as seen in the first case) prepended with
  <code>pub(crate)</code> are visible to the entire code inside given crate — so
  <code>pub(crate) animals</code> means that all the code inside
  <code>lib-simulation</code> will be able to access <code>world.animals</code>,
  and it'll remain private for other crates.
</p>

<p>As for the difference between both snippets, it's pretty minor:</p>

<ol>
  <li>
    <p>
      Some people advocate for mutable getters, because they make refactoring
      easier (e.g. you can rename the field from <code>animals</code> to
      <code>birds</code>, but keep <code>fn animals_mut()</code> to avoid
      introducing a breaking change),
    </p>
  </li>
  <li>
    <p>
      Some people advocate for crate-public fields, because they make the code
      shorter (there's no need to create additional functions).
    </p>
  </li>
</ol>

<p>
  For simplicity, we'll go with the second approach — with an additional
  <i>touch</i>:
</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
  = #![feature(crate_visibility_modifier)]
    // ^ Allows to write `crate field: ...` instead of a bit longer
    // | `pub(crate) field: ...`.
    // |
    // | I like it, because it makes the code easier to follow.
    // ---
    
    /* ... */
  -->
</listing>

<div class="listing-title">libs/simulation/src/animal.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct Animal {
  =     crate position: na::Point2<f32>,
  =     crate rotation: na::Rotation2<f32>,
  =     crate speed: f32,
    }
    
    /* ... */
  -->
</listing>

<div class="listing-title">libs/simulation/src/food.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct Food {
  =     crate position: na::Point2<f32>,
    }
    
    /* ... */
  -->
</listing>

<div class="listing-title">libs/simulation/src/world.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct World {
  =     crate animals: Vec<Animal>,
  =     crate foods: Vec<Food>,
    }
    
    /* ... */
  -->
</listing>

<div class="listing-title">$ cargo check</div>

<listing lang="text">
  <!--
    Checking lib-simulation v0.1.0
        Checking lib-simulation-wasm v0.1.0
        Finished dev [unoptimized + debuginfo] target(s) in 0.57s
  -->
</listing>

<p>Nice 😎 — now we're ready to implement eyes!</p>

<h3>Eye Of The Birdie</h3>

<p>What's an eye?</p>

<p>
  Well, a biologist might tell you that eye is an organ that provides vision; a
  philosopher's take might be that eye is a window to one's soul; and me? I
  think that an eye…​
</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
  = pub use self::{animal::*, eye::*, food::*, world::*};
    
    mod animal;
  = mod eye;
    mod food;
    mod world;
  -->
</listing>

<p>... is a struct!</p>

<div class="listing-title">libs/simulation/src/eye.rs</div>

<listing lang="rust">
  <!--
  = use crate::*;
  = 
  = #[derive(Debug)]
  = pub struct Eye;
  -->
</listing>

<p>
  Not just <i>any</i> struct, though — it's gotta have one function in
  particular:
</p>

<div class="listing-title">libs/simulation/src/eye.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
  = impl Eye {
  =     pub fn process_vision() -> Vec<f32> {
  =         todo!()
  =     }
  = }
  -->
</listing>

<p>
  The result of this function is a vector of numbers, where each number — each
  <i>eye cell</i> — tells us <i>how close</i> the nearest food matching that eye
  cell is:
</p>

<figure class="sketch w-80">
  <img
    src="{{ assets }}/sketches/0adc49b4-c1cb-4012-9d63-25bbaed96de7.svg"
  />

  <figcaption>
    <div class="title">Example of an eye with three eye cells</div>
  </figcaption>
</figure>

<p>Such an eye is defined by a few parameters:</p>

<div class="listing-title">libs/simulation/src/eye.rs</div>

<listing lang="rust">
  <!--
    use crate::*;
  = use std::f32::consts::*;
    
    /// How far our eye can see:
    ///
    /// -----------------
    /// |               |
    /// |               |
    /// |               |
    /// |@      %      %|
    /// |               |
    /// |               |
    /// |               |
    /// -----------------
    ///
    /// If @ marks our birdie and % marks food, then a FOV_RANGE of:
    ///
    /// - 0.1 = 10% of the map = bird sees no foods (at least in this case)
    /// - 0.5 = 50% of the map = bird sees one of the foods
    /// - 1.0 = 100% of the map = bird sees both foods
  = const FOV_RANGE: f32 = 0.25;
    
    /// How wide our eye can see.
    ///
    /// If @> marks our birdie (rotated to the right) and . marks the area
    /// our birdie sees, then a FOV_ANGLE of:
    ///
    /// - PI/2 = 90° =
    ///   -----------------
    ///   |             /.|
    ///   |           /...|
    ///   |         /.....|
    ///   |       @>......|
    ///   |         \\.....|
    ///   |           \\...|
    ///   |             \\.|
    ///   -----------------
    ///
    /// - PI = 180° =
    ///   -----------------
    ///   |       |.......|
    ///   |       |.......|
    ///   |       |.......|
    ///   |       @>......|
    ///   |       |.......|
    ///   |       |.......|
    ///   |       |.......|
    ///   -----------------
    ///
    /// - 2 * PI = 360° =
    ///   -----------------
    ///   |...............|
    ///   |...............|
    ///   |...............|
    ///   |.......@>......|
    ///   |...............|
    ///   |...............|
    ///   |...............|
    ///   -----------------
    ///
    /// Field of view depends on both FOV_RANGE and FOV_ANGLE:
    ///
    /// - FOV_RANGE=0.4, FOV_ANGLE=PI/2:
    ///   -----------------
    ///   |       @       |
    ///   |     /.v.\\     |
    ///   |   /.......\\   |
    ///   |   ---------   |
    ///   |               |
    ///   |               |
    ///   |               |
    ///   -----------------
    ///
    /// - FOV_RANGE=0.5, FOV_ANGLE=2*PI:
    ///   -----------------
    ///   |               |
    ///   |      ---      |
    ///   |     /...\\     |
    ///   |    |..@..|    |
    ///   |     \\.../     |
    ///   |      ---      |
    ///   |               |
    ///   -----------------
  = const FOV_ANGLE: f32 = PI + FRAC_PI_4;
    
    /// How much photoreceptors there are in a single eye.
    ///
    /// More cells means our birds will have more "crisp" vision, allowing
    /// them to locate the food more precisely - but the trade-off is that
    /// the evolution process will then take longer, or even fail, unable
    /// to find any solution.
    ///
    /// I've found values between 3~11 sufficient, with eyes having more
    /// than ~20 photoreceptors yielding progressively worse results.
  = const CELLS: usize = 9;
    
  = #[derive(Debug)]
  = pub struct Eye {
  =     fov_range: f32,
  =     fov_angle: f32,
  =     cells: usize,
  = }
  = 
  = impl Eye {
  =     // FOV_RANGE, FOV_ANGLE & CELLS are the values we'll use during
  =     // simulation - but being able to create an arbitrary eye will
  =     // come handy during the testing:
  =     fn new(fov_range: f32, fov_angle: f32, cells: usize) -> Self {
  =         assert!(fov_range > 0.0);
  =         assert!(fov_angle > 0.0);
  =         assert!(cells > 0);
  = 
  =         Self { fov_range, fov_angle, cells }
  =     }
  = 
  =     pub fn cells(&self) -> usize {
  =         self.cells
  =     }
  = 
  =     pub fn process_vision(
  =         &self,
  =         position: na::Point2<f32>,
  =         rotation: na::Rotation2<f32>,
  =         foods: &[Food],
  =     ) -> Vec<f32> {
  =         todo!()
  =     }
  = }
  = 
  = impl Default for Eye {
  =     fn default() -> Self {
  =         Self::new(FOV_RANGE, FOV_ANGLE, CELLS)
  =     }
  = }
  -->
</listing>

<p>The basic outline of our algorithm is:</p>

<div class="listing-title">libs/simulation/src/eye.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    pub fn process_vision(/* ... */) -> Vec<f32> {
  =     let mut cells = vec![0.0; self.cells];
  = 
  =     for food in foods {
  =         if food inside fov {
  =            cells[cell that sees this food] += how close the food is;
  =         }
  =     }
  = 
  =     cells
    }
    
    /* ... */
  -->
</listing>

<p>
  How can we check if some food is inside our field of view? Two conditions must
  be fulfilled:
</p>

<ol>
  <li>
    <p>
      The distance between us and the food must be no greater than
      <code>FOV_RANGE</code>:
    </p>

    <div class="listing-title">libs/simulation/src/eye.rs</div>

    <listing lang="rust">
      <!--
        /* ... */
        
        for food in foods {
      =     let vec = food.position - position;
        
            // ^ Represents a *vector* from food to us
            //
            // In case this is the first time you hear the word `vector`, a
            // quick definition would be:
            //
            // > A vector is an object that has *magnitude* (aka length)
            // > and *direction*.
            //
            // You could say a vector is an arrow:
            //
            //   --\-> this is a vector of magnitude=3 (if we count each
            //        dash as a single "unit of space"), and direction=0°
            //        (at least relative to the X axis)
            //
            //    |   this is a vector of magnitude=1 and direction=90°
            //    v   (at least when we treat direction clockwise)
            //
            // Our food-to-birdie vectors are no different:
            //
            // ---------
            // |       |  gets us this vector:
            // |@     %|          <-----
            // |       |  (magnitude=5, direction=180°)
            // ---------
            //
            // ---------  gets us this vector:
            // |   %   |           |
            // |       |           |
            // |   @   |           v
            // ---------  (magnitude=2, direction=90°)
            //
            // This is not to be confused with Rust's `Vec` or C++'s
            // `std::vector`, which technically *are* vectors, but in a more
            // abstract sense -- better not overthink it.
            //
            // (https://stackoverflow.com/questions/581426/why-is-a-c-vector-called-a-vector).
        
            // ---
            // | Fancy way to say "length of the vector".
            // ----------- v----v
      =     let dist = vec.norm();
      = 
      =     if dist >= self.fov_range {
      =         continue;
      =     }
        }
        
        /* ... */
      -->
    </listing>
  </li>
  <li>
    <p>
      The angle between us and the food must be no greater than
      <code>FOV_ANGLE</code> — and since our birdie's vision is symmetrical
      (they see the same amount "on the left" and "on the right", just like
      humans do), this means that our angle must be
      <code>&lt;-FOV_ANGLE/2, +FOV_ANGLE/2&gt;</code>:
    </p>

    <div class="listing-title">libs/simulation/src/eye.rs</div>

    <listing lang="rust">
      <!--
        /* ... */
        
        for food in foods {
            /* ... */
        
            // Returns vector's direction relative to the X axis, that is:
            //
            //   -\-> = 0° = 0
            //
            //    |  = 90° = PI / 2
            //    v
            //
            //   <--- = 180° = PI
            //
            // (if you've been measuring rotations before - this is atan2
            // in disguise.)
      =     let angle = na::Rotation2::rotation_between(
      =         &na::Vector2::x(),
      =         &vec,
      =     ).angle();
        
            // Because our bird is *also* rotated, we have to include its
            // rotation too:
      =     let angle = angle - rotation.angle();
        
            // Rotation is wrapping (from -PI to PI), that is:
            //
            //   = angle of 2*PI
            //   = angle of PI    (because 2*PI >= PI)
            //   = angle of 0     (          PI >= PI)
            //                    (           0 < PI; fin.)
            //
            //  angle of 2*PI + PI/2
            //  = angle of 1*PI + PI/2  (because 2*PI + PI/2 >= PI)
            //  = angle of PI/2         (          PI + PI/2 >= PI)
            //                          (               PI/2 < PI; fin.)
            //
            //  angle of -2.5*PI
            //  = angle of -1.5*PI  (because -2.5*PI <= -PI)
            //  = angle of -0.5*PI  (        -1.5*PI <= -PI)
            //                      (        -0.5*PI > -PI; fin.)
            //
            // Intuitively:
            //
            // - when you rotate yourself twice around the axis, it's the
            //   same as if you rotated once, as if you've never rotated
            //   at all.
            //
            //   (your bony labyrinth might have a different opinion tho.)
            //
            // - when you rotate by 90° and then by 360°, it's the same
            //   as if you rotated only by 90° (*or* by 270°, just in the
            //   opposite direction).
      =     let angle = na::wrap(angle, -PI, PI);
        
            // If current angle is outside our birdie's field of view, jump
            // to the next food
      =     if angle < -self.fov_angle / 2.0 ||
      =        angle > self.fov_angle / 2.0
      =     {
      =         continue;
      =     }
        }
        
        /* ... */
      -->
    </listing>
  </li>
</ol>

<p>
  Ok, we've rejected all the foods outside our birdie's field of view — for the
  eye to work, we need one more thing:
</p>

<listing lang="rust">
  <!--
    cells[cell that sees this food] += how close the food is;
  -->
</listing>

<p>
  Determining which concrete cell sees the food is a bit tricky, but it distills
  to looking at the angle between the food and our eye — e.g. for an eye with
  three cells and fov of 120°:
</p>

<figure class="sketch">
  <img
    src="{{ assets }}/sketches/17d07e2f-952f-4c16-a71a-aace25683c5e.svg"
  />
</figure>

<p>In the poetic language of code:</p>

<div class="listing-title">libs/simulation/src/eye.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    for food in foods {
        /* ... */
    
        // Makes angle *relative* to our birdie's field of view - that is:
        // transforms it from <-FOV_ANGLE/2,+FOV_ANGLE/2> to <0,FOV_ANGLE>.
        //
        // After this operation:
        // - an angle of 0° means "the beginning of the FOV",
        // - an angle of self.fov_angle means "the ending of the FOV".
  =     let angle = angle + self.fov_angle / 2.0;
    
        // Since this angle is now in range <0,FOV_ANGLE>, by dividing it by
        // FOV_ANGLE, we transform it to range <0,1>.
        //
        // The value we get can be treated as a percentage, that is:
        //
        // - 0.2 = the food is seen by the "20%-th" eye cell
        //         (practically: it's a bit to the left)
        //
        // - 0.5 = the food is seen by the "50%-th" eye cell
        //         (practically: it's in front of our birdie)
        //
        // - 0.8 = the food is seen by the "80%-th" eye cell
        //         (practically: it's a bit to the right)
  =     let cell = angle / self.fov_angle;
    
        // With cell in range <0,1>, by multiplying it by the number of
        // cells we get range <0,CELLS> - this corresponds to the actual
        // cell index inside our `cells` array.
        //
        // Say, we've got 8 eye cells:
        // - 0.2 * 8 = 20% * 8 = 1.6 ~= 1 = second cell (indexing from 0!)
        // - 0.5 * 8 = 50% * 8 = 4.0 ~= 4 = fifth cell
        // - 0.8 * 8 = 80% * 8 = 6.4 ~= 6 = seventh cell
  =     let cell = cell * (self.cells as f32);
    
        // Our `cell` is of type `f32` - before we're able to use it to
        // index an array, we have to convert it to `usize`.
        //
        // We're also doing `.min()` to cover an extreme edge case: for
        // cell=1.0 (which corresponds to a food being maximally to the
        // right side of our birdie), we'd get `cell` of `cells.len()`,
        // which is one element *beyond* what the `cells` array contains
        // (its range is <0, cells.len()-1>).
        //
        // Being honest, I've only caught this thanks to unit tests we'll
        // write in a moment, so if you consider my explanation
        // insufficient (pretty fair!), please feel free to drop the
        // `.min()` part later and see which tests fail - and why :-)
  =     let cell = (cell as usize).min(cells.len() - 1);
    }
    
    /* ... */
  -->
</listing>

<p>Now that we know the cell index, our final touch in here is:</p>

<div class="listing-title">libs/simulation/src/eye.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    for food in foods {
        /* ... */
    
        // Energy is inversely proportional to the distance between our
        // birdie and the currently checked food; that is - an energy of:
        //
        // - 0.0001 = food is barely in the field of view (i.e. far away),
        // - 1.0000 = food is right in front of the bird.
        //
        // We could also model energy in reverse manner - "the higher the
        // energy, the further away the food" - but from what I've seen, it
        // makes the learning process a bit harder.
        //
        // As always, feel free to experiment! -- overall this isn't the
        // only way of implementing eyes :-)
  =     let energy = (self.fov_range - dist) / self.fov_range;
    
  =     cells[cell] += energy;
    }
    
    /* ... */
  -->
</listing>

<p>
  That's a lot of math! — how do we know it works? Of course, by testing it 😊
</p>

<h3>Nothing But Tests</h3>

<p>
  The first obstacle is that our vision requires lot of parameters to compute:
</p>

<ul>
  <li>
    <p>FOV range (one <code>f32</code>),</p>
  </li>
  <li>
    <p>FOV angle (one <code>f32</code>),</p>
  </li>
  <li>
    <p>number of cells (one <code>usize</code>),</p>
  </li>
  <li>
    <p>position (two <code>f32</code>-s),</p>
  </li>
  <li>
    <p>rotation (one <code>f32</code>).</p>
  </li>
</ul>

<p>
  Even ignoring the number of cells — which we can hard-code without losing
  much — this gets us <b>5</b> different tunables that affect each other, plus
  we've also got to specify locations of our foods; moon on a stick, checking
  all of the combinations, I tell ya'!
</p>

<p>
  The second obstacle is that our <code>Eye::process_vision()</code> returns
  <code>Vec&lt;f32&gt;</code>, so it's one of those functions that take some dry
  numbers and return some dry numbers; not only it's a bit boring, but also
  resilient to solid testing:
</p>

<p class="text-center">
  is <code>vec![0.0, 0.1, 0.7]</code> <i>really</i> the response we want for
  <code>x=0.2, y=0.5</code>? who knows!
</p>

<p>
  So, as for the first obstacle, my idea is to use a thing called
  <b>parameterized tests</b> — with a pinch of salt, parameterized tests are
  when you create a testing function:
</p>

<listing lang="rust">
  <!--
    #[test]
    fn some_test() {
        /* ... */
    }
  -->
</listing>

<p>... and make it accept one or many parameters:</p>

<listing lang="rust">
  <!--
    // This is just an example in pseudo-Rust
    
    #[test(x=10, y=20, z=30)]
    #[test(x=50, y=50, z=50)]
    #[test(x=0, y=0, z=0)]
    fn some_test(x: f32, y: f32, z: usize) {
        /* ... */
    }
  -->
</listing>

<p>
  This testing methodology allows to cover the input space more thoroughly than
  you'd do with copy-pasted <code>mod { …​ }</code>, simply because adding more
  edge cases is just <i>so easy</i>.
</p>

<p>
  Rust doesn't support parameterized tests natively — at least not in the manner
  that I've shown above — but there exist a few crates providing this
  functionality; we're going to use
  <a href="https://crates.io/crates/test-case">test-case</a>:
</p>

<div class="listing-title">libs/simulation/Cargo.toml</div>

<listing lang="toml">
  <!--
    # ...
    
  = [dev-dependencies]
  = test-case = "1.1"
  -->
</listing>

<p>... which has a pretty straightforward syntax:</p>

<div class="listing-title">libs/simulation/src/eye.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
  = #[cfg(test)]
  = mod tests {
  =     use super::*;
  = 
  =     mod different_fov_ranges {
  =         use super::*;
  =         use test_case::test_case;
  = 
  =         #[test_case(1.0)]
  =         #[test_case(0.5)]
  =         #[test_case(0.1)]
  =         fn test(fov_range: f32) {
  =             todo!()
  =         }
  =     }
  = }
  -->
</listing>

<p>
  This solves the first obstacle, at least for all the practical purposes; while
  we still won't be able to cover <i>all</i> the cases (remember how many
  numbers <code>f32</code> can encode?), the more test-cases we include, the
  more confident we can be that our code works as intended.
</p>

<p>
  As for the second hindrance: instead of comparing blunt vectors of number,
  whaddya say we compare <b>graphical representations</b> of what the bird sees?
</p>

<p>
  Stay with me: even if <code>process_vision()</code> returns something like
  <code>vec![0.0, 0.5, 0.0]</code>, it doesn't mean we're forced to compare
  <i>that</i> in our tests! If instead of a vector, what we compared was, hmm,
  <code>" * "</code>, it'd be <i>waay</i> easier to ensure our eye works
  correctly!
</p>

<p>So, baby steps:</p>

<div class="listing-title">libs/simulation/src/eye.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[cfg(test)]
    mod tests {
        use super::*;
    
  =     fn test(
  =         foods: Vec<Food>,
  =         fov_range: f32,
  =         fov_angle: f32,
  =         x: f32,
  =         y: f32,
  =         rot: f32,
  =         expected_vision: &str,
  =     ) {
  =         todo!()
  =     }
    
        mod different_fov_ranges {
            use super::*;
            use test_case::test_case;
    
            #[test_case(1.0)]
            #[test_case(0.5)]
            #[test_case(0.1)]
            fn test(fov_range: f32) {
  =             super::test(
  =                 todo!(),
  =                 fov_range,
  =                 todo!(),
  =                 todo!(),
  =                 todo!(),
  =                 todo!(),
  =                 todo!(),
  =              );
            }
        }
    }
  -->
</listing>

<p>
  Hmmm, <b>no</b> — that's <i>waaay</i> too many parameters for a single
  function; how about a struct?
</p>

<div class="listing-title">libs/simulation/src/eye.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[cfg(test)]
    mod tests {
        use super::*;
    
  =     struct TestCase {
  =         foods: Vec<Food>,
  =         fov_range: f32,
  =         fov_angle: f32,
  =         x: f32,
  =         y: f32,
  =         rot: f32,
  =         expected_vision: &'static str,
  =     }
  = 
  =     impl TestCase {
  =         fn run(self) {
  =             todo!()
  =         }
  =     }
    
        mod different_fov_ranges {
            use super::*;
            use test_case::test_case;
    
            #[test_case(1.0)]
            #[test_case(0.5)]
            #[test_case(0.1)]
            fn test(fov_range: f32) {
  =             TestCase {
  =                 foods: todo!(),
  =                 fov_angle: todo!(),
  =                 x: todo!(),
  =                 y: todo!(),
  =                 rot: todo!(),
  =                 expected_vision: todo!(),
  =                 fov_range,
  =             }.run()
            }
        }
    }
  -->
</listing>

<p>Nice and readable; nice and readable.</p>

<p>
  Our test's result, <code>expected_vision</code>, depends on
  <code>fov_range</code>, so it's formally a parameter, too:
</p>

<div class="listing-title">libs/simulation/src/eye.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    mod different_fov_ranges {
        use super::*;
        use test_case::test_case;
    
  =     #[test_case(1.0, "not sure yet")]
  =     #[test_case(0.5, "not sure yet")]
  =     #[test_case(0.1, "not sure yet")]
  =     fn test(fov_range: f32, expected_vision: &'static str) {
            TestCase {
                foods: todo!(),
                fov_angle: todo!(),
                x: todo!(),
                y: todo!(),
                rot: todo!(),
                fov_range,
  =             expected_vision,
            }.run()
        }
    }
    
    /* ... */
  -->
</listing>

<p>
  About that <code>TestCase</code> — from a birds-eye view, what we're looking
  for is:
</p>

<listing lang="rust">
  <!--
    /* ... */
    
    impl TestCase {
        fn run(self) {
            let eye = Eye::new(/* ... */);
    
            let actual_vision = eye.process_vision(/* ... */);
            let actual_vision = make_human_readable(actual_vision);
    
            assert_eq!(actual_vision, self.expected_vision);
        }
    }
    
    /* ... */
  -->
</listing>

<p>
  Since our <code>TestCase</code> already knows all the parameters needed, we
  can start implementing it:
</p>

<div class="listing-title">libs/simulation/src/eye.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    /// All our tests will use eyes hard-coded to thirteen eye cells.
    ///
    /// As for the "why":
    ///
    /// While we certainly *could* implement tests for different number of
    /// eye cells, after a while I've decided it's just not worth the
    /// hassle - as you'll see in a moment, we'll already get a good coverage
    /// via the other parameters, so creating a separate set of tests for
    /// different values of eye cells seemed like a waste of time.
    ///
    /// As for the "why this number in particular":
    ///
    /// I've checked a few numbers by hand, and generally found 13 to yield
    /// pretty good results. As always, nothing special about 13 in
    /// particular, your (eye) mileage may vary.
  = const TEST_EYE_CELLS: usize = 13;
    
    impl TestCase {
        fn run(self) {
  =         let eye = Eye::new(
  =             self.fov_range,
  =             self.fov_angle,
  =             TEST_EYE_CELLS,
  =         );
  = 
  =         let actual_vision = eye.process_vision(
  =             na::Point2::new(self.x, self.y),
  =             na::Rotation2::new(self.rot),
  =             &self.foods,
  =         );
    
            /* ... */
        }
    }
    
    /* ... */
  -->
</listing>

<p>
  Currently our <code>actual_vision</code> is <code>Vec&lt;f32&gt;</code> — we
  can convert it into a string via a chip of <code>.into_iter()</code>,
  <code>.map()</code> and <code>.join()</code> magic:
</p>

<div class="listing-title">libs/simulation/src/eye.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    impl TestCase {
        fn run(self) {
            /* ... */
    
  =         let actual_vision: Vec<_> = actual_vision
  =             .into_iter()
  =             .map(|cell| {
  =                 // As a reminder, the higher cell's value, the closer
  =                 // the food is:
  = 
  =                 if cell >= 0.7 {
  =                     // <0.7, 1.0>
  =                     // food is right in front of us
  =                     "#"
  =                 } else if cell >= 0.3 {
  =                     // <0.3, 0.7)
  =                     // food is somewhat further
  =                     "+"
  =                 } else if cell > 0.0 {
  =                     // <0.0, 0.3)
  =                     // food is pretty far away
  =                     "."
  =                 } else {
  =                     // 0.0
  =                     // no food in sight, this cell sees empty space
  =                     " "
  =                 }
  =             })
  =             .collect();
    
            // As before, there's nothing special about the cell values
            // (`0.7`, `0.3`, `0.0`) or the characters (`#`, `+`, `.`).
            //
            // I've chosen hash because to my eye it seems to occupy the
            // most "visual space" out of all the ASCII characters (thus
            // it represents a food being close), and then plus and dot
            // are just smaller (representing food being further away).
    
            // `.join()` converts `Vec<String>` into `String` using a
            // separator - e.g. `vec!["a", "b", "c"].join("|")` would
            // return `a|b|c`.
  =         let actual_vision = actual_vision.join("");
    
            // The finish line!
  =         assert_eq!(actual_vision, self.expected_vision);
        }
    }
    
    /* ... */
  -->
</listing>

<p>Just like that, our <b>testing framework</b> is complete! 🥳</p>

<p>Now, as for the tests — allow me to present you <i>pure beauty</i>:</p>

<div class="listing-title">libs/simulation/src/eye.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    // A helper-function that allows to create food easily
  = fn food(x: f32, y: f32) -> Food {
  =     Food {
  =         position: na::Point2::new(x, y),
  =     }
  = }
    
    mod different_fov_ranges {
        use super::*;
        use test_case::test_case;
    
        /// During tests in this module, we're using a world that looks
        /// like this:
        ///
        /// ------------
        /// |          |
        /// |          |
        /// |    @>   %|
        /// |          |
        /// |          |
        /// ------------
        ///
        /// Each test gradually reduces our birdie's field of view and
        /// compares what the birdie sees:
        ///
        /// ------------
        /// |        /.|
        /// |      /...|
        /// |    @>...%|
        /// |      \\...|
        /// |        \\.|
        /// ------------
        ///
        /// ------------
        /// |          |
        /// |      /.| |
        /// |    @>..|%|
        /// |      \\.| |
        /// |          |
        /// ------------
        ///
        /// ------------
        /// |          |
        /// |          |
        /// |    @>.| %|
        /// |          |
        /// |          |
        /// ------------
        ///
        /// Over time, what we see is the food gradually disappearing
        /// into an emptiness:
        ///
        /// (well, technically the food and bird remain stationary - it's
        /// only the birdie's own field of view that gets reduced.)
  =     #[test_case(1.0, "      +      ")] // Food is inside the FOV
  =     #[test_case(0.9, "      +      ")] // ditto
  =     #[test_case(0.8, "      +      ")] // ditto
  =     #[test_case(0.7, "      .      ")] // Food slowly disappears
  =     #[test_case(0.6, "      .      ")] // ditto
  =     #[test_case(0.5, "             ")] // Food disappeared!
  =     #[test_case(0.4, "             ")]
  =     #[test_case(0.3, "             ")]
  =     #[test_case(0.2, "             ")]
  =     #[test_case(0.1, "             ")]
        fn test(fov_range: f32, expected_vision: &'static str) {
            TestCase {
  =             foods: vec![food(1.0, 0.5)],
  =             fov_angle: FRAC_PI_2,
  =             x: 0.5,
  =             y: 0.5,
  =             rot: 0.0,
                fov_range,
                expected_vision,
            }.run()
        }
    }
    
    /* ... */
  -->
</listing>

<p>Breath in, breath out:</p>

<div class="listing-title">$ cargo test --workspace</div>

<listing lang="text">
  <!--
    running 10 tests
    test eye::tests::different_fov_ranges::test::_0_4_ ... ok
    test eye::tests::different_fov_ranges::test::_0_2_ ... ok
    test eye::tests::different_fov_ranges::test::_0_5_ ... ok
    test eye::tests::different_fov_ranges::test::_0_1_ ... ok
    test eye::tests::different_fov_ranges::test::_0_3_ ... ok
    test eye::tests::different_fov_ranges::test::_0_8_ ... ok
    test eye::tests::different_fov_ranges::test::_0_9_ ... ok
    test eye::tests::different_fov_ranges::test::_1_0_ ... ok
    test eye::tests::different_fov_ranges::test::_0_7_ ... ok
    test eye::tests::different_fov_ranges::test::_0_6_ ... ok
    
    test result: ok. 10 passed; 0 failed
  -->
</listing>

<p>
  Ha, ha! — it works! And it's readable! (and, with luck, even maintainable!)
</p>

<aside class="note">
  <p>
    The code you see has the correct values for
    <code>expected_vision</code> already filled — but in reality I didn't know
    them up-front; behind the scenes, what I've done was:
  </p>

  <listing lang="rust">
    <!--
      #[test_case(1.0, "")]
      /* ... */
    -->
  </listing>

  <p>
    ... and then I've run <code>$ cargo test</code>, and copy-pasted the actual
    result from the error message, analyzing whether it made sense or not (e.g.
    getting <code>#</code> for <code>fov_range</code> of <code>0.1</code> could
    indicate a bug, as a birdie with such a small
    <code>fov_range</code> shouldn't be able to see that food).
  </p>

  <p>
    Since all of this <code>$ cargo test</code> and copy-pasting is a rather
    mundane task, to avoid boring you, the code I'll provide in a moment will
    already contain all of the <code>expected_vision</code> pre-filled so that
    all of the tests pass; just keep in mind than in reality you'd have to start
    with e.g. empty assertion and see what comes out of it.
  </p>
</aside>

<p>That's one parameter — four more to go! What about rotation?</p>

<div class="listing-title">libs/simulation/src/eye.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
  = mod different_rotations {
  =     use super::*;
  =     use test_case::test_case;
    
        /// World:
        ///
        /// ------------
        /// |          |
        /// |          |
        /// |    @>    |
        /// |          |
        /// |         %|
        /// ------------
        ///
        /// Test cases:
        ///
        /// ------------
        /// |..........|
        /// |..........|
        /// |....@>....|
        /// |..........|
        /// |.........%|
        /// ------------
        ///
        /// ------------
        /// |..........|
        /// |..........|
        /// |....@.....|
        /// |....v.....|
        /// |.........%|
        /// ------------
        ///
        /// ------------
        /// |..........|
        /// |..........|
        /// |...<@.....|
        /// |..........|
        /// |.........%|
        /// ------------
        ///
        /// ... and so on, until we do a full circle, 360° rotation:
  =     #[test_case(0.00 * PI, "         +   ")] // Food is to our right
  =     #[test_case(0.25 * PI, "        +    ")]
  =     #[test_case(0.50 * PI, "      +      ")]
  =     #[test_case(0.75 * PI, "    +        ")]
  =     #[test_case(1.00 * PI, "   +         ")] // Food is behind us
  =     #[test_case(1.25 * PI, " +           ")] // (we continue to see it
  =     #[test_case(1.50 * PI, "            +")] // due to 360° fov_angle.)
  =     #[test_case(1.75 * PI, "           + ")]
  =     #[test_case(2.00 * PI, "         +   ")] // Here we've done 360°
  =     #[test_case(2.25 * PI, "        +    ")] // (and a bit more, to
  =     #[test_case(2.50 * PI, "      +      ")] // prove the numbers wrap.)
  =     fn test(rot: f32, expected_vision: &'static str) {
  =         TestCase {
  =             foods: vec![food(0.5, 1.0)],
  =             fov_range: 1.0,
  =             fov_angle: 2.0 * PI,
  =             x: 0.5,
  =             y: 0.5,
  =             rot,
  =             expected_vision,
  =         }.run()
  =     }
  = }
    
    /* ... */
  -->
</listing>

<p>Testing position is even more fun:</p>

<div class="listing-title">libs/simulation/src/eye.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
  = mod different_positions {
  =     use super::*;
  =     use test_case::test_case;
    
        /// World:
        ///
        /// ------------
        /// |          |
        /// |         %|
        /// |          |
        /// |         %|
        /// |          |
        /// ------------
        ///
        /// Test cases for the X axis:
        ///
        /// ------------
        /// |          |
        /// |        /%|
        /// |       @>.|
        /// |        \\%|
        /// |          |
        /// ------------
        ///
        /// ------------
        /// |        /.|
        /// |      /..%|
        /// |     @>...|
        /// |      \\..%|
        /// |        \\.|
        /// ------------
        ///
        /// ... and so on, going further left
        ///     (or, from the bird's point of view - going _back_)
        ///
        /// Test cases for the Y axis:
        ///
        /// ------------
        /// |     @>...|
        /// |       \\.%|
        /// |         \\|
        /// |         %|
        /// |          |
        /// ------------
        ///
        /// ------------
        /// |      /...|
        /// |     @>..%|
        /// |      \\...|
        /// |        \\%|
        /// |          |
        /// ------------
        ///
        /// ... and so on, going further down
        ///     (or, from the bird's point of view - going _right_)
    
  =     // Checking the X axis:
  =     // (you can see the bird is "flying away" from the foods)
  =     #[test_case(0.9, 0.5, "#           #")]
  =     #[test_case(0.8, 0.5, "  #       #  ")]
  =     #[test_case(0.7, 0.5, "   +     +   ")]
  =     #[test_case(0.6, 0.5, "    +   +    ")]
  =     #[test_case(0.5, 0.5, "    +   +    ")]
  =     #[test_case(0.4, 0.5, "     + +     ")]
  =     #[test_case(0.3, 0.5, "     . .     ")]
  =     #[test_case(0.2, 0.5, "     . .     ")]
  =     #[test_case(0.1, 0.5, "     . .     ")]
  =     #[test_case(0.0, 0.5, "             ")]
  =     //
  =     // Checking the Y axis:
  =     // (you can see the bird is "flying alongside" the foods)
  =     #[test_case(0.5, 0.0, "            +")]
  =     #[test_case(0.5, 0.1, "          + .")]
  =     #[test_case(0.5, 0.2, "         +  +")]
  =     #[test_case(0.5, 0.3, "        + +  ")]
  =     #[test_case(0.5, 0.4, "      +  +   ")]
  =     #[test_case(0.5, 0.6, "   +  +      ")]
  =     #[test_case(0.5, 0.7, "  + +        ")]
  =     #[test_case(0.5, 0.8, "+  +         ")]
  =     #[test_case(0.5, 0.9, ". +          ")]
  =     #[test_case(0.5, 1.0, "+            ")]
  =     fn test(x: f32, y: f32, expected_vision: &'static str) {
  =         TestCase {
  =             foods: vec![food(1.0, 0.4), food(1.0, 0.6)],
  =             fov_range: 1.0,
  =             fov_angle: FRAC_PI_2,
  =             rot: 0.0,
  =             x,
  =             y,
  =             expected_vision,
  =         }.run()
  =     }
  = }
    
    /* ... */
  -->
</listing>

<p>
  We've got only one more parameter left to cover: field of view's <i>angle</i>.
</p>

<p>
  We'll use the same framework, but <i>imagining</i> what happens in here is
  tiny bit more complicated (or at least it took me a minute to ensure the
  behavior is correct):
</p>

<div class="listing-title">libs/simulation/src/eye.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
  = mod different_fov_angles {
  =     use super::*;
  =     use test_case::test_case;
    
        /// World:
        ///
        /// ------------
        /// |%  %  %  %|
        /// |          |
        /// |    @>    |
        /// |          |
        /// |%  %  %  %|
        /// ------------
        ///
        /// Test cases:
        ///
        /// ------------
        /// |%  %  %/.%|
        /// |      /...|
        /// |    @>....|
        /// |      \\...|
        /// |%  %  %\\.%|
        /// ------------
        ///
        /// ------------
        /// |%  %|.%..%|
        /// |    |.....|
        /// |    @>....|
        /// |    |.....|
        /// |%  %|.%..%|
        /// ------------
        ///
        /// ... and so on, until we reach the full, 360° FOV
  =     #[test_case(0.25 * PI, " +         + ")] // FOV is narrow = 2 foods
  =     #[test_case(0.50 * PI, ".  +     +  .")]
  =     #[test_case(0.75 * PI, "  . +   + .  ")] // FOV gets progressively
  =     #[test_case(1.00 * PI, "   . + + .   ")] // wider and wider...
  =     #[test_case(1.25 * PI, "   . + + .   ")]
  =     #[test_case(1.50 * PI, ".   .+ +.   .")]
  =     #[test_case(1.75 * PI, ".   .+ +.   .")]
  =     #[test_case(2.00 * PI, "+.  .+ +.  .+")] // FOV is wide = 8 foods
  =     fn test(fov_angle: f32, expected_vision: &'static str) {
  =         TestCase {
  =             foods: vec![
  =                 food(0.0, 0.0),
  =                 food(0.0, 0.33),
  =                 food(0.0, 0.66),
  =                 food(0.0, 1.0),
  =                 food(1.0, 0.0),
  =                 food(1.0, 0.33),
  =                 food(1.0, 0.66),
  =                 food(1.0, 1.0),
  =             ],
  =             fov_range: 1.0,
  =             x: 0.5,
  =             y: 0.5,
  =             rot: 0.0,
  =             fov_angle,
  =             expected_vision,
  =         }.run()
  =     }
  = }
    
    /* ... */
  -->
</listing>

<p>Nice:</p>

<div class="listing-title">cargo test --workspace</div>

<listing lang="text">
  <!--
    test result: ok. 49 passed; 0 failed
  -->
</listing>

<p>
  So — we've got <i>eyez</i>, but what about <i>brainz</i>? Fortunately, we've
  already implemented it!
</p>

<div class="listing-title">libs/simulation/Cargo.toml</div>

<listing lang="toml">
  <!--
    # ...
    
    [dependencies]
    # ...
    
  = lib-neural-network = { path = "../neural-network" }
    
    # ...
  -->
</listing>

<div class="listing-title">libs/simuation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
  = use lib_neural_network as nn;
    use nalgebra as na;
    use rand::{Rng, RngCore};
    
    /* ... */
  -->
</listing>

<div class="listing-title">libs/simulation/src/animal.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct Animal {
        /* ... */
  =     crate eye: Eye,
  =     crate brain: nn::Network,
    }
    
    impl Animal {
        pub fn random(rng: &mut dyn RngCore) -> Self {
  =         let eye = Eye::default();
  = 
  =         let brain = nn::Network::random(
  =             rng,
  =             &[
                    // The Input Layer
                    //
                    // Because our eye returns Vec<f32>, and our neural
                    // network works on Vec<f32>, we can pass-through
                    // numbers from eye into the neural network directly.
                    //
                    // Had our birdies had, I dunno, ears, we could do
                    // something like: `eye.cells() + ear.nerves()` etc.
  =                 nn::LayerTopology {
  =                     neurons: eye.cells(),
  =                 },
    
                    // The Hidden Layer
                    //
                    // There is no best answer as to "how many neurons
                    // the hidden layer should contain" (or how many
                    // hidden layers there should be, even - there could
                    // be zero, one, two or more!).
                    //
                    // The rule of thumb is to start with a single hidden
                    // layer that has somewhat more neurons that the input
                    // layer, and see how well the network performs.
  =                 nn::LayerTopology {
  =                     neurons: 2 * eye.cells(),
  =                 },
    
                    // The Output Layer
                    //
                    // Since the brain will control our bird's speed and
                    // rotation, this gives us two numbers = two neurons.
  =                 nn::LayerTopology { neurons: 2 },
  =             ],
  =         );
    
            Self {
                /* ... */
  =             eye,
  =             brain,
            }
        }
    
        /* ... */
    }
  -->
</listing>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    // FRAC_PI_2 = PI / 2.0; a convenient shortcut
  = use std::f32::consts::FRAC_PI_2;
    
    /// Minimum speed of a bird.
    ///
    /// Keeping it above zero prevents birds from getting stuck in one place.
  = const SPEED_MIN: f32 = 0.001;
    
    /// Maximum speed of a bird.
    ///
    /// Keeping it "sane" prevents birds from accelerating up to infinity,
    /// which makes the simulation... unrealistic :-)
  = const SPEED_MAX: f32 = 0.005;
    
    /// Speed acceleration; determines how much the brain can affect bird's
    /// speed during one step.
    ///
    /// Assuming our bird is currently flying with speed=0.5, when the brain
    /// yells "stop flying!", a SPEED_ACCEL of:
    ///
    /// - 0.1 = makes it take 5 steps ("5 seconds") for the bird to actually
    ///         slow down to SPEED_MIN,
    ///
    /// - 0.5 = makes it take 1 step for the bird to slow down to SPEED_MIN.
    ///
    /// This improves simulation faithfulness, because - as in real life -
    /// it's not possible to increase speed from 1km/h to 50km/h in one
    /// instant, even if your brain very much wants to.
  = const SPEED_ACCEL: f32 = 0.2;
    
    /// Ditto, but for rotation:
    ///
    /// - 2 * PI = it takes one step for the bird to do a 360° rotation,
    /// - PI = it takes two steps for the bird to do a 360° rotation,
    ///
    /// I've chosen PI/2, because - as our motto goes - this value seems
    /// to play nice.
  = const ROTATION_ACCEL: f32 = FRAC_PI_2;
    
    impl Simulation {
        /* ... */
    
        pub fn step(&mut self, rng: &mut dyn RngCore) {
            self.process_collisions(rng);
  =         self.process_brains();
            self.process_movements();
        }
    
        /* ... */
    
  =     fn process_brains(&mut self) {
  =         for animal in &mut self.world.animals {
  =             let vision = animal.eye.process_vision(
  =                 animal.position,
  =                 animal.rotation,
  =                 &self.world.foods,
  =             );
  = 
  =             let response = animal.brain.propagate(vision);
    
                // ---
                // | Limits number to given range.
                // -------------------- v---v
  =             let speed = response[0].clamp(
  =                 -SPEED_ACCEL,
  =                 SPEED_ACCEL,
  =             );
  = 
  =             let rotation = response[1].clamp(
  =                 -ROTATION_ACCEL,
  =                 ROTATION_ACCEL,
  =             );
    
                // Our speed & rotation here are *relative* - that is: when
                // they are equal to zero, what the brain says is "keep
                // flying as you are now", not "stop flying".
                //
                // Both values being relative is crucial, because our bird's
                // brain doesn't know its own speed and rotation*, meaning
                // that it fundamentally cannot return absolute values.
                //
                // * they'd have to be provided as separate inputs to the
                //   neural network, which would make the evolution process
                //   waaay longer, if even possible.
    
  =             animal.speed =
  =                 (animal.speed + speed).clamp(SPEED_MIN, SPEED_MAX);
  = 
  =             animal.rotation = na::Rotation2::new(
  =                 animal.rotation.angle() + rotation,
  =             );
    
                // (btw, there is no need for ROTATION_MIN or ROTATION_MAX,
                // because rotation automatically wraps from 2*PI back to 0 -
                // we've already witnessed that when we were testing eyes,
                // inside `mod different_rotations { ... }`.)
  =         }
  =     }
    
        /* ... */
    }
  -->
</listing>

<p>Does it work? Let's find out!</p>

<div class="listing-title">$ wasm-pack build</div>

<listing lang="text">
  <!--
    ...
    [INFO]: :-) Done in 12.20s
    [INFO]: :-) Your wasm pkg is ready to publish at /home/pwy/Projects/...
  -->
</listing>

<p>Oh my, oh my, oh my!</p>

<figure>
  <video
    controls=""
    src="{{ assets }}/d8d74b38-d9be-48a2-94b4-f1f917a1a63d.mp4"
  >
    Your browser does not support the video tag.
  </video>
</figure>

<blockquote>
  <p>
    Birds were flying from continent to continent long before we were. They
    reached the coldest place on Earth, Antarctica, long before we did. They can
    survive in the hottest of deserts. Some can remain on the wing for years at
    a time. They can girdle the globe.
  </p>

  <p class="attribution">
      — David Attenborough about our simulation (hypothesized)
  </p>
</blockquote>

<p>
  What we see is enchanting: each bird, equipped with a randomized brain,
  <i>decides</i> where it wants to fly, trying to adjust its behavior to its
  surroundings.
</p>

<p>
  Some of our birds fly in circles, some exhibit more complex behaviors — and,
  if you're lucky (try refreshing the page a few times!), what you'll see is a
  bird actually steering into the food, as if it <i>understood</i>.
</p>

<p>
  Currently this is pure luck though; our next, and the last, milestone will be
  about <i>teaching</i> — we'll augment our simulation with the final piece of
  puzzle: the genetic algorithm.
</p>

<h2 id="huggin-n-evolvin">
  <a href="#huggin-n-evolvin">Huggin' & Evolvin'</a>
</h2>

<p>
  Even though our birds can fly, their brains are entirely random at the
  moment — in this chapter we'll see how we can integrate our simulation with a
  genetic algorithm, so that our birdies can learn & evolve.
</p>

<p>
  Broadly speaking, we want to <b>maximize</b> the amount of food eaten per
  bird — that'll be our fitness function; and the way we'll achieve that is that
  we'll run the simulation for <i>some</i> time (called <b>generation</b>), note
  down how many foods have been eaten by each bird, and then, uhm,
  <i>reproduce</i> the best birdies.
</p>

<p>Let's get to it!</p>

<div class="listing-title">libs/simulation/Cargo.toml</div>

<listing lang="toml">
  <!--
    # ...
    
    [dependencies]
    # ...
    
  = lib-genetic-algorithm = { path = "../genetic-algorithm" }
    lib-neural-network = { path = "../neural-network" }
    
    # ...
  -->
</listing>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
  = use lib_genetic_algorithm as ga;
    use lib_neural_network as nn;
    /* ... */
  -->
</listing>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    /// How much `.step()`-s have to occur before we push data into the
    /// genetic algorithm.
    ///
    /// Value that's too low might prevent the birds from learning, while
    /// a value that's too high will make the evolution unnecessarily
    /// slower.
    ///
    /// You can treat this number as "for how many steps each bird gets
    /// to live"; 2500 was chosen with a fair dice roll.
  = const GENERATION_LENGTH: usize = 2500;
    
    pub struct Simulation {
        world: World,
  =     ga: ga::GeneticAlgorithm<ga::RouletteWheelSelection>,
  =     age: usize,
    }
    
    impl Simulation {
        pub fn random(rng: &mut dyn RngCore) -> Self {
  =         let world = World::random(rng);
  = 
  =         let ga = ga::GeneticAlgorithm::new(
  =             ga::RouletteWheelSelection::default(),
  =             ga::UniformCrossover::default(),
  =             ga::GaussianMutation::new(0.01, 0.3),
  =             // ---------------------- ^--^ -^-^
  =             // | Chosen with a bit of experimentation.
  =             // |
  =             // | Higher values can make the simulation more chaotic,
  =             // | which - a bit counterintuitively - might allow for
  =             // | it to discover *better* solutions; but the trade-off
  =             // | is that higher values might also cause current, good
  =             // | enough solutions to be discarded.
  =             // ---
  =         );
  = 
  =         Self { world, ga, age: 0 }
        }
    
        /* ... */
    
        pub fn step(&mut self, rng: &mut dyn RngCore) {
            self.process_collisions(rng);
            self.process_brains();
            self.process_movements();
    
  =         self.age += 1;
  = 
  =         if self.age > GENERATION_LENGTH {
  =             self.evolve(rng);
  =         }
        }
    
        /* ... */
    
  =     fn evolve(&mut self, rng: &mut dyn RngCore) {
  =         self.age = 0;
  = 
  =         // Step 1: Prepare birdies to be sent into the genetic algorithm
  =         let current_population = todo!();
  = 
  =         // Step 2: Evolve birdies
  =         let evolved_population = self.ga.evolve(
  =             rng,
  =             &current_population,
  =         );
  = 
  =         // Step 3: Bring birdies back from the genetic algorithm
  =         self.world.animals = todo!();
  = 
  =         // Step 4: Restart foods
  =         //
  =         // (this is not strictly necessary, but it allows to easily spot
  =         // when the evolution happens - so it's more of a UI thing.)
  =         for food in &mut self.world.foods {
  =             food.position = rng.gen();
  =         }
  =     }
    }
  -->
</listing>

<p>
  As you might remember, our <code>GenenticAlgorithm::evolve()</code> requires
  for the "evolvable" type to implement a trait called <code>Individual</code>:
</p>

<div class="listing-title">libs/genetic-algorithm/src/lib.rs</div>

<listing lang="rust">
  <!--
    pub fn evolve<I>(
        &self,
        rng: &mut dyn RngCore,
        population: &[I],
    ) -> (Vec<I>, Statistics)
    where
        I: Individual
  -->
</listing>

<p>
  ... so a naïve approach could be to simply implement
  <code>Individual</code> for <code>Animal</code> — after all, birdies
  <i>are</i> the thing we want to evolve:
</p>

<div class="listing-title">libs/simulation/src/animal.rs</div>

<listing lang="rust" class="listing-invalid">
  <!--
    /* ... */
    
    impl ga::Individual for Animal {
        fn create(chromosome: ga::Chromosome) -> Self {
            todo!()
        }
    
        fn chromosome(&self) -> &ga::Chromosome {
            todo!()
        }
    
        fn fitness(&self) -> f32 {
            todo!()
        }
    }
  -->
</listing>

<p>
  But as soon as we try to actually implement those functions, we quickly get
  backed into a corner — for instance: how can we implement
  <code>fn chromosome()</code> that returns a reference to
  <code>ga::Chromosome</code> if our <code>Animal</code> doesn't contain a field
  called <code>chromosome</code>?
</p>

<div class="listing-title">libs/simulation/src/animal.rs</div>

<listing lang="rust" class="listing-invalid">
  <!--
    /* ... */
    
    impl ga::Individual for Animal {
        /* ... */
    
        fn chromosome(&self) -> &ga::Chromosome {
           &self.what // :'-(
        }
    
        /* ... */
    }
  -->
</listing>

<p>
  Granted, you <i>could</i> say that since we control code inside
  <code>lib-genetic-algorithm</code>, we can just change
  <code>fn chromosome()</code> to work on owned <code>Chromosome</code>-s
  instead — and you'd be right! But this doesn't actually solve the underlying
  design issue, merely pushes it somewhere else:
</p>

<div class="listing-title">libs/simulation/src/animal.rs</div>

<listing lang="rust" class="listing-invalid">
  <!--
    /* ... */
    
    impl ga::Individual for Animal {
        fn create(chromosome: ga::Chromosome) -> Self {
            Self {
                position: rng.gen(), // err: we don't have access to PRNG
                                     // in here!
                /* ... */
            }
        }
    
        /* ... */
    }
  -->
</listing>

<p>
  So, for the sake of argument, let's assume that our
  <code>ga::Individual</code> <i>is</i> designed correctly — how can we
  integrate <code>Animal</code> with it, then?
</p>

<p>Most easily — by creating a dedicated struct:</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    mod animal;
  = mod animal_individual;
    /* ... */
    
  = use self::animal_individual::*;
    use lib_genetic_algorithm as ga;
    use lib_neural_network as nn;
    /* ... */
  -->
</listing>

<div class="listing-title">libs/simulation/src/animal_individual.rs</div>

<listing lang="rust">
  <!--
  = use crate::*;
  = 
  = pub struct AnimalIndividual;
  = 
  = impl ga::Individual for AnimalIndividual {
  =     fn create(chromosome: ga::Chromosome) -> Self {
  =         todo!()
  =     }
  = 
  =     fn chromosome(&self) -> &ga::Chromosome {
  =         todo!()
  =     }
  = 
  =     fn fitness(&self) -> f32 {
  =         todo!()
  =     }
  = }
  -->
</listing>

<p>As we see, this structure has to contain at least those two fields:</p>

<div class="listing-title">libs/simulation/src/animal_individual.rs</div>

<listing lang="rust">
  <!--
    use crate::*;
    
  = pub struct AnimalIndividual {
  =     fitness: f32,
  =     chromosome: ga::Chromosome,
  = }
    
    impl ga::Individual for AnimalIndividual {
        fn create(chromosome: ga::Chromosome) -> Self {
  =         Self {
  =             fitness: 0.0,
  =             chromosome,
  =         }
        }
    
        fn chromosome(&self) -> &ga::Chromosome {
  =         &self.chromosome
        }
    
        fn fitness(&self) -> f32 {
  =         self.fitness
        }
    }
  -->
</listing>

<p>Let's go back to <code>fn evolve()</code> and see how it fits there:</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    fn evolve(&mut self, rng: &mut dyn RngCore) {
        self.age = 0;
    
        // Transforms `Vec<Animal>` to `Vec<AnimalIndividual>`
  =     let current_population: Vec<_> = self
  =         .world
  =         .animals
  =         .iter()
  =         .map(|animal| convert Animal to AnimalIndividual)
  =         .collect();
    
        // Evolves this `Vec<AnimalIndividual>`
        let evolved_population = self.ga.evolve(
            rng,
            &current_population,
        );
    
        // Transforms `Vec<AnimalIndividual>` back into `Vec<Animal>`
  =     self.world.animals = evolved_population
  =         .into_iter()
  =         .map(|individual| convert AnimalIndividual to Animal)
  =         .collect();
    
        for food in &mut self.world.foods {
            food.position = rng.gen();
        }
    }
    
    /* ... */
  -->
</listing>

<p>Seems like this might just work!</p>

<p>
  To implement those <code>.map()</code>-s, we'll need two conversion methods:
</p>

<div class="listing-title">libs/simulation/src/animal_individual.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
  = impl AnimalIndividual {
  =     pub fn from_animal(animal: &Animal) -> Self {
  =         todo!()
  =     }
  = 
  =     pub fn into_animal(self, rng: &mut dyn RngCore) -> Animal {
  =         todo!()
  =     }
  = }
    
    /* ... */
  -->
</listing>

<p>... which allow us to:</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    fn evolve(&mut self, rng: &mut dyn RngCore) {
        /* ... */
    
        let current_population: Vec<_> = self
            .world
            .animals
            .iter()
  =         .map(AnimalIndividual::from_animal)
            .collect();
    
        /* ... */
    
        self.world.animals = evolved_population
            .into_iter()
  =         .map(|individual| individual.into_animal(rng))
            .collect();
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>Ok, so: how can we implement those two conversion methods?</p>

<h3>from_animal</h3>

<p>Let's bring into the picture the important bits:</p>

<div class="listing-title">libs/simulation/src/animal_individual.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    pub struct AnimalIndividual {
        fitness: f32,
        chromosome: ga::Chromosome,
    }
    
    impl AnimalIndividual {
        pub fn from_animal(animal: &Animal) -> Self {
  =         Self {
  =             fitness: todo!(),
  =             chromosome: todo!(),
  =         }
        }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>
  What are we supposed to do inside <code>::from_animal()</code>? Well, looks
  like <i>two</i> things:
</p>

<ol>
  <li>
    <p>determine animal's <b>fitness score</b>,</p>
  </li>
  <li>
    <p>determine animal's <b>chromosome</b> (aka <i>genotype</i>).</p>
  </li>
</ol>

<p>
  Finding out fitness score is pretty easy — since we already handle collisions,
  all we've gotta do is to <i>count</i> them:
</p>

<div class="listing-title">libs/simulation/src/animal.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct Animal {
        /* ... */
    
        /// Number of foods eaten by this animal
  =     crate satiation: usize,
    }
    
    impl Animal {
        pub fn random(rng: &mut dyn RngCore) -> Self {
            /* ... */
    
            Self {
                /* ... */
  =             satiation: 0,
            }
        }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
        fn process_collisions(&mut self, rng: &mut dyn RngCore) {
            for animal in &mut self.world.animals {
                for food in &mut self.world.foods {
                    /* ... */
    
                    if distance <= 0.01 {
  =                     animal.satiation += 1;
                        food.position = rng.gen();
                    }
                }
            }
        }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<div class="listing-title">libs/simulation/src/animal_individual.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    impl AnimalIndividual {
        pub fn from_animal(animal: &Animal) -> Self {
            Self {
  =             fitness: animal.satiation as f32,
                chromosome: todo!(),
            }
        }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>Ah, I love when all the pieces just fit together — don't ya'?</p>

<p>
  When it comes to the second field, <code>chromosome</code>, there'll be a bit
  more work there. As a reminder, what we mean by <i>chromosome</i> here is
  <i>weights of the neural network</i>; so ideally we'd write:
</p>

<div class="listing-title">libs/simulation/src/animal_individual.rs</div>

<listing lang="rust" class="listing-invalid">
  <!--
    /* ... */
    
    impl AnimalIndividual {
        pub fn from_animal(animal: &Animal) -> Self {
            Self {
                /* ... */
  =             chromosome: animal.brain.weights(),
            }
        }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>
  ... but our <code>lib-neural-network</code>-'s <code>Network</code> doesn't
  have such method…​ yet!
</p>

<p>
  To implement <code>.weights()</code>, let's go back to
  <code>lib-neural-network</code> — what we're looking for is:
</p>

<div class="listing-title">libs/neural-network/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Network {
        /* ... */
    
  =     pub fn weights(&self) -> Vec<f32> {
  =         todo!()
  =     }
    }
    
    /* ... */
  -->
</listing>

<p>'cause we're <i>good programmers</i>, let's start with a test:</p>

<div class="listing-title">libs/neural-network/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[cfg(test)]
    mod tests {
        /* ... */
    
  =     mod weights {
  =         use super::*;
  = 
  =         #[test]
  =         fn test() {
  =             let network = Network::new(vec![
  =                 Layer::new(vec![Neuron::new(0.1, vec![0.2, 0.3, 0.4])]),
  =                 Layer::new(vec![Neuron::new(0.5, vec![0.6, 0.7, 0.8])]),
  =             ]);
  = 
  =             let actual = network.weights();
  =             let expected = vec![0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8];
  = 
  =             approx::assert_relative_eq!(
  =                 actual.as_slice(),
  =                 expected.as_slice(),
  =             );
  =         }
  =     }
    }
  -->
</listing>

<p>
  As for the implementation, I'll show you two of them — one uses explicit
  <code>for</code> loops, while the other works on combinators; barring some
  preallocation stuff, both are equivalent:
</p>

<ol>
  <li>
    <p>Explicit loops:</p>

    <div class="listing-title">libs/neural-network/src/lib.rs</div>

    <listing lang="rust">
      <!--
        pub fn weights(&self) -> Vec<f32> {
      =     let mut weights = Vec::new();
      = 
      =     for layer in &self.layers {
      =         for neuron in &layer.neurons {
      =             weights.push(neuron.bias);
      = 
      =             for weight in &neuron.weights {
      =                 weights.push(*weight);
      =             }
      =         }
      =     }
      = 
      =     weights
        }
      -->
    </listing>
  </li>
  <li>
    <p>Combinators:</p>

    <div class="listing-title">libs/neural-network/src/lib.rs</div>

    <listing lang="rust">
      <!--
        pub fn weights(&self) -> Vec<f32> {
      =     use std::iter::once;
      = 
      =     self.layers
      =         .iter()
      =         .flat_map(|layer| layer.neurons.iter())
      =         .flat_map(|neuron| once(&neuron.bias).chain(&neuron.weights))
      =         .copied()
      =         .collect()
        }
      -->
    </listing>
  </li>
</ol>

<p>
  I consider the combinator approach more idiomatic as it allows to avoid
  allocating <i>any</i> vector:
</p>

<listing lang="rust">
  <!--
    pub fn weights(&self) -> impl Iterator<Item = f32> + '_ {
        self.layers
            .iter()
            .flat_map(|layer| layer.neurons.iter())
            .flat_map(|neuron| once(&neuron.bias).chain(&neuron.weights))
            .copied()
    }
  -->
</listing>

<p>
  ... but, when push comes to shove, maintenability is usually more important
  than performance, so choose whichever version you prefer :-)
</p>

<p>
  Also, while we're here, let's implement an inverse method we'll need
  later — <code>::from_weights()</code>:
</p>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Network {
        /* ... */
    
  =     pub fn from_weights(
  =         layers: &[LayerTopology],
  =         weights: impl IntoIterator<Item = f32>,
  =     ) -> Self {
  =         todo!()
  =     }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>Ideally, we'd like for the following identity to hold:</p>

<listing lang="rust">
  <!--
    network == Network::from_weights(network.weights())
  -->
</listing>

<p>... so let's base our tests exactly on that:</p>

<listing lang="rust">
  <!--
    /* ... */
    
    #[cfg(test)]
    mod tests {
        /* ... */
    
  =     mod from_weights {
  =         use super::*;
  = 
  =         #[test]
  =         fn test() {
  =             let layers = &[
  =                 LayerTopology { neurons: 3 },
  =                 LayerTopology { neurons: 2 },
  =             ];
  = 
  =             let weights = vec![0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8];
  = 
  =             let network = Network::from_weights(layers, weights.clone());
  =             let actual: Vec<_> = network.weights().collect();
  = 
  =             approx::assert_relative_eq!(
  =                 actual.as_slice(),
  =                 weights.as_slice(),
  =             );
  =         }
  =     }
    
        /* ... */
    }
  -->
</listing>

<p>... and then an example implementation could be:</p>

<div class="listing-title">libs/neural-network/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Network {
        /* ... */
    
  =     pub fn from_weights(
  =         layers: &[LayerTopology],
  =         weights: impl IntoIterator<Item = f32>,
  =     ) -> Self {
  =         assert!(layers.len() > 1);
  = 
  =         let mut weights = weights.into_iter();
  = 
  =         let layers = layers
  =             .windows(2)
  =             .map(|layers| {
  =                 Layer::from_weights(
  =                     layers[0].neurons,
  =                     layers[1].neurons,
  =                     &mut weights,
  =                 )
  =             })
  =             .collect();
  = 
  =         if weights.next().is_some() {
  =             panic!("got too many weights");
  =         }
  = 
  =         Self { layers }
  =     }
    
        /* ... */
    }
    
    impl Layer {
        /* ... */
    
  =     pub fn from_weights(
  =         input_size: usize,
  =         output_size: usize,
  =         weights: &mut dyn Iterator<Item = f32>,
  =     ) -> Self {
  =         let neurons = (0..output_size)
  =             .map(|_| Neuron::from_weights(input_size, weights))
  =             .collect();
  = 
  =         Self { neurons }
  =     }
    
        /* ... */
    }
    
    impl Neuron {
        /* ... */
    
  =     pub fn from_weights(
  =         output_neurons: usize,
  =         weights: &mut dyn Iterator<Item = f32>,
  =     ) -> Self {
  =         let bias = weights.next().expect("got not enough weights");
  = 
  =         let weights = (0..output_neurons)
  =             .map(|_| weights.next().expect("got not enough weights"))
  =             .collect();
  = 
  =         Self { bias, weights }
  =     }
    
        /* ... */
    }
  -->
</listing>

<p>
  Recreating network from weights is quite complex, so don't worry if this code
  takes a moment to sink-in — took a while to write, too!
</p>

<h3>Refactoring</h3>

<p>
  Our <code>Network</code> has now everything we need to make it compatible with
  genetic algorithm — but before we do that, let's take a moment to refactor one
  thing.
</p>

<p>Inside our <code>Animal</code>, what we have now is:</p>

<div class="listing-title">libs/simulation/src/animal.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct Animal {
        /* ... */
        crate brain: nn::Network,
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>
  ... and what I have on mind is to refactor
  <code>brain: nn::Network</code> into a distinct, em, body part:
</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
  = pub use self::{animal::*, brain::*, eye::*, food::*, world::*};
    
    mod animal;
    mod animal_individual;
  = mod brain;
    /* ... */
  -->
</listing>

<div class="listing-title">libs/simulation/src/brain.rs</div>

<listing lang="rust">
  <!--
  = use crate::*;
  = 
  = #[derive(Debug)]
  = pub struct Brain {
  =     crate nn: nn::Network,
  = }
  = 
  = impl Brain {
  =     pub fn random(rng: &mut dyn RngCore, eye: &Eye) -> Self {
  =         Self {
  =             nn: nn::Network::random(rng, &Self::topology(eye)),
  =         }
  =     }
  = 
  =     crate fn as_chromosome(&self) -> ga::Chromosome {
  =         self.nn.weights().collect()
  =     }
  = 
  =     fn topology(eye: &Eye) -> [nn::LayerTopology; 3] {
  =         [
  =             nn::LayerTopology {
  =                 neurons: eye.cells(),
  =             },
  =             nn::LayerTopology {
  =                 neurons: 2 * eye.cells(),
  =             },
  =             nn::LayerTopology { neurons: 2 },
  =         ]
  =     }
  = }
  -->
</listing>

<div class="listing-title">libs/simulation/src/animal.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[derive(Debug)]
    pub struct Animal {
        /* ... */
  =     crate brain: Brain,
        /* ... */
    }
    
    impl Animal {
  =     pub fn random(rng: &mut dyn RngCore) -> Self {
  =         let eye = Eye::default();
  =         let brain = Brain::random(rng, &eye);
  = 
  =         Self::new(eye, brain, rng)
  =     }
    
  =     crate fn as_chromosome(&self) -> ga::Chromosome {
  =         // We evolve only our birds' brains, but technically there's no
  =         // reason not to simulate e.g. physical properties such as size.
  =         //
  =         // If that was to happen, this function could be adjusted to
  =         // return a longer chromosome that encodes not only the brain,
  =         // but also, say, birdie's color.
  = 
  =         self.brain.as_chromosome()
  =     }
    
        /* ... */
    
  =     fn new(eye: Eye, brain: Brain, rng: &mut dyn RngCore) -> Self {
  =         Self {
  =             position: rng.gen(),
  =             rotation: rng.gen(),
  =             speed: 0.002,
  =             eye,
  =             brain,
  =             satiation: 0,
  =         }
  =     }
    }
  -->
</listing>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    fn process_brains(&mut self) {
        for animal in &mut self.world.animals {
            /* ... */
    
  =         let response = animal.brain.nn.propagate(vision);
    
            /* ... */
        }
    }
  -->
</listing>

<p>
  All this allows us to complete <code>AnimalIndividual::from_animal()</code>:
</p>

<div class="listing-title">libs/simulation/src/animal_individual.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    impl AnimalIndividual {
        pub fn from_animal(animal: &Animal) -> Self {
            Self {
                fitness: animal.satiation as f32,
  =             chromosome: animal.as_chromosome(),
            }
        }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>Once again, all the pieces fit together 🥳</p>

<h3>into_animal</h3>

<p>
  With our latest changes we can transform <code>Animal</code> into
  <code>AnimalIndividual</code> and send it into the genetic algorithm — now
  it's time to implement the reverse operation: given a brand-new
  <code>AnimalIndividual</code> fresh from the genetic algorithm, we have to
  convert it into <code>Animal</code>:
</p>

<div class="listing-title">libs/simulation/src/animal_individual.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    impl AnimalIndividual {
        /* ... */
    
        pub fn into_animal(self, rng: &mut dyn RngCore) -> Animal {
  =         Animal::from_chromosome(self.chromosome, rng)
        }
    }
    
    /* ... */
  -->
</listing>

<div class="listing-title">libs/simulation/src/animal.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Animal {
        /* ... */
    
        /// "Restores" bird from a chromosome.
        ///
        /// We have to have access to the PRNG in here, because our
        /// chromosomes encode only the brains - and while we restore the
        /// bird, we have to also randomize its position, direction, etc.
        /// (so it's stuff that wouldn't make sense to keep in the genome.)
  =     crate fn from_chromosome(
  =         chromosome: ga::Chromosome,
  =         rng: &mut dyn RngCore,
  =     ) -> Self {
  =         let eye = Eye::default();
  =         let brain = Brain::from_chromosome(chromosome, &eye);
  = 
  =         Self::new(eye, brain, rng)
  =     }
    
        crate fn as_chromosome(&self) -> ga::Chromosome {
            self.brain.as_chromosome()
        }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<div class="listing-title">libs/simulation/src/brain.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Brain {
        /* ... */
    
  =     crate fn from_chromosome(
  =         chromosome: ga::Chromosome,
  =         eye: &Eye,
  =     ) -> Self {
  =         Self {
  =             nn: nn::Network::from_weights(
  =                 &Self::topology(eye),
  =                 chromosome,
  =             ),
  =         }
  =     }
    
        crate fn as_chromosome(&self) -> ga::Chromosome {
            self.nn.weights().collect()
        }
    
        /* ... */
    }
  -->
</listing>

<p>Looks like…​ we're done! Are we done??</p>

<h2 id="ready-set">
  <a href="#ready-set">Ready, Set…​</a>
</h2>

<p>
  We're <i>kinda-sorta</i> done — while you could just launch
  <code>wasm-pack build</code>, take your binoculars and start to watch wildlife
  freely flying and electively evolving on your screen now, there are two things
  we can do to make this experience more rewarding:
</p>

<ol>
  <li>
    <p>
      First of all: since evolution happens once every 2500 steps, and we
      perform 60 steps per second (there's one step per one frame, and the
      browser tries to keep steady 60 FPS), then in real-time we're talking
      about <b>one evolution per ~40 seconds</b>.
    </p>

    <p>
      If we wanted to witness birdies getting smarter and smarter, we'd have to
      wait around 10 generations (speaking from experience), so roughly 6.5
      minutes. <b>6.5 minutes</b> of bluntly staring into the screen — <a
        href="https://xkcd.com/1205/"
        >what a waste of time</a
      >!
    </p>

    <p>
      <i
        >(though i'm very into this kind of stuff — there's no
        screentime-shaming on this blog, my pal)</i
      >
    </p>

    <p>But if we had some kind of a "fast-forward" button…​</p>
  </li>
  <li>
    <p>
      Second of all: even <i>if</i> evolution works (with big emphasis on
      <i>if</i>, 'cause - you know - we're skeptics!), at the moment we'd have
      no way of knowing.
    </p>

    <p>
      I mean, do our current birds <b>really</b> fly better than those from five
      minutes ago?
    </p>

    <p>
      Luckily to us, because we're <span class="text-rainbow">digital</span>,
      finding evidence for evolution gets pretty easy: we'll just enhance
      <code>lib-genetic-algorithm</code> so that it returns statistics — such as
      an average fitness score — and we'll use <code>console.log()</code> to see
      if those statistics grow!
    </p>
  </li>
</ol>

<p>&lt;slowly-breaths-out/&gt;</p>

<p>
  Our journey heads towards its end — the code that we'll write in a moment will
  be the culminating point of all the hard work we've done over the past months.
  I'd like to thank you for taking the time to go through all of this, and I
  hope this project was at least partially as interesting to you as it was to
  me.
</p>

<p>
  So, my friend — are you ready to knock on wood and begin our final
  birdie-adventure?
</p>

<h3>Fast-Forward & Statistics</h3>

<p>
  Inside our JavaScript code we invoke <code>.step()</code> <i>only</i> during
  <code>redraw()</code> — that's what makes our simulation "stuck" to 60 FPS:
</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
    function redraw() {
        /* ... */
    
        simulation.step();
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>
  To make our simulation faster, we could either invoke
  <code>.step()</code> many times at once:
</p>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
    function redraw() {
        /* ... */
    
        // Performs 10 steps per frame, which makes simulation 10x faster
        // (at least if your computer can catch up!)
        for (let i = 0; i < 10; i += 1) {
            simulation.step();
        }
    
        /* ... */
    }
    
    /* ... */
  -->
</listing>

<p>
  ... or, a bit better, we could provide a dedicated method that "fast-forwards"
  an entire generation; this way we could keep the simulation running at 1x
  speed, and only bind this "fast-forwarding" to a button; make it fast-forward
  on-demand.
</p>

<p>
  To use a shorter noun, instead of calling it <code>fn fast_forward()</code>,
  let's go with <code>fn train()</code>:
</p>

<div class="listing-title">libs/simulation/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
  =     pub fn step(&mut self, rng: &mut dyn RngCore) -> bool {
            /* ... */
    
            self.age += 1;
    
            if self.age > GENERATION_LENGTH {
                self.evolve(rng);
  =             true
  =         } else {
  =             false
  =         }
        }
    
        /// Fast-forwards 'till the end of the current generation.
  =     pub fn train(&mut self, rng: &mut dyn RngCore) {
  =         loop {
  =             if self.step(rng) {
  =                 return;
  =             }
  =         }
  =     }
    
        /* ... */
    }
  -->
</listing>

<div class="listing-title">libs/simulation-wasm/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[wasm_bindgen]
    impl Simulation {
        /* ... */
    
  =     pub fn train(&mut self) {
  =         self.sim.train(&mut self.rng);
  =     }
    }
    
    /* ... */
  -->
</listing>

<div class="listing-title">www/index.html</div>

<listing lang="html">
  <!--
    <!-- ... -\->
    <style>
      /* ... */
    
  =   #train {
  =       position: absolute;
  =       top: 0;
  =       margin: 15px;
  =   }
    </style>
    <body>
      <canvas id="viewport" width="800" height="800"></canvas>
  =   <button id="train">train please, thank u</button>
      <script src="./bootstrap.js"></script>
    </body>
    <!-- ... -\->
  -->
</listing>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    import * as sim from "lib-simulation-wasm";
    
    let simulation = new sim.Simulation();
    
  = document.getElementById('train').onclick = function() {
  =     simulation.train();
  = };
    
    const viewport = document.getElementById('viewport');
    const viewportScale = window.devicePixelRatio || 1;
    
    /* ... */
  -->
</listing>

<aside class="note">
  <blockquote>
    <p>
      But wait — doesn't this code require some kind of <code>RwLock</code> or
      <code>Mutex</code>?
    </p>

    <p>
      I mean, what happens when user clicks
      <code>train please, thank u</code> during the time <code>.step()</code> is
      working — won't this cause our Rust code to be invoked twice
      <i>at the same time</i>, destroying the entire universe and everything we
      love?
    </p>
  </blockquote>

  <p>
    Fear not: as I mentioned before, JavaScript is single threaded — when
    browser executes our <code>.step()</code> (or rather <code>redraw()</code>),
    it "hangs" the tab.
  </p>

  <p>
    <a
      href="https://stackoverflow.com/questions/2734025/is-javascript-guaranteed-to-be-single-threaded/2734311#2734311"
      >Simplifying a bit</a
    >, you could say that at a time only one line of JavaScript code is
    running — it's not possible to execute both <code>.step()</code> and
    <code>.train()</code> at once (which would also violate the
    <code>&mut self</code> requirement on the Rust's side); if user clicks
    <code>train</code> when <code>.step()</code> is working, the browser will
    schedule the click event to be executed in the next frame.
  </p>
</aside>

<p>
  Ok, now that we can speed-up the evolution, let's get our hands dirty with
  statistics — the simplest thing we have at hand are fitness scores, so
  <code>lib-genetic-algorithm</code> seems like a nice place to implement them:
</p>

<div class="listing-title">libs/genetic-algorithm/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
  = #[derive(Clone, Debug)]
  = pub struct Statistics {
  =     min_fitness: f32,
  =     max_fitness: f32,
  =     avg_fitness: f32,
  = }
    
    /* ... */
    
    impl<S> GeneticAlgorithm<S>
    where
        S: SelectionMethod,
    {
        /* ... */
    
  =     pub fn evolve<I>(/* ... */) -> (Vec<I>, Statistics)
        where
            I: Individual,
        {
            assert!(!population.is_empty());
    
            let new_population = (0..population.len())
                .map(|_| {
                    /* ... */
                })
                .collect();
    
  =         let stats = Statistics::new(population);
  = 
  =         (new_population, stats)
        }
    }
    
    /* ... */
    
  = impl Statistics {
  =     fn new<I>(population: &[I]) -> Self
  =     where
  =         I: Individual,
  =     {
  =         assert!(!population.is_empty());
  = 
  =         let mut min_fitness = population[0].fitness();
  =         let mut max_fitness = min_fitness;
  =         let mut sum_fitness = 0.0;
  = 
  =         for individual in population {
  =             let fitness = individual.fitness();
  = 
  =             min_fitness = min_fitness.min(fitness);
  =             max_fitness = max_fitness.max(fitness);
  =             sum_fitness += fitness;
  =         }
  = 
  =         Self {
  =             min_fitness,
  =             max_fitness,
  =             avg_fitness: sum_fitness / (population.len() as f32),
  =         }
  =     }
  = 
  =     pub fn min_fitness(&self) -> f32 {
  =         self.min_fitness
  =     }
  = 
  =     pub fn max_fitness(&self) -> f32 {
  =         self.max_fitness
  =     }
  = 
  =     pub fn avg_fitness(&self) -> f32 {
  =         self.avg_fitness
  =     }
  = }
  -->
</listing>

<listing lang="rust">
  <!--
    /* ... */
    
    impl Simulation {
        /* ... */
    
  =     pub fn step(
  =         &mut self,
  =         rng: &mut dyn RngCore,
  =     ) -> Option<ga::Statistics> {
            /* ... */
    
            if self.age > GENERATION_LENGTH {
  =             Some(self.evolve(rng))
            } else {
  =             None
            }
        }
    
  =     pub fn train(&mut self, rng: &mut dyn RngCore) -> ga::Statistics {
            loop {
  =             if let Some(summary) = self.step(rng) {
  =                 return summary;
                }
            }
        }
    
        /* ... */
    
  =     fn evolve(&mut self, rng: &mut dyn RngCore) -> ga::Statistics {
            /* ... */
    
  =         let (evolved_population, stats) = self.ga.evolve(
            /* ... */
    
  =         stats
        }
    }
  -->
</listing>

<div class="listing-title">libs/simulation-wasm/src/lib.rs</div>

<listing lang="rust">
  <!--
    /* ... */
    
    #[wasm_bindgen]
    impl Simulation {
        /* ... */
    
        /// min = minimum amount of food eaten by any bird
        ///
        /// max = maximum amount of food eaten by any bird
        ///
        /// avg = sum of all the food eaten by all the birds,
        ///       divided by the number of birds
        ///
        /// Median could also come useful!
  =     pub fn train(&mut self) -> String {
  =         let stats = self.sim.train(&mut self.rng);
  = 
  =         format!(
  =             "min={:.2}, max={:.2}, avg={:.2}",
  =             stats.min_fitness(),
  =             stats.max_fitness(),
  =             stats.avg_fitness()
  =         )
  =     }
    }
  -->
</listing>

<div class="listing-title">www/index.js</div>

<listing lang="javascript">
  <!--
    /* ... */
    
    document.getElementById('train').onclick = function() {
  =     console.log(simulation.train());
    };
    
    /* ... */
  -->
</listing>

<p>
  This time, when building, don't forget about the
  <code>--release</code> switch — it enables optimizations which are
  <i>crucial</i> to get <code>.train()</code> working at a reasonable
  performance:
</p>

<div class="listing-title">$ wasm-pack build --release</div>

<listing lang="text">
  <!--
    ...
    [INFO]: :-) Done in 40.00s
    [INFO]: :-) Your wasm pkg is ready to publish at /home/pwy/Projects/...
  -->
</listing>

<h2 id="ready-set-go">
  <a href="#ready-set-go">Ready, Set, Go!</a>
</h2>

<p>
  Finally, ultimately, eventually, <i>at long</i> — the outcome of our diligent,
  assiduous coding; u ready?
</p>

<figure>
  <video
    src="{{ assets }}/3c9592ed-e1ef-4fc5-8b72-607fc9692a25.mp4"
    controls=""
  >
    Your browser does not support the video tag.
  </video>
</figure>

<style>
  #_tada {
    margin-top: 0.3em;
    text-align: center;
    font-size: 3em;
  }
</style>

<div id="_tada">🎉</div>

<p>Nice?</p>

<ul>
  <li>
    <p>birdies are cute? ✅</p>
  </li>
  <li>
    <p>birdies eat food? ✅</p>
  </li>
  <li>
    <p>birdies learn to catch food better and better? ✅</p>
  </li>
</ul>

<p>Nice!</p>

<aside class="note">
  <p>
    The concrete statistics you get are most likely different than mine, but the
    general trend — min, max and average going up — should be visible in most of
    the simulations.
  </p>

  <p>
    The results won't be rising up to infinity - from what I saw, most of the
    time you'll get averages up to 40~50, everything above will be pretty much
    exceptional.
  </p>

  <p>
    Also, please remember that we're putting a lot of faith in random
    numbers! — if your birds seem to be getting stuck in local optimum too soon,
    try refreshing the simulation.
  </p>
</aside>

<h2 id="closing-thoughts">
  <a href="#closing-thoughts">Closing Thoughts</a>
</h2>

<p>Started from the bottom, haven't we?</p>

<p>
  Started from rough sketches, got through our very first
  <code>struct Network</code>, designed genetic algorithm, implemented tests for
  <i>eyes</i> (how awesome is that!), to end up with a bunch of self-governing
  birdies that certainly don't seem to look like <i>this much</i> code on the
  surface :-)
</p>

<p>
  Since I've already done the sentimental part in the previous section, in here
  let me just re-thank you for your time — I hope this series showed you a fair
  share of Rust idioms, testing techniques, and delivered on its promise of
  using WebAssembly in an interesting way.
</p>

<p>And, champ, that's for you:</p>

<figure class="sketch w-70">
  <img
    src="{{ assets }}/sketches/e5313753-9b47-4c39-a198-df190f2db9c4.svg"
  />

  <figcaption>
    <div class="title">
      A <a href="https://en.wikipedia.org/wiki/Horned_lark">shorelark</a> (or at
      least my attempt at drawing one)
    </div>
  </figcaption>
</figure>

<h3>What now?</h3>

<p>
  If you want to fiddle a bit on your own, there's still a few things to do
  here, simulation-wise!
</p>

<p>You remember all those constants such as <code>FOV_RANGE</code>?</p>

<p>
  If instead of keeping them hard-coded, you made them configurable via some
  <code>struct Config</code>, you could then create an application that'd
  traverse different combinations of those parameters, trying to find the most
  optimal ones:
</p>

<listing lang="rust">
  <!--
    let mut stats = Vec::new();
    
    for fov_range in vec![0.1, 0.2, 0.3, 0.4, ..., PI] {
        for fov_distance in vec![0.1, 0.2, 0.3, 0.4, ..., 1.0] {
            let current_stats = run_simulation(
                fov_range,
                fov_distance,
                /* ... */,
            );
    
            stats.push((fov_range, fov_distance, current_stats));
        }
    }
    
    // TODO using `stats`, find out which combinations yielded the best
    //      results :-)
  -->
</listing>

<p>
  Bonus points for using <a href="https://github.com/rayon-rs/rayon">rayon</a>!
</p>

<p>
  As a reminder: the entire source code, a bit refactored, is available
  <a href="https://github.com/patryk27/shorelark">at my GitHub</a>; if you just
  skimmed this article and/or don't feel like copy-pasting all the snippets, you
  can simply clone that repository and start from there.
</p>

<h3>What’s next?</h3>

<p>
  I've got a few ideas on mind — I'm thinking ATmega328p + Rust + <i>light</i> =
  &lt;3; we'll see how things play out :-)
</p>

<p>Until next time!</p>
