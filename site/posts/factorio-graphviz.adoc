---
title: "Graphviz in the service of Factorio"
tags: [ "dot", "factorio", "graphviz" ]
---

In this article I present the way I piggyback on Graphviz's `dot` engine to make building factories in Factorio a bit
easier, more approachable and wholesome.

<!--more-->

Enjoy.

== Abstract

[quote, https://factorio.com]
Factorio is a game in which you build and maintain factories.

You start the game spawned somewhere on an alien planet, with nothing more than yourself and some nearby ores.

At the beginning you start digging coal, iron and copper all by hand, but in time you realize this won't do - you need
to automate production lines, you need to automate mining lines and you need _machines_.

todo: screenshot of my current base

One of the first things that heavily rely on automation are laboratories - they consume _science packs_ and, in favor,
provide various technological advantages like better military or fancy electronic stuff.

For instance:

- unlocking _steel processing_ costs 50 automation science packs,

- unlocking _plastics_ costs 200 automation science packs and the same number of logistic science packs,

- unlocking _atomic bomb_ costs 5000 units of six different science packs (not including the preceding research
required to even get to this point in game).

If you haven't played Factorio yet, just to give you a sense of scale: were you to unlock steel processing by hand,
assuming you already had laboratories in place, you'd have to invest about @todo minutes just to craft all the 50
required science packs. So, as you might imagine, doing that for 5000k * 6 science packs would be a rather gruesome act
of self-mutilation, but hey - it's a sandbox after all.

Also, if you haven't played Factorio yet - I highly encourage you to give it a try!

== Case study: Logistic science pack

We've started the game, built a few mining drills and got a basic electrical grid set-up - time for science.

Certainly, we need some laboratories:

@todo screenshot

Now, for our laboratories to work, we need a production line that will provide a constant flow of science packs; first,
let's focus on https://wiki.factorio.com/Logistic_science_pack[logistic science packs].

As we can find on Factorio's Wiki:

- To produce `1 logistic science pack`, we'll need `1 inserter` and `1 transport belt`.

- Next, to produce that `1 inserter`, we'll need `1 electronic circuit`, `1 iron gear wheel` and `1 iron plate`.

- Next, to produce _that_ `1 electronic circuit`, we'll need.. well, describing this in English gets tedious; what do
you say we invent some notation to make things simpler?

Let's start with a bare minimum text format of:

----
product
    requirements
----

_Oh, even just thinking about all the elegant stuff we can do with this grammar gives me shivers running down my spine!_

Translating the former requirements, we get:

----
logistic-science-pack
    inserter
    transport-belt
----

Since both the `inserter` and `transport-belt` need to be produced too, let's expand them:

----
logistic-science-pack
    inserter
        electronic-circuit
        iron-gear-wheel
    transport-belt
        iron-plate
        iron-gear-wheel
----

It's going good - let's expand everything up to `iron-plate` & `copper-plate`, because they are essentially "primitive
components" available freely within my factory.

[NOTE]
====
Some people like to construct https://wiki.factorio.com/Tutorial:Main_bus[main buses] with different constituents -
e.g. if you have an abundance of electronic circuits, you might treat _them_ as primitive and stop expanding there.
====

----
logistic-science-pack
    inserter
        electronic-circuit
            copper-cable
                copper-plate
            iron-plate
        iron-gear-wheel
            iron-plate
        iron-plate
    transport-belt
        iron-plate
        iron-gear-wheel
            iron-plate
----

That's the entire recipe: it lists all the materials we need to either fetch (like `copper-plate`) or create
(like `transport-belt`) in order to end up with a `logistic science pack`, neat!

It's certainly of _some_ help, although it still doesn't tell us e.g. where to place the assembly machines -
fortunately, *graphs* come to the rescue!

== Introduction to graphs

Graphs are structures used to model relationships between objects - thanks to graphs you can create e.g. a family tree
or a network of your friends.

For instance, here's an undirected graph presenting me and my dog's mates:

[graphviz, format=svg, opts=inline]
----
graph {
    rankdir = "LR"

    Patryk -- Dafne
    Dafne -- Niko
    Dafne -- Dulcia
    Dulcia -- Charlie
}
----

\... and, for comparison, a directed one (with arrows dictating the relationship's direction):

[graphviz, format=svg, opts=inline]
----
digraph {
    rankdir = "LR"

    Patryk -> Dafne
    Dafne -> Patryk

    Dafne -> Niko
    Dafne -> Dulcia
    Dulcia -> Charlie
}
----

Graphs can be drawn by hand (on a piece of paper or using Inkscape), which gets exponentially difficult for larger and
larger graphs, or using dedicated software, like https://www.graphviz.org[Graphviz].

For instance, here's the source code - written in the https://en.wikipedia.org/wiki/DOT_(graph_description_language)[DOT language] -
of the graph you see above:

[source, dot]
----
# This instruction starts a directed graph
digraph {
    # This instruction makes the graph go left-right
    rankdir = "LR"

    # Those instructions define all the nodes and their connections
    Patryk -> Dafne
    Dafne -> Patryk
    Dafne -> Niko
    Dafne -> Dulcia
    Dulcia -> Charlie
}
----

[NOTE]
====
There are many fantastic online tools that you can use to fiddle with graphs written in the DOT language; I frequently
use https://dreampuf.github.io/GraphvizOnline - you can just copy-paste the code above and get yourself a nice graph.
====

Take a minute to get comfortable with this syntax and, if you're ready, notice one peculiar thing:

Contrary to drawing graphs manually, using the DOT language we don't have to specify _where_ to place each node: we said
`Patryk -> Dafne`, `Dafne -> Niko` and the program almost magically *laid out* the entire graph for us.

[NOTE]
====
The overall subject of pretty-printing graphs is called https://en.wikipedia.org/wiki/Graph_drawing[graph drawing] /
https://en.wikipedia.org/wiki/Force-directed_graph_drawing[force-directed graph drawing] - if you find yourself having
too much spare time, it's a nice rabbit hole to go down for a side programming-project!
====

We're going to exploit this very feature to answer our original problem: having a list of requirements, how should we
lay our assembly machines and wire them up?

== Case study: Logistic science pack (cont.)

Let's recap our recipe:

----
logistic-science-pack
    inserter
        electronic-circuit
            copper-cable
                copper-plate
            iron-plate
        iron-gear-wheel
            iron-plate
        iron-plate
    transport-belt
        iron-plate
        iron-gear-wheel
            iron-plate
----

Since Graphviz doesn't understand our freshly-invented notation, first we have to translate it into a `DOT` file.

Let's begin with the final product:

[.row]
--
[.col]
[source, dot]
----
digraph {
    # DOT language forbids using `-` in names, so
    # we use `_` instead:

    logistic_science_pack
}
----

[.col.center-h.center-v]
[graphviz, format=svg, opts=inline]
----
digraph {
    logistic_science_pack
}
----
--

Now let's add the first set of requirements:

[.row]
--
[.col]
[source, dot]
----
digraph {
    logistic_science_pack
    inserter -> logistic_science_pack
    transport_belt -> logistic_science_pack
}
----

[.col.center-h.center-v]
[graphviz, format=svg, opts=inline]
----
digraph {
    logistic_science_pack
    inserter -> logistic_science_pack
    transport_belt -> logistic_science_pack
}
----
--

And so on, and so forth, until we finally end up with:

@todo sort the code appropriately

[.row]
--
[.col]
[source, dot]
----
digraph {
    copper_plate -> copper_cable
    copper_cable -> electronic_circuit
    iron_plate -> electronic_circuit
    electronic_circuit -> inserter
    iron_gear_wheel -> inserter
    iron_plate -> inserter
    iron_plate -> iron_gear_wheel
    inserter -> logistic_science_pack
    transport_belt -> logistic_science_pack
    iron_gear_wheel -> transport_belt
    iron_plate -> transport_belt
}
----

[.col]
[graphviz, format=svg, opts=inline]
----
digraph {
    copper_plate -> copper_cable
    copper_cable -> electronic_circuit
    iron_plate -> electronic_circuit
    electronic_circuit -> inserter
    iron_gear_wheel -> inserter
    iron_plate -> inserter
    iron_plate -> iron_gear_wheel
    inserter -> logistic_science_pack
    transport_belt -> logistic_science_pack
    iron_gear_wheel -> transport_belt
    iron_plate -> transport_belt
}
----
--

Woo hoo, we've finally extracted some _new_ information from the system - namely: *placement* and *wiring*!

Granted, it's not perfect (we can't actually build curvy transport belts), but at least we've got _some_ visualisation
right in front of our eyes - now let's try to improve it.

We'll start by forcing the edges (the lines) to be straight via `splines = ortho`:

[NOTE]
====
There are many other spline algorithms you can experiment with - you can find them all in the
https://www.graphviz.org/doc/info/attrs.html#d:splines[documentation].
====

[.row]
--
[.col]
[source, dot]
----
digraph {
    splines = ortho

    copper_plate -> copper_cable
    copper_cable -> electronic_circuit
    iron_plate -> electronic_circuit
    electronic_circuit -> inserter
    iron_gear_wheel -> inserter
    iron_plate -> inserter
    iron_plate -> iron_gear_wheel
    inserter -> logistic_science_pack
    transport_belt -> logistic_science_pack
    iron_gear_wheel -> transport_belt
    iron_plate -> transport_belt
}
----

[.col]
[graphviz, format=svg, opts=inline]
----
digraph {
    splines = ortho

    copper_plate -> copper_cable
    copper_cable -> electronic_circuit
    iron_plate -> electronic_circuit
    electronic_circuit -> inserter
    iron_gear_wheel -> inserter
    iron_plate -> inserter
    iron_plate -> iron_gear_wheel
    inserter -> logistic_science_pack
    transport_belt -> logistic_science_pack
    iron_gear_wheel -> transport_belt
    iron_plate -> transport_belt
}
----
--

It's better, but still kinda sloppy; since in my factory copper plates will be transported next to iron plates, it would
be more helpful to align `copper_plate` on the same level as `iron_plate`.

Luckily, Graphviz has our backs covered - shake hands with (and properly wash them after) the `rank` instruction:

[source, dot]
----
digraph {
    splines = ortho

    {
        # This instruction tells Graphviz to align all
        # nodes located in this block next to each other
        rank = same

        copper_plate
        iron_plate
    }

    /* ... */
}
----

[graphviz, format=svg, opts=inline]
----
digraph {
    splines = ortho

    {
        rank = same

        copper_plate
        iron_plate
    }

    copper_plate -> copper_cable
    copper_cable -> electronic_circuit
    iron_plate -> electronic_circuit
    electronic_circuit -> inserter
    iron_gear_wheel -> inserter
    iron_plate -> inserter
    iron_plate -> iron_gear_wheel
    inserter -> logistic_science_pack
    transport_belt -> logistic_science_pack
    iron_gear_wheel -> transport_belt
    iron_plate -> transport_belt
}
----

That's... disappointing (especially since now we've got two crossing edges); let's additionally align `inserter` and
`transport_belt`:

[graphviz, format=svg, opts=inline]
----
digraph {
    splines = ortho

    {
        rank = same

        copper_plate
        iron_plate
    }

    {
        rank = same

        inserter
        transport_belt
    }

    copper_plate -> copper_cable
    copper_cable -> electronic_circuit
    iron_plate -> electronic_circuit
    electronic_circuit -> inserter
    iron_gear_wheel -> inserter
    iron_plate -> inserter
    iron_plate -> iron_gear_wheel
    inserter -> logistic_science_pack
    transport_belt -> logistic_science_pack
    iron_gear_wheel -> transport_belt
    iron_plate -> transport_belt
}
----

== Case study: Chemical science pack

== Ethical dilemmas

== Future work

z3!
